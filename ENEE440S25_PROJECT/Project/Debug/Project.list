
Project.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   000001d8  08000000  08000000  00001000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00002a4c  080001d8  080001d8  000011d8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000000  08002c24  08002c24  00005540  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  3 .ARM.extab    00000000  08002c24  08002c24  00005540  2**0
                  CONTENTS
  4 .ARM          00000000  08002c24  08002c24  00005540  2**0
                  CONTENTS
  5 .preinit_array 00000000  08002c24  08002c24  00005540  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  08002c24  08002c24  00003c24  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .fini_array   00000004  08002c28  08002c28  00003c28  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  8 .data         00001540  20000000  08002c2c  00004000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .ccmsram      00000000  10000000  10000000  00005540  2**0
                  CONTENTS
 10 .bss          000000bc  20001540  20001540  00005540  2**3
                  ALLOC
 11 ._user_heap_stack 00000604  200015fc  200015fc  00005540  2**0
                  ALLOC
 12 .ARM.attributes 00000030  00000000  00000000  00005540  2**0
                  CONTENTS, READONLY
 13 .debug_line   000016af  00000000  00000000  00005570  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_line_str 000002c5  00000000  00000000  00006c1f  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_info   000006ee  00000000  00000000  00006ee4  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_abbrev 0000039a  00000000  00000000  000075d2  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_aranges 000003b0  00000000  00000000  00007970  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_str    00004d2f  00000000  00000000  00007d20  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_rnglists 00000032  00000000  00000000  0000ca4f  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .debug_macro  00001450  00000000  00000000  0000ca81  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 21 .comment      00000043  00000000  00000000  0000ded1  2**0
                  CONTENTS, READONLY
 22 .debug_frame  00000078  00000000  00000000  0000df14  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

080001d8 <__do_global_dtors_aux>:
 80001d8:	b510      	push	{r4, lr}
 80001da:	4c05      	ldr	r4, [pc, #20]	@ (80001f0 <__do_global_dtors_aux+0x18>)
 80001dc:	7823      	ldrb	r3, [r4, #0]
 80001de:	b933      	cbnz	r3, 80001ee <__do_global_dtors_aux+0x16>
 80001e0:	4b04      	ldr	r3, [pc, #16]	@ (80001f4 <__do_global_dtors_aux+0x1c>)
 80001e2:	b113      	cbz	r3, 80001ea <__do_global_dtors_aux+0x12>
 80001e4:	4804      	ldr	r0, [pc, #16]	@ (80001f8 <__do_global_dtors_aux+0x20>)
 80001e6:	f3af 8000 	nop.w
 80001ea:	2301      	movs	r3, #1
 80001ec:	7023      	strb	r3, [r4, #0]
 80001ee:	bd10      	pop	{r4, pc}
 80001f0:	20001540 	.word	0x20001540
 80001f4:	00000000 	.word	0x00000000
 80001f8:	08002c0c 	.word	0x08002c0c

080001fc <frame_dummy>:
 80001fc:	b508      	push	{r3, lr}
 80001fe:	4b03      	ldr	r3, [pc, #12]	@ (800020c <frame_dummy+0x10>)
 8000200:	b11b      	cbz	r3, 800020a <frame_dummy+0xe>
 8000202:	4903      	ldr	r1, [pc, #12]	@ (8000210 <frame_dummy+0x14>)
 8000204:	4803      	ldr	r0, [pc, #12]	@ (8000214 <frame_dummy+0x18>)
 8000206:	f3af 8000 	nop.w
 800020a:	bd08      	pop	{r3, pc}
 800020c:	00000000 	.word	0x00000000
 8000210:	20001544 	.word	0x20001544
 8000214:	08002c0c 	.word	0x08002c0c

08000218 <LPUART1_init>:

@;------------------
.global LPUART1_init	@;void LPUART1_init(); //initialize LPUART1 for ST-Link VCOM
.thumb_func
LPUART1_init:
	push {r7,lr}
 8000218:	b580      	push	{r7, lr}
	
@; --- configuration for LPUART1
@;	enable the USARTx interface clock.
	mUPDATE_DEVICEREG_BIT_TO_1 		RCC_BASE,	RCC_APB1ENR2,	RCC_APB1ENR2_LPUART1EN_Pos,	RCC_APB1ENR2_LPUART1EN  
 800021a:	f241 0000 	movw	r0, #4096	@ 0x1000
 800021e:	f2c4 0002 	movt	r0, #16386	@ 0x4002
 8000222:	6dc1      	ldr	r1, [r0, #92]	@ 0x5c
 8000224:	f041 0101 	orr.w	r1, r1, #1
 8000228:	65c1      	str	r1, [r0, #92]	@ 0x5c
1:	mCONFIRM_DEVICEREG_BIT_EQ_1 	RCC_BASE,	RCC_APB1ENR2,	RCC_APB1ENR2_LPUART1EN_Pos,	RCC_APB1ENR2_LPUART1EN
 800022a:	f241 0000 	movw	r0, #4096	@ 0x1000
 800022e:	f2c4 0002 	movt	r0, #16386	@ 0x4002
 8000232:	6dc0      	ldr	r0, [r0, #92]	@ 0x5c
 8000234:	f000 0001 	and.w	r0, r0, #1
 8000238:	f090 0001 	eors.w	r0, r0, #1
	bne 1b
 800023c:	d1f5      	bne.n	800022a <LPUART1_init+0x12>

@;	reset LPUART1`
	mUPDATE_DEVICEREG_BIT_TO_1 		RCC_BASE,	RCC_APB1RSTR2,	RCC_APB1RSTR2_LPUART1RST_Pos, 	RCC_APB1RSTR2_LPUART1RST
 800023e:	f241 0000 	movw	r0, #4096	@ 0x1000
 8000242:	f2c4 0002 	movt	r0, #16386	@ 0x4002
 8000246:	6bc1      	ldr	r1, [r0, #60]	@ 0x3c
 8000248:	f041 0101 	orr.w	r1, r1, #1
 800024c:	63c1      	str	r1, [r0, #60]	@ 0x3c
1:	mCONFIRM_DEVICEREG_BIT_EQ_1		RCC_BASE,	RCC_APB1RSTR2,	RCC_APB1RSTR2_LPUART1RST_Pos, 	RCC_APB1RSTR2_LPUART1RST
 800024e:	f241 0000 	movw	r0, #4096	@ 0x1000
 8000252:	f2c4 0002 	movt	r0, #16386	@ 0x4002
 8000256:	6bc0      	ldr	r0, [r0, #60]	@ 0x3c
 8000258:	f000 0001 	and.w	r0, r0, #1
 800025c:	f090 0001 	eors.w	r0, r0, #1
	bne 1b
 8000260:	d1f5      	bne.n	800024e <LPUART1_init+0x36>

@;	unreset LPUART1`
	mUPDATE_DEVICEREG_BIT_TO_0 		RCC_BASE,	RCC_APB1RSTR2,	RCC_APB1RSTR2_LPUART1RST_Pos, 	RCC_APB1RSTR2_LPUART1RST
 8000262:	f241 0000 	movw	r0, #4096	@ 0x1000
 8000266:	f2c4 0002 	movt	r0, #16386	@ 0x4002
 800026a:	6bc1      	ldr	r1, [r0, #60]	@ 0x3c
 800026c:	f021 0101 	bic.w	r1, r1, #1
 8000270:	63c1      	str	r1, [r0, #60]	@ 0x3c
1:	mCONFIRM_DEVICEREG_BIT_EQ_0		RCC_BASE,	RCC_APB1RSTR2,	RCC_APB1RSTR2_LPUART1RST_Pos, 	RCC_APB1RSTR2_LPUART1RST
 8000272:	f241 0000 	movw	r0, #4096	@ 0x1000
 8000276:	f2c4 0002 	movt	r0, #16386	@ 0x4002
 800027a:	6bc0      	ldr	r0, [r0, #60]	@ 0x3c
 800027c:	f010 0f01 	tst.w	r0, #1
	bne 1b
 8000280:	d1f7      	bne.n	8000272 <LPUART1_init+0x5a>

//@;	HSI16 always enable for peripheral kernels (RM0440 pg 288) !!wmh question -- this seems like a global (all peripherals, unlike LPUART1SMEN)   
	mUPDATE_DEVICEREG_BIT_TO_1 		RCC_BASE,	RCC_CR,			RCC_CR_HSIKERON_Pos, 			RCC_CR_HSIKERON
 8000282:	f241 0000 	movw	r0, #4096	@ 0x1000
 8000286:	f2c4 0002 	movt	r0, #16386	@ 0x4002
 800028a:	6801      	ldr	r1, [r0, #0]
 800028c:	f441 7100 	orr.w	r1, r1, #512	@ 0x200
 8000290:	6001      	str	r1, [r0, #0]
1:	mCONFIRM_DEVICEREG_BIT_EQ_1		RCC_BASE,	RCC_CR,			RCC_CR_HSIKERON_Pos, 			RCC_CR_HSIKERON
 8000292:	f241 0000 	movw	r0, #4096	@ 0x1000
 8000296:	f2c4 0002 	movt	r0, #16386	@ 0x4002
 800029a:	6800      	ldr	r0, [r0, #0]
 800029c:	f400 7000 	and.w	r0, r0, #512	@ 0x200
 80002a0:	f490 7000 	eors.w	r0, r0, #512	@ 0x200
	bne 1b
 80002a4:	d1f5      	bne.n	8000292 <LPUART1_init+0x7a>

@;	LPUART1 clocks disabled by the clock gating(1) during Sleep and Stop modes`(RM0440 pg 320 
	mUPDATE_DEVICEREG_BIT_TO_0 		RCC_BASE,	RCC_APB1SMENR2,	RCC_APB1SMENR2_LPUART1SMEN_Pos, RCC_APB1SMENR2_LPUART1SMEN 
 80002a6:	f241 0000 	movw	r0, #4096	@ 0x1000
 80002aa:	f2c4 0002 	movt	r0, #16386	@ 0x4002
 80002ae:	6fc1      	ldr	r1, [r0, #124]	@ 0x7c
 80002b0:	f021 0101 	bic.w	r1, r1, #1
 80002b4:	67c1      	str	r1, [r0, #124]	@ 0x7c
1:	mCONFIRM_DEVICEREG_BIT_EQ_0		RCC_BASE,	RCC_APB1SMENR2,	RCC_APB1SMENR2_LPUART1SMEN_Pos, RCC_APB1SMENR2_LPUART1SMEN 
 80002b6:	f241 0000 	movw	r0, #4096	@ 0x1000
 80002ba:	f2c4 0002 	movt	r0, #16386	@ 0x4002
 80002be:	6fc0      	ldr	r0, [r0, #124]	@ 0x7c
 80002c0:	f010 0f01 	tst.w	r0, #1
	bne 1b
 80002c4:	d1f7      	bne.n	80002b6 <LPUART1_init+0x9e>

@;	Peripherals independent clock configuration register (RM0440 pg 322): 0x2: HSI16 clock selected as LPUART1 clock
	mUPDATE_DEVICEREG_FIELD 		RCC_BASE, 	RCC_CCIPR, 		RCC_CCIPR_LPUART1SEL_Pos, 		RCC_CCIPR_LPUART1SEL_Msk,	RCC_CCIPR_LPUART1SEL_1
 80002c6:	f241 0300 	movw	r3, #4096	@ 0x1000
 80002ca:	f2c4 0302 	movt	r3, #16386	@ 0x4002
 80002ce:	f44f 6240 	mov.w	r2, #3072	@ 0xc00
 80002d2:	f44f 6100 	mov.w	r1, #2048	@ 0x800
 80002d6:	f8d3 0088 	ldr.w	r0, [r3, #136]	@ 0x88
 80002da:	ea20 0002 	bic.w	r0, r0, r2
 80002de:	ea40 0001 	orr.w	r0, r0, r1
 80002e2:	f8c3 0088 	str.w	r0, [r3, #136]	@ 0x88

@;	enable GPIOA for LPUART TX/RX
	mUPDATE_DEVICEREG_BIT_TO_1 		RCC_BASE,	RCC_AHB2ENR,	RCC_AHB2ENR_GPIOAEN_Pos,		RCC_AHB2ENR_GPIOAEN
 80002e6:	f241 0000 	movw	r0, #4096	@ 0x1000
 80002ea:	f2c4 0002 	movt	r0, #16386	@ 0x4002
 80002ee:	6cc1      	ldr	r1, [r0, #76]	@ 0x4c
 80002f0:	f041 0101 	orr.w	r1, r1, #1
 80002f4:	64c1      	str	r1, [r0, #76]	@ 0x4c

@;	configure PA2, PA3 for alternate function
	mUPDATE_DEVICEREG_FIELD 		GPIOA_BASE, GPIO_MODER, 	GPIO_MODER_MODE2_Pos,			GPIO_MODER_MODE2_Msk, 		((2)<<GPIO_MODER_MODE2_Pos)
 80002f6:	f240 0300 	movw	r3, #0
 80002fa:	f6c4 0300 	movt	r3, #18432	@ 0x4800
 80002fe:	f04f 0230 	mov.w	r2, #48	@ 0x30
 8000302:	f04f 0120 	mov.w	r1, #32
 8000306:	6818      	ldr	r0, [r3, #0]
 8000308:	ea20 0002 	bic.w	r0, r0, r2
 800030c:	ea40 0001 	orr.w	r0, r0, r1
 8000310:	6018      	str	r0, [r3, #0]
	mUPDATE_DEVICEREG_FIELD 		GPIOA_BASE, GPIO_MODER, 	GPIO_MODER_MODE3_Pos,			GPIO_MODER_MODE3_Msk, 		((2)<<GPIO_MODER_MODE3_Pos)
 8000312:	f240 0300 	movw	r3, #0
 8000316:	f6c4 0300 	movt	r3, #18432	@ 0x4800
 800031a:	f04f 02c0 	mov.w	r2, #192	@ 0xc0
 800031e:	f04f 0180 	mov.w	r1, #128	@ 0x80
 8000322:	6818      	ldr	r0, [r3, #0]
 8000324:	ea20 0002 	bic.w	r0, r0, r2
 8000328:	ea40 0001 	orr.w	r0, r0, r1
 800032c:	6018      	str	r0, [r3, #0]

@;	configure PA2 for LPUART1_TX (alternate function 12)
	mUPDATE_DEVICEREG_FIELD 		GPIOA_BASE, GPIO_AFRL, 		GPIO_AFRL_AFSEL2_Pos,			GPIO_AFRL_AFSEL2_Msk, 		((12)<<GPIO_AFRL_AFSEL2_Pos)
 800032e:	f240 0300 	movw	r3, #0
 8000332:	f6c4 0300 	movt	r3, #18432	@ 0x4800
 8000336:	f44f 6270 	mov.w	r2, #3840	@ 0xf00
 800033a:	f44f 6140 	mov.w	r1, #3072	@ 0xc00
 800033e:	6a18      	ldr	r0, [r3, #32]
 8000340:	ea20 0002 	bic.w	r0, r0, r2
 8000344:	ea40 0001 	orr.w	r0, r0, r1
 8000348:	6218      	str	r0, [r3, #32]

@;	configure PA3 for LPUART1_RX (alternate function 12)
	mUPDATE_DEVICEREG_FIELD 		GPIOA_BASE, GPIO_AFRL, 		GPIO_AFRL_AFSEL3_Pos,			GPIO_AFRL_AFSEL3_Msk, 		((12)<<GPIO_AFRL_AFSEL3_Pos)
 800034a:	f240 0300 	movw	r3, #0
 800034e:	f6c4 0300 	movt	r3, #18432	@ 0x4800
 8000352:	f44f 4270 	mov.w	r2, #61440	@ 0xf000
 8000356:	f44f 4140 	mov.w	r1, #49152	@ 0xc000
 800035a:	6a18      	ldr	r0, [r3, #32]
 800035c:	ea20 0002 	bic.w	r0, r0, r2
 8000360:	ea40 0001 	orr.w	r0, r0, r1
 8000364:	6218      	str	r0, [r3, #32]

@; configure LPUART(see RM0440 pg 1617 step-by-step) 

@;	unenable LPUART1`
	mUPDATE_DEVICEREG_BIT_TO_0 		LPUART1_BASE,	USART_CR1,	USART_CR1_UE_Pos, 	USART_CR1_UE
 8000366:	f248 0000 	movw	r0, #32768	@ 0x8000
 800036a:	f2c4 0000 	movt	r0, #16384	@ 0x4000
 800036e:	6801      	ldr	r1, [r0, #0]
 8000370:	f021 0101 	bic.w	r1, r1, #1
 8000374:	6001      	str	r1, [r0, #0]
1:	mCONFIRM_DEVICEREG_BIT_EQ_0		LPUART1_BASE,	USART_CR1,	USART_CR1_UE_Pos, 	USART_CR1_UE
 8000376:	f248 0000 	movw	r0, #32768	@ 0x8000
 800037a:	f2c4 0000 	movt	r0, #16384	@ 0x4000
 800037e:	6800      	ldr	r0, [r0, #0]
 8000380:	f010 0f01 	tst.w	r0, #1
	bne 1b
 8000384:	d1f7      	bne.n	8000376 <LPUART1_init+0x15e>

@;	enable RX
	mUPDATE_DEVICEREG_BIT_TO_1 		LPUART1_BASE,	USART_CR1,	USART_CR1_RE_Pos, 	USART_CR1_RE
 8000386:	f248 0000 	movw	r0, #32768	@ 0x8000
 800038a:	f2c4 0000 	movt	r0, #16384	@ 0x4000
 800038e:	6801      	ldr	r1, [r0, #0]
 8000390:	f041 0104 	orr.w	r1, r1, #4
 8000394:	6001      	str	r1, [r0, #0]

@;	enable TX
	mUPDATE_DEVICEREG_BIT_TO_1 		LPUART1_BASE,	USART_CR1,	USART_CR1_TE_Pos, 	USART_CR1_TE
 8000396:	f248 0000 	movw	r0, #32768	@ 0x8000
 800039a:	f2c4 0000 	movt	r0, #16384	@ 0x4000
 800039e:	6801      	ldr	r1, [r0, #0]
 80003a0:	f041 0108 	orr.w	r1, r1, #8
 80003a4:	6001      	str	r1, [r0, #0]


@;	define word length =N81 using M1:M0 = 0:0   
	mUPDATE_DEVICEREG_FIELD			LPUART1_BASE,	USART_CR1,	USART_CR1_M1_Pos,	USART_CR1_M1_Msk,		((0)<<USART_CR1_M1_Pos)
 80003a6:	f248 0300 	movw	r3, #32768	@ 0x8000
 80003aa:	f2c4 0300 	movt	r3, #16384	@ 0x4000
 80003ae:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 80003b2:	f04f 0100 	mov.w	r1, #0
 80003b6:	6818      	ldr	r0, [r3, #0]
 80003b8:	ea20 0002 	bic.w	r0, r0, r2
 80003bc:	ea40 0001 	orr.w	r0, r0, r1
 80003c0:	6018      	str	r0, [r3, #0]
	mUPDATE_DEVICEREG_FIELD			LPUART1_BASE,	USART_CR1,	USART_CR1_M0_Pos,	USART_CR1_M0_Msk,		((0)<<USART_CR1_M0_Pos)
 80003c2:	f248 0300 	movw	r3, #32768	@ 0x8000
 80003c6:	f2c4 0300 	movt	r3, #16384	@ 0x4000
 80003ca:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
 80003ce:	f04f 0100 	mov.w	r1, #0
 80003d2:	6818      	ldr	r0, [r3, #0]
 80003d4:	ea20 0002 	bic.w	r0, r0, r2
 80003d8:	ea40 0001 	orr.w	r0, r0, r1
 80003dc:	6018      	str	r0, [r3, #0]
	@; done another way
	mUPDATE_DEVICEREG_BIT_TO_0 		LPUART1_BASE,	USART_CR1,	USART_CR1_M1_Pos,	USART_CR1_M1_Msk
 80003de:	f248 0000 	movw	r0, #32768	@ 0x8000
 80003e2:	f2c4 0000 	movt	r0, #16384	@ 0x4000
 80003e6:	6801      	ldr	r1, [r0, #0]
 80003e8:	f021 5180 	bic.w	r1, r1, #268435456	@ 0x10000000
 80003ec:	6001      	str	r1, [r0, #0]
	mUPDATE_DEVICEREG_BIT_TO_0 		LPUART1_BASE,	USART_CR1,	USART_CR1_M1_Pos,	USART_CR1_M1_Msk
 80003ee:	f248 0000 	movw	r0, #32768	@ 0x8000
 80003f2:	f2c4 0000 	movt	r0, #16384	@ 0x4000
 80003f6:	6801      	ldr	r1, [r0, #0]
 80003f8:	f021 5180 	bic.w	r1, r1, #268435456	@ 0x10000000
 80003fc:	6001      	str	r1, [r0, #0]

//@;	LPUART1 input clock not divided
	mUPDATE_DEVICEREG_FIELD			LPUART1_BASE,	USART_PRESC,	USART_PRESC_PRESCALER_Pos,	USART_PRESC_PRESCALER_Msk, ((0)<< USART_PRESC_PRESCALER_Pos)
 80003fe:	f248 0300 	movw	r3, #32768	@ 0x8000
 8000402:	f2c4 0300 	movt	r3, #16384	@ 0x4000
 8000406:	f04f 020f 	mov.w	r2, #15
 800040a:	f04f 0100 	mov.w	r1, #0
 800040e:	6ad8      	ldr	r0, [r3, #44]	@ 0x2c
 8000410:	ea20 0002 	bic.w	r0, r0, r2
 8000414:	ea40 0001 	orr.w	r0, r0, r1
 8000418:	62d8      	str	r0, [r3, #44]	@ 0x2c

@;	set LPUART1 baud rate (USART_BRR.BRR = USARTDIV = 16000000/115200 = 138 =0x8A //see example, RM0440 pg 1627) (!!wmh : USART_BRR_LPUART_Msk is 16 bits; this macro could fail when value is >256) 
//	mUPDATE_DEVICEREG_FIELD			LPUART1_BASE,	USART_BRR,	USART_BRR_LPUART_Pos,	USART_BRR_LPUART_Msk,	((0x8A)<<USART_BRR_LPUART_Pos)
// 	mUPDATE_DEVICEREG_FIELD			LPUART1_BASE,	USART_BRR,	USART_BRR_LPUART_Pos,USART_BRR_LPUART_Msk,	((0x1234)<<USART_BRR_LPUART_Pos)
 	mUPDATE_DEVICEREG_FIELD			LPUART1_BASE,	USART_BRR,	USART_BRR_LPUART_Pos,USART_BRR_LPUART_Msk,	((0x008AE4)<<USART_BRR_LPUART_Pos)
 800041a:	f248 0300 	movw	r3, #32768	@ 0x8000
 800041e:	f2c4 0300 	movt	r3, #16384	@ 0x4000
 8000422:	f64f 72ff 	movw	r2, #65535	@ 0xffff
 8000426:	f2c0 020f 	movt	r2, #15
 800042a:	f648 21e4 	movw	r1, #35556	@ 0x8ae4
 800042e:	68d8      	ldr	r0, [r3, #12]
 8000430:	ea20 0002 	bic.w	r0, r0, r2
 8000434:	ea40 0001 	orr.w	r0, r0, r1
 8000438:	60d8      	str	r0, [r3, #12]

@;	set number of stop bits =1
	mUPDATE_DEVICEREG_FIELD			LPUART1_BASE,	USART_CR2,	USART_CR2_STOP_Pos,	USART_CR2_STOP_Msk,		((0x0)<<USART_CR2_STOP_Pos)
 800043a:	f248 0300 	movw	r3, #32768	@ 0x8000
 800043e:	f2c4 0300 	movt	r3, #16384	@ 0x4000
 8000442:	f44f 5240 	mov.w	r2, #12288	@ 0x3000
 8000446:	f04f 0100 	mov.w	r1, #0
 800044a:	6858      	ldr	r0, [r3, #4]
 800044c:	ea20 0002 	bic.w	r0, r0, r2
 8000450:	ea40 0001 	orr.w	r0, r0, r1
 8000454:	6058      	str	r0, [r3, #4]
	
@;	enable LPUART1`
	mUPDATE_DEVICEREG_BIT_TO_1 		LPUART1_BASE,	USART_CR1,	USART_CR1_UE_Pos, 	USART_CR1_UE
 8000456:	f248 0000 	movw	r0, #32768	@ 0x8000
 800045a:	f2c4 0000 	movt	r0, #16384	@ 0x4000
 800045e:	6801      	ldr	r1, [r0, #0]
 8000460:	f041 0101 	orr.w	r1, r1, #1
 8000464:	6001      	str	r1, [r0, #0]
1:	mCONFIRM_DEVICEREG_BIT_EQ_1		LPUART1_BASE,	USART_CR1,	USART_CR1_UE_Pos, 	USART_CR1_UE
 8000466:	f248 0000 	movw	r0, #32768	@ 0x8000
 800046a:	f2c4 0000 	movt	r0, #16384	@ 0x4000
 800046e:	6800      	ldr	r0, [r0, #0]
 8000470:	f000 0001 	and.w	r0, r0, #1
 8000474:	f090 0001 	eors.w	r0, r0, #1
	bne 1b
 8000478:	d1f5      	bne.n	8000466 <LPUART1_init+0x24e>

	pop {r7,pc}
 800047a:	bd80      	pop	{r7, pc}

0800047c <LPUART1_RX_interrupt_enable>:

.global LPUART1_RX_interrupt_enable		// void LPUART1_RX_interrupt_enable(); //what it says
.thumb_func
LPUART1_RX_interrupt_enable:
	@; disable RX interrupt
	mUPDATE_DEVICEREG_BIT_TO_0 		LPUART1_BASE,	USART_CR1,	USART_CR1_RXNEIE_Pos, 	USART_CR1_RXNEIE_Msk
 800047c:	f248 0000 	movw	r0, #32768	@ 0x8000
 8000480:	f2c4 0000 	movt	r0, #16384	@ 0x4000
 8000484:	6801      	ldr	r1, [r0, #0]
 8000486:	f021 0120 	bic.w	r1, r1, #32
 800048a:	6001      	str	r1, [r0, #0]

	@; configure NVIC for LPUART1 interrupt
	.set NVIC_ISER_wordoffset,(4*(LPUART1_IRQn>>5))
	.set NVIC_ISER_bitpos,(LPUART1_IRQn&0x1F) 
	.set NVIC_IPR_byteoffset, (LPUART1_IRQn)
	mBITSET_DEVICEREG 		NVIC_ISER,	NVIC_ISER_wordoffset,	NVIC_ISER_bitpos
 800048c:	f24e 1300 	movw	r3, #57600	@ 0xe100
 8000490:	f2ce 0300 	movt	r3, #57344	@ 0xe000
 8000494:	f04f 6200 	mov.w	r2, #134217728	@ 0x8000000
 8000498:	609a      	str	r2, [r3, #8]
	mBYTEWRITE_DEVICEREG 	NVIC_IPR,	NVIC_IPR_byteoffset, 	0x80
 800049a:	f24e 4300 	movw	r3, #58368	@ 0xe400
 800049e:	f2ce 0300 	movt	r3, #57344	@ 0xe000
 80004a2:	f04f 0280 	mov.w	r2, #128	@ 0x80
 80004a6:	f883 205b 	strb.w	r2, [r3, #91]	@ 0x5b

	@; clear RX of data (if any) to reset the RXINE
	MOV_imm32 r3,LPUART1_BASE
 80004aa:	f248 0300 	movw	r3, #32768	@ 0x8000
 80004ae:	f2c4 0300 	movt	r3, #16384	@ 0x4000
	ldr r0,[r3,#USART_RDR]
 80004b2:	6a58      	ldr	r0, [r3, #36]	@ 0x24

	@; enable RX interrupt
	mUPDATE_DEVICEREG_BIT_TO_1 		LPUART1_BASE,	USART_CR1,	USART_CR1_RXNEIE_Pos, 	USART_CR1_RXNEIE_Msk
 80004b4:	f248 0000 	movw	r0, #32768	@ 0x8000
 80004b8:	f2c4 0000 	movt	r0, #16384	@ 0x4000
 80004bc:	6801      	ldr	r1, [r0, #0]
 80004be:	f041 0120 	orr.w	r1, r1, #32
 80004c2:	6001      	str	r1, [r0, #0]

	@; done
	bx lr
 80004c4:	4770      	bx	lr

080004c6 <HW_userCOM_init>:
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	.global HW_userCOM_init // void HW_userCOM_init(); //initializes LPUART1 for asynchronous 115200N81 communication with RX interrupt enabled										
	.thumb_func
HW_userCOM_init:
	push {r7,lr}
 80004c6:	b580      	push	{r7, lr}
	bl userCOM_RXbuffer_init @;initializes LPUART1 ring buffer control with main()'s values for userCOM_RXDATACOUNT,userCOM_RXDATASTORAGE
 80004c8:	f002 f9b9 	bl	800283e <userCOM_RXbuffer_init>
	bl LPUART1_init
 80004cc:	f7ff fea4 	bl	8000218 <LPUART1_init>
	bl LPUART1_RX_interrupt_enable
 80004d0:	f7ff ffd4 	bl	800047c <LPUART1_RX_interrupt_enable>
	pop {r7,pc}
 80004d4:	bd80      	pop	{r7, pc}

080004d6 <HW_userCOM_nbgetchar>:
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

	.global HW_userCOM_nbgetchar @;conditional UART getchar()
	.thumb_func
HW_userCOM_nbgetchar: @; char HW_userCOM_nbgetchar(void);	//success: return data>=0; failure: return -1
 	push {r7,lr}
 80004d6:	b580      	push	{r7, lr}
	MOV_imm32 r3,LPUART1_BASE	
 80004d8:	f248 0300 	movw	r3, #32768	@ 0x8000
 80004dc:	f2c4 0300 	movt	r3, #16384	@ 0x4000

	@;initialize success/fail to 'fail'
	mov r0,#-1		
 80004e0:	f04f 30ff 	mov.w	r0, #4294967295
	@;check if new data is available
	ldr r2,[r3,#USART_ISR]			@;is receiver not empty (RXNE ==1)?
 80004e4:	69da      	ldr	r2, [r3, #28]
	tst r2,#(1<<5)				@; ..
 80004e6:	f012 0f20 	tst.w	r2, #32
	beq	1f						@;	no, receiver is empty -- return -1 (no data is available)
 80004ea:	d001      	beq.n	80004f0 <HW_userCOM_nbgetchar+0x1a>
	ldrb r0,[r3,#USART_RDR]			@;	yes, receiver is not empty -- get new data (automatically clears RXNE)
 80004ec:	f893 0024 	ldrb.w	r0, [r3, #36]	@ 0x24
@;	ands r0,#0xFF				@;	clean it up to 8 bits
@;	strb r0,[r3,#USART_DR]			@;  echo it back for debug
1:	pop {r7,pc}					@; 	and return ( data>=0 =='success' )
 80004f0:	bd80      	pop	{r7, pc}

080004f2 <HW_userCOM_okgetchar>:

	.global HW_userCOM_okgetchar    @; non-blocking; ok to get char return non-zero; not ok: return 0
	.thumb_func
HW_userCOM_okgetchar: @; char HW_userCOM_okgetchar(void);	//success: return non-zero;  failure: return 0
 	push {r7,lr}
 80004f2:	b580      	push	{r7, lr}
	MOV_imm32 r3,LPUART1_BASE	
 80004f4:	f248 0300 	movw	r3, #32768	@ 0x8000
 80004f8:	f2c4 0300 	movt	r3, #16384	@ 0x4000
	ldr r0,[r3,#USART_ISR]			@;is receiver not empty (RXNE ==1)?
 80004fc:	69d8      	ldr	r0, [r3, #28]
	and r0,#(1<<5)				@; ..
 80004fe:	f000 0020 	and.w	r0, r0, #32
	pop {r7,pc}					@; return RXNE status
 8000502:	bd80      	pop	{r7, pc}

08000504 <HW_userCOM_nbputchar>:


	.global HW_userCOM_nbputchar		@;conditional UART putchar()
	.thumb_func
HW_userCOM_nbputchar: @;  int HW_userCOM_nbputchar(char data);	//success: return +1; failure: return -1
 	push {r7,lr}
 8000504:	b580      	push	{r7, lr}
	MOV_imm32 r3,LPUART1_BASE	
 8000506:	f248 0300 	movw	r3, #32768	@ 0x8000
 800050a:	f2c4 0300 	movt	r3, #16384	@ 0x4000

	@;check if sending is ok
	ldr r2,[r3,#USART_ISR]			@;is transmitter empty (TXE ==1)?
 800050e:	69da      	ldr	r2, [r3, #28]
	tst r2,#(1<<7)				@; .. 
 8000510:	f012 0f80 	tst.w	r2, #128	@ 0x80
	beq 1f						@;	no, transmitter not empty -- return -1 (sending is blocked)
 8000514:	d004      	beq.n	8000520 <HW_userCOM_nbputchar+0x1c>
	strb r0,[r3,#USART_TDR]			@;	yes -- send data (automatically clears TXE)
 8000516:	f883 0028 	strb.w	r0, [r3, #40]	@ 0x28
	mov r0,#1					@;		mark 'success'
 800051a:	f04f 0001 	mov.w	r0, #1
	pop {r7,pc}					@; 		and return +1 (data was sent)
 800051e:	bd80      	pop	{r7, pc}
1:	mov r0,#-1					@;mark 'failure'
 8000520:	f04f 30ff 	mov.w	r0, #4294967295
	pop {r7,pc}					@; 		and return -1 (sending is blocked)
 8000524:	bd80      	pop	{r7, pc}

08000526 <HW_userCOM_okputchar>:

	.global HW_userCOM_okputchar		@;conditional UART putchar()
	.thumb_func
HW_userCOM_okputchar: @;  int HW_userCOM_okputchar(char data);	ok to putchar return non-zero; not ok: return 0
 	push {r7,lr}
 8000526:	b580      	push	{r7, lr}
	MOV_imm32 r3,LPUART1_BASE	
 8000528:	f248 0300 	movw	r3, #32768	@ 0x8000
 800052c:	f2c4 0300 	movt	r3, #16384	@ 0x4000
	@;check if sending is ok
	ldr r0,[r3,#USART_ISR]		@;is transmitter empty (TXE ==1)?
 8000530:	69d8      	ldr	r0, [r3, #28]
	ands r0,#(1<<7)				@; yes -- result is 128
 8000532:	f010 0080 	ands.w	r0, r0, #128	@ 0x80
	sub r0,#1					@; no -- result is -1 after the subtract
 8000536:	f1a0 0001 	sub.w	r0, r0, #1
	pop {r7,pc}					@;  return TXE status: ok: 127 not ok: -1
 800053a:	bd80      	pop	{r7, pc}

0800053c <HW_userCOM_bgetchar>:


	.global HW_userCOM_bgetchar		@; blocking UART getchar()
	.thumb_func
HW_userCOM_bgetchar: @;  int HW_userCOM_bgetchar(void);	//blocks until new data, then return data in r0
 	push {r7,lr}
 800053c:	b580      	push	{r7, lr}
	MOV_imm32 r3,LPUART1_BASE	
 800053e:	f248 0300 	movw	r3, #32768	@ 0x8000
 8000542:	f2c4 0300 	movt	r3, #16384	@ 0x4000

	@;check if new data is available
1:	ldr r2,[r3,#USART_ISR]			@;is receiver not empty (RXNE ==1)?
 8000546:	69da      	ldr	r2, [r3, #28]
	tst r2,#(1<<5)				@; ..
 8000548:	f012 0f20 	tst.w	r2, #32
	beq	1b						@;	no, receiver is empty -- keep testing
 800054c:	d0fb      	beq.n	8000546 <HW_userCOM_bgetchar+0xa>
	ldrb r0,[r3,#USART_RDR]			@;	yes, receiver is not empty -- get new data (automatically clears RXNE)
 800054e:	f893 0024 	ldrb.w	r0, [r3, #36]	@ 0x24
@;	ands r0,#0xFF				@;	clean it up to 8 bits
	pop {r7,pc}					@; 	and return ( data>=0 =='success' )
 8000552:	bd80      	pop	{r7, pc}

08000554 <HW_userCOM_bputchar>:


	.global HW_userCOM_bputchar		@;blocking UART putchar()
	.thumb_func
HW_userCOM_bputchar: @;  void HW_userCOM_bputchar(char data);	//block until character can be sent
 	push {r7,lr}
 8000554:	b580      	push	{r7, lr}
	MOV_imm32 r3,LPUART1_BASE	
 8000556:	f248 0300 	movw	r3, #32768	@ 0x8000
 800055a:	f2c4 0300 	movt	r3, #16384	@ 0x4000

	@;check if sending is ok
1:	ldr r2,[r3,#USART_ISR]			@;is transmitter empty (TXE ==1)?
 800055e:	69da      	ldr	r2, [r3, #28]
	tst r2,#(1<<7)				@; .. 
 8000560:	f012 0f80 	tst.w	r2, #128	@ 0x80
	beq 1b						@;	no, transmitter not empty -- keep testing
 8000564:	d0fb      	beq.n	800055e <HW_userCOM_bputchar+0xa>
	strb r0,[r3,#USART_TDR]			@;	yes -- send data (automatically clears TXE)
 8000566:	f883 0028 	strb.w	r0, [r3, #40]	@ 0x28
	pop {r7,pc}					@; 		and return
 800056a:	bd80      	pop	{r7, pc}

0800056c <HW_userCOM_putchar>:

	.global HW_userCOM_putchar
	.thumb_func
HW_userCOM_putchar:					@; debug: unconditional write to UART DR and return
 	push {r7,lr}
 800056c:	b580      	push	{r7, lr}
	MOV_imm32 r3,LPUART1_BASE	
 800056e:	f248 0300 	movw	r3, #32768	@ 0x8000
 8000572:	f2c4 0300 	movt	r3, #16384	@ 0x4000
	strb r0,[r3,#USART_TDR]			@;	yes -- send data (automatically clears TXE)
 8000576:	f883 0028 	strb.w	r0, [r3, #40]	@ 0x28
	pop {r7,pc}					@; 		and return
 800057a:	bd80      	pop	{r7, pc}

0800057c <LPUART1_IRQHandler>:


	.global LPUART1_IRQHandler			@;using label from interrupt table
	.thumb_func
LPUART1_IRQHandler: 					@; entered for both RX and TX interrupts
	push {r7,lr}	@; even though we're an interrupt, we're not a leaf function, so must do this
 800057c:	b580      	push	{r7, lr}
	@;
	@; get USART structure pointer
	MOV_imm32 r3,LPUART1_BASE			@; USART2 register structure  !!
 800057e:	f248 0300 	movw	r3, #32768	@ 0x8000
 8000582:	f2c4 0300 	movt	r3, #16384	@ 0x4000
	@;read flags to determine source of interrupt		
	ldr r1,[r3,#USART_ISR]					@;USART status in r1
 8000586:	69d9      	ldr	r1, [r3, #28]
	tst r1,#(0x0F)						@;break on overrun, noise-detected, framing, or parity error
 8000588:	f011 0f0f 	tst.w	r1, #15
	bne LPUART1_IRQHandler_error_trap	@;	yes -- 
 800058c:	d113      	bne.n	80005b6 <LPUART1_IRQHandler_error_trap>
	tst r1,#(1<<5)	@;testing RXNE		@;new RX data?
 800058e:	f011 0f20 	tst.w	r1, #32
	beq LPUART1_IRQHandler_noRXdata		@;	no -- go check if we need to transmit
 8000592:	d003      	beq.n	800059c <LPUART1_IRQHandler_noRXdata>
	@; here with new received char to save in USART2 RX ringbuffer						
										@; MOV_imm32 r0,userCOM_RXbufHANDLE@;get USART2 ringbuffer handle
	ldrh r0,[r3,#USART_RDR]					@; ldrh r1,[r3,#RDR]				@;read new RX data value
 8000594:	8c98      	ldrh	r0, [r3, #36]	@ 0x24
	bl userCOM_ringbufbuf_wr			@; bl ringbufbuf_wr					@; save the new character  -- ringbufbuf_wr(uint8_t *bufHANDLE,  uint8_t data ); )
 8000596:	f002 fa14 	bl	80029c2 <userCOM_ringbufbuf_wr>
	@;here with new data saved in USART2 RX ringbuffer. No warning if buffer is full; oldest data is overwritten.  
	@;
	pop {r7,pc}							@;done -- if USART2 TX interrupt is enabled and TXE=1 we'll get a followon interrupt that goes to LPUART1_IRQHandler_noRXdata below
 800059a:	bd80      	pop	{r7, pc}

0800059c <LPUART1_IRQHandler_noRXdata>:

	@;here if source of interrupt is not error or RXNE so could be TXE  
LPUART1_IRQHandler_noRXdata: @;if TX interrupt and messages not empty, send next character 
	tst r1,#(1<<7)						@;test TXE -- r1 retains image of SR from above
 800059c:	f011 0f80 	tst.w	r1, #128	@ 0x80
	beq LPUART1_IRQHandler_unknown_trap	@;we've eliminated all of the possible interrupt sources, so we have a mystery
 80005a0:	d00d      	beq.n	80005be <LPUART1_IRQHandler_unknown_trap>
@; <snip> broken code which trasmits from message queue
	b LPUART1_IRQHandler_TXcompleted		@;!!FIX ME: currently we are not not using TX interrupts -- task1 is polling ok_userCOM_putchar and sending with HW_userCOM_putchar
 80005a2:	e001      	b.n	80005a8 <LPUART1_IRQHandler_TXcompleted>
	b LPUART1_IRQHandler_TXcontinues 
 80005a4:	e7ff      	b.n	80005a6 <LPUART1_IRQHandler_TXcontinues>

080005a6 <LPUART1_IRQHandler_TXcontinues>:
	LPUART1_IRQHandler_TXcontinues:		@; current message is not finished or new message is installed on list -- return from interrupt
	pop {r7,pc}														
 80005a6:	bd80      	pop	{r7, pc}

080005a8 <LPUART1_IRQHandler_TXcompleted>:

	@;here if message is completed and no more messages on list. Clear message pointers and turn interrupt off. 
LPUART1_IRQHandler_TXcompleted:	
	mov r0,#0							@;clear task messages list
 80005a8:	f04f 0000 	mov.w	r0, #0
@!!	MOV_imm32 r2,userCOM_MsgCtl			@; future fixup - if TX ever gets connected to message queue
@!!	str r0,[r2,#(MSGHEAD_PTR)]			@; ..
@!!	str r0,[r2,#(MSGTAIL_PTR)]			@; ..
	ldr r0,[r3,#USART_CR1]					@; disable transmit interrupt 
 80005ac:	6818      	ldr	r0, [r3, #0]
	bic r0,#( (1<<7) ) @; TXEIE=bit7	@; ..
 80005ae:	f020 0080 	bic.w	r0, r0, #128	@ 0x80
	str r0,[r3,#USART_CR1]					@; .. 
 80005b2:	6018      	str	r0, [r3, #0]
	pop {r7,pc}							@; return from interrupt
 80005b4:	bd80      	pop	{r7, pc}

080005b6 <LPUART1_IRQHandler_error_trap>:

	@;here with SR in r1 when one or more of ORE, NF, FE, PE (overrun, noise, framing or parity) error bits are set
LPUART1_IRQHandler_error_trap:
	mov r0,0x0F							@;clear error bits 
 80005b6:	f04f 000f 	mov.w	r0, #15
	str r0,[r3,#USART_ICR]					@; ..
 80005ba:	6218      	str	r0, [r3, #32]
	@;record this incident
@!!	bl userCOM_updateRXBUF_NUMERRORS																							
	pop {r7,pc}							@; returns from interrupt
 80005bc:	bd80      	pop	{r7, pc}

080005be <LPUART1_IRQHandler_unknown_trap>:
										
LPUART1_IRQHandler_unknown_trap:	@;kludge 'fix' for debugging question of why we got an interrupt without any flags set. !!?? maybe because the NVIC pending flag is set?
	@; record this event						
@!!	bl userCOM_updateRXBUF_NUMUNKNOWNS			
	pop {r7,pc}							@; returns from interrupt
 80005be:	bd80      	pop	{r7, pc}

080005c0 <LPUART1_IRQHandler_putchar_failure_trap>:

LPUART1_IRQHandler_putchar_failure_trap: @;  not called in this text but easy enough to implement, so done
	@; record this incident
@!!	bl userCOM_updateRXBUF_NUMPUTFAILS														
	pop {r7,pc}							@; returns from interrupt
 80005c0:	bd80      	pop	{r7, pc}

080005c2 <userCOM_IRQenable>:

// stuff added to connect with MoT_userCOM0x.S !!wmh : don't know where this gets used (if at all)
	.global userCOM_IRQenable
	.thumb_func
userCOM_IRQenable: @; int LPUART1_IRQinit(void); //returns 0 indicating success
	push {r7,lr}
 80005c2:	b580      	push	{r7, lr}
	MOV_imm32 r3,LPUART1_BASE
 80005c4:	f248 0300 	movw	r3, #32768	@ 0x8000
 80005c8:	f2c4 0300 	movt	r3, #16384	@ 0x4000
	ldr r2,[r3,#USART_CR1]
 80005cc:	681a      	ldr	r2, [r3, #0]
	orr r2,#( (1<<7) ) @; TXEIE=bit7
 80005ce:	f042 0280 	orr.w	r2, r2, #128	@ 0x80
	str r2,[r3,#USART_CR1]
 80005d2:	601a      	str	r2, [r3, #0]
	mov r0,#0 
 80005d4:	f04f 0000 	mov.w	r0, #0
	pop {r7,pc}
 80005d8:	bd80      	pop	{r7, pc}

080005da <SysTick_init>:
	.thumb						@; Use thumb instructions only

	.global SysTick_init
	.thumb_func
SysTick_init: @;initialize SysTick timer
	push {r7,lr}				@;save callers context 	
 80005da:	b580      	push	{r7, lr}

	MOV_imm32 r1,SYST_CSR		@;get SysTick control register base
 80005dc:	f24e 0110 	movw	r1, #57360	@ 0xe010
 80005e0:	f2ce 0100 	movt	r1, #57344	@ 0xe000
	@;stop SysTick counter and interrupt before making changes
	mov r2,0x0 					
 80005e4:	f04f 0200 	mov.w	r2, #0
	str r2,[r1]
 80005e8:	600a      	str	r2, [r1, #0]
	@;set SysTick period	
	MOV_imm32 r2,SysTick_ReloadValue @; as established in SystemClock_init2.S
 80005ea:	f240 0200 	movw	r2, #0
 80005ee:	f2c2 0200 	movt	r2, #8192	@ 0x2000
	ldr r2,[r2]					@; ..
 80005f2:	6812      	ldr	r2, [r2, #0]
	str r2,[r1,#4]				@;write SysTick Reload Value Register, SYST_RVR
 80005f4:	604a      	str	r2, [r1, #4]
	@;clear current SysTick count
	str r2,[r1,#8]				@;write SysTick Current Value Register, SYST_CVR (storing any value does it)
 80005f6:	608a      	str	r2, [r1, #8]
	@;establish SysTick priority
	MOV_imm32 r3,SysTick_PR		@;byte-address of SysTick priority register
 80005f8:	f64e 5323 	movw	r3, #60707	@ 0xed23
 80005fc:	f2ce 0300 	movt	r3, #57344	@ 0xe000
	mov r0,#SYSTICK_PRI			@;defined above
 8000600:	f04f 0080 	mov.w	r0, #128	@ 0x80
	and r0,0xF0					@;mask value -- only upper 4 bits of are used
 8000604:	f000 00f0 	and.w	r0, r0, #240	@ 0xf0
	strb r0,[r3]				@; ..
 8000608:	7018      	strb	r0, [r3, #0]
	@;enable SysTick interrupt, enable the counter using core clock
	mov r2,0x07
 800060a:	f04f 0207 	mov.w	r2, #7
	str r2,[r1,#0]
 800060e:	600a      	str	r2, [r1, #0]

	pop {r7,pc}					@;return to caller
 8000610:	bd80      	pop	{r7, pc}

08000612 <SysTick_Handler>:
SysTick_Handler: @; here for each SysTick timer timeout
	@; anything goes here -- r0-r3 dont need to be preserved but everything must be not used or else preserved
	@; you can call other functions but r14 (lr)  must be preserved, e.g. pushed before any 'bl' 
	@; when you are finished, stack must be where it started
	
	push {r7,lr}				@;save return key and interruptees context
 8000612:	b580      	push	{r7, lr}

	@;update absolute msecs 
	MOV_imm32 r2,SysTick_absmsecs @; get address of global variable SysTick_absmsecs in .SysTick_shmem (defined above)
 8000614:	f241 5260 	movw	r2, #5472	@ 0x1560
 8000618:	f2c2 0200 	movt	r2, #8192	@ 0x2000
	ldr r0,[r2]					@; current value of SysTick_absmsecs low word 
 800061c:	6810      	ldr	r0, [r2, #0]
	adds r0,r0,#1				@; is updated
 800061e:	3001      	adds	r0, #1
	str r0,[r2],#4				@; 	.. and r2 points to high word of SysTick_absmsecs
 8000620:	f842 0b04 	str.w	r0, [r2], #4
	ldr r0,[r2]					@; current value of SysTick_absmsecs high word 
 8000624:	6810      	ldr	r0, [r2, #0]
	adc r0,r0,#0				@; is updated
 8000626:	f140 0000 	adc.w	r0, r0, #0
	str r0,[r2] 				@; ..
 800062a:	6010      	str	r0, [r2, #0]
	

	@;update msecs 
	MOV_imm32 r2,SysTick_msecs	@; get address of global variable SysTick_msecs in .SysTick_shmem (defined above)
 800062c:	f241 525c 	movw	r2, #5468	@ 0x155c
 8000630:	f2c2 0200 	movt	r2, #8192	@ 0x2000
	ldr r0,[r2]					@; current value of SysTick_msecs in r0
 8000634:	6810      	ldr	r0, [r2, #0]
	add r0,r0,#1				@; is updated
 8000636:	f100 0001 	add.w	r0, r0, #1
	str r0,[r2]					@; ..
 800063a:	6010      	str	r0, [r2, #0]
	cmp r0,#1000				@; has one second elapsed?
 800063c:	f5b0 7f7a 	cmp.w	r0, #1000	@ 0x3e8
	blo SysTick_Handler_exit	@;	no -- return from interrupt 
 8000640:	d30a      	bcc.n	8000658 <SysTick_Handler_exit>
								@;  yes -- do updates for new second
	mov r0,#0					@;		reset msec count
 8000642:	f04f 0000 	mov.w	r0, #0
	str r0,[r2]					@; 		..
 8000646:	6010      	str	r0, [r2, #0]

	@;update secs counter
	MOV_imm32 r2,SysTick_secs	@; get address of global variable SysTick_secs in .SysTick_shmem (defined above)
 8000648:	f241 5268 	movw	r2, #5480	@ 0x1568
 800064c:	f2c2 0200 	movt	r2, #8192	@ 0x2000
	ldr r0,[r2]					@; current value of SysTick_secs in r0 (max: 2**32= 136 years) 
 8000650:	6810      	ldr	r0, [r2, #0]
	add r0,r0,#1				@; is updated
 8000652:	f100 0001 	add.w	r0, r0, #1
	str r0,[r2]					@; ..
 8000656:	6010      	str	r0, [r2, #0]

08000658 <SysTick_Handler_exit>:
	
	@;here with SysTick counters updated
SysTick_Handler_exit:
	@;SystTick doesnt require resetting an interrupt flag like normal interrupts do
	pop {r7,pc}					@;magic Cortex-M interrupt kludge takes you back to the interrupted program
 8000658:	bd80      	pop	{r7, pc}

0800065a <SystemClock_init2>:
	#include "bit-op_macros.S"

	.global SystemClock_init2	@ make SystemClock_init() visible everywhere
	.thumb_func					@; make linker set bit0 =1 in any absolute indirect references (function pointers) to this function
SystemClock_init2:
	push {r7,lr}
 800065a:	b580      	push	{r7, lr}

	@; )	update and confirm : turn HSI16 oscillator 'ON' (RCC_CR_HSION, RCC_CR_HSIRDY) (mSET_DEVICREG_BIT ok) 
	mUPDATE_DEVICEREG_BIT_TO_1 	RCC_BASE, RCC_CR, 	RCC_CR_HSION_Pos, 	RCC_CR_HSION_Msk
 800065c:	f241 0000 	movw	r0, #4096	@ 0x1000
 8000660:	f2c4 0002 	movt	r0, #16386	@ 0x4002
 8000664:	6801      	ldr	r1, [r0, #0]
 8000666:	f441 7180 	orr.w	r1, r1, #256	@ 0x100
 800066a:	6001      	str	r1, [r0, #0]
1:	mCONFIRM_DEVICEREG_BIT_EQ_1	RCC_BASE, RCC_CR, 	RCC_CR_HSIRDY_Pos, 	RCC_CR_HSIRDY_Msk	
 800066c:	f241 0000 	movw	r0, #4096	@ 0x1000
 8000670:	f2c4 0002 	movt	r0, #16386	@ 0x4002
 8000674:	6800      	ldr	r0, [r0, #0]
 8000676:	f400 6080 	and.w	r0, r0, #1024	@ 0x400
 800067a:	f490 6080 	eors.w	r0, r0, #1024	@ 0x400
	bne 1b
 800067e:	d1f5      	bne.n	800066c <SystemClock_init2+0x12>

	@; )	update and confirm : change SysClk source to HSI16 (RCC_CFGR_SW,RCC_CFGR_SWS)
	mUPDATE_DEVICEREG_FIELD RCC_BASE, RCC_CFGR, RCC_CFGR_SWS_Pos, RCC_CFGR_SWS_Msk, RCC_CFGR_SW_HSI
 8000680:	f241 0300 	movw	r3, #4096	@ 0x1000
 8000684:	f2c4 0302 	movt	r3, #16386	@ 0x4002
 8000688:	f04f 020c 	mov.w	r2, #12
 800068c:	f04f 0101 	mov.w	r1, #1
 8000690:	6898      	ldr	r0, [r3, #8]
 8000692:	ea20 0002 	bic.w	r0, r0, r2
 8000696:	ea40 0001 	orr.w	r0, r0, r1
 800069a:	6098      	str	r0, [r3, #8]
1:	mCONFIRM_DEVICEREG_FIELD RCC_BASE, RCC_CFGR, RCC_CFGR_SWS_Pos, RCC_CFGR_SWS_Msk, RCC_CFGR_SWS_HSI
 800069c:	f241 0300 	movw	r3, #4096	@ 0x1000
 80006a0:	f2c4 0302 	movt	r3, #16386	@ 0x4002
 80006a4:	f04f 020c 	mov.w	r2, #12
 80006a8:	f04f 0104 	mov.w	r1, #4
 80006ac:	6898      	ldr	r0, [r3, #8]
 80006ae:	ea00 0002 	and.w	r0, r0, r2
 80006b2:	4048      	eors	r0, r1
	bne 1b
 80006b4:	d1f2      	bne.n	800069c <SystemClock_init2+0x42>

	@; )	update and confirm : turn PLL 'OFF' (RCC_CR_PLLON=0, RCC_CR_PLLRDY=0)
	mUPDATE_DEVICEREG_BIT_TO_0 	RCC_BASE, RCC_CR, 	RCC_CR_PLLON_Pos, 	RCC_CR_PLLON_Msk
 80006b6:	f241 0000 	movw	r0, #4096	@ 0x1000
 80006ba:	f2c4 0002 	movt	r0, #16386	@ 0x4002
 80006be:	6801      	ldr	r1, [r0, #0]
 80006c0:	f021 7180 	bic.w	r1, r1, #16777216	@ 0x1000000
 80006c4:	6001      	str	r1, [r0, #0]
1:	mCONFIRM_DEVICEREG_BIT_EQ_0	RCC_BASE, RCC_CR, 	RCC_CR_PLLRDY_Pos, 	RCC_CR_PLLRDY_Msk	
 80006c6:	f241 0000 	movw	r0, #4096	@ 0x1000
 80006ca:	f2c4 0002 	movt	r0, #16386	@ 0x4002
 80006ce:	6800      	ldr	r0, [r0, #0]
 80006d0:	f010 7f00 	tst.w	r0, #33554432	@ 0x2000000
	bne 1b
 80006d4:	d1f7      	bne.n	80006c6 <SystemClock_init2+0x6c>

	@; )	update and confirm : FLASH wait state setting for anticipated clock frequencies < 150MHz (FLASH_ACR_LATENCY)
	mUPDATE_DEVICEREG_FIELD FLASH_BASE, FLASH_ACR, FLASH_ACR_LATENCY_Pos, FLASH_ACR_LATENCY_Msk, FLASH_ACR_LATENCY_4WS
 80006d6:	f240 0300 	movw	r3, #0
 80006da:	f6c0 0300 	movt	r3, #2048	@ 0x800
 80006de:	f04f 020f 	mov.w	r2, #15
 80006e2:	f04f 0104 	mov.w	r1, #4
 80006e6:	6818      	ldr	r0, [r3, #0]
 80006e8:	ea20 0002 	bic.w	r0, r0, r2
 80006ec:	ea40 0001 	orr.w	r0, r0, r1
 80006f0:	6018      	str	r0, [r3, #0]
1:	mCONFIRM_DEVICEREG_FIELD FLASH_BASE, FLASH_ACR, FLASH_ACR_LATENCY_Pos, FLASH_ACR_LATENCY_Msk, FLASH_ACR_LATENCY_4WS
 80006f2:	f240 0300 	movw	r3, #0
 80006f6:	f6c0 0300 	movt	r3, #2048	@ 0x800
 80006fa:	f04f 020f 	mov.w	r2, #15
 80006fe:	f04f 0104 	mov.w	r1, #4
 8000702:	6818      	ldr	r0, [r3, #0]
 8000704:	ea00 0002 	and.w	r0, r0, r2
 8000708:	4048      	eors	r0, r1
//!!	bne 1b

	@; )	confirm : power settings for anticipated CPU clock frequencies < 150MHz (PWR_CR5_R1MODE)
1:	mCONFIRM_DEVICEREG_FIELD PWR_BASE, PWR_CR1, PWR_CR1_VOS_Pos, PWR_CR1_VOS_Msk, PWR_CR1_VOS_0
 800070a:	f247 0300 	movw	r3, #28672	@ 0x7000
 800070e:	f2c4 0300 	movt	r3, #16384	@ 0x4000
 8000712:	f44f 62c0 	mov.w	r2, #1536	@ 0x600
 8000716:	f44f 7100 	mov.w	r1, #512	@ 0x200
 800071a:	6818      	ldr	r0, [r3, #0]
 800071c:	ea00 0002 	and.w	r0, r0, r2
 8000720:	4048      	eors	r0, r1
	bne 1b
 8000722:	d1f2      	bne.n	800070a <SystemClock_init2+0xb0>
1:	mCONFIRM_DEVICEREG_BIT_EQ_1	PWR_BASE, PWR_CR5, 	PWR_CR5_R1MODE_Pos, PWR_CR5_R1MODE_Msk	
 8000724:	f247 0000 	movw	r0, #28672	@ 0x7000
 8000728:	f2c4 0000 	movt	r0, #16384	@ 0x4000
 800072c:	f8d0 0080 	ldr.w	r0, [r0, #128]	@ 0x80
 8000730:	f400 7080 	and.w	r0, r0, #256	@ 0x100
 8000734:	f490 7080 	eors.w	r0, r0, #256	@ 0x100
	bne 1b
 8000738:	d1f4      	bne.n	8000724 <SystemClock_init2+0xca>

	@; )	update and confirm : PLL reference clock prescaler (RCC_PLLCFGR_PLLM) scales PLL reference input by 4
	mUPDATE_DEVICEREG_FIELD RCC_BASE, RCC_PLLCFGR, RCC_PLLCFGR_PLLM_Pos, RCC_PLLCFGR_PLLM_Msk, ( 3 << RCC_PLLCFGR_PLLM_Pos ) 
 800073a:	f241 0300 	movw	r3, #4096	@ 0x1000
 800073e:	f2c4 0302 	movt	r3, #16386	@ 0x4002
 8000742:	f04f 02f0 	mov.w	r2, #240	@ 0xf0
 8000746:	f04f 0130 	mov.w	r1, #48	@ 0x30
 800074a:	68d8      	ldr	r0, [r3, #12]
 800074c:	ea20 0002 	bic.w	r0, r0, r2
 8000750:	ea40 0001 	orr.w	r0, r0, r1
 8000754:	60d8      	str	r0, [r3, #12]
1:	mCONFIRM_DEVICEREG_FIELD RCC_BASE, RCC_PLLCFGR, RCC_PLLCFGR_PLLM_Pos, RCC_PLLCFGR_PLLM_Msk,( 3 << RCC_PLLCFGR_PLLM_Pos ) 
 8000756:	f241 0300 	movw	r3, #4096	@ 0x1000
 800075a:	f2c4 0302 	movt	r3, #16386	@ 0x4002
 800075e:	f04f 02f0 	mov.w	r2, #240	@ 0xf0
 8000762:	f04f 0130 	mov.w	r1, #48	@ 0x30
 8000766:	68d8      	ldr	r0, [r3, #12]
 8000768:	ea00 0002 	and.w	r0, r0, r2
 800076c:	4048      	eors	r0, r1
	bne 1b
 800076e:	d1f2      	bne.n	8000756 <SystemClock_init2+0xfc>

	@; )	update and confirm : VCO frequency multiplier (RCC_PLLCFGR_PLLN) with PLLM, multiplies PLL reference input by 36/4 =9
	mUPDATE_DEVICEREG_FIELD RCC_BASE, RCC_PLLCFGR, RCC_PLLCFGR_PLLN_Pos, RCC_PLLCFGR_PLLN_Msk, ( 36 << RCC_PLLCFGR_PLLN_Pos ) 
 8000770:	f241 0300 	movw	r3, #4096	@ 0x1000
 8000774:	f2c4 0302 	movt	r3, #16386	@ 0x4002
 8000778:	f44f 42fe 	mov.w	r2, #32512	@ 0x7f00
 800077c:	f44f 5110 	mov.w	r1, #9216	@ 0x2400
 8000780:	68d8      	ldr	r0, [r3, #12]
 8000782:	ea20 0002 	bic.w	r0, r0, r2
 8000786:	ea40 0001 	orr.w	r0, r0, r1
 800078a:	60d8      	str	r0, [r3, #12]
1:	mCONFIRM_DEVICEREG_FIELD RCC_BASE, RCC_PLLCFGR, RCC_PLLCFGR_PLLN_Pos, RCC_PLLCFGR_PLLN_Msk,( 36 << RCC_PLLCFGR_PLLN_Pos ) 
 800078c:	f241 0300 	movw	r3, #4096	@ 0x1000
 8000790:	f2c4 0302 	movt	r3, #16386	@ 0x4002
 8000794:	f44f 42fe 	mov.w	r2, #32512	@ 0x7f00
 8000798:	f44f 5110 	mov.w	r1, #9216	@ 0x2400
 800079c:	68d8      	ldr	r0, [r3, #12]
 800079e:	ea00 0002 	and.w	r0, r0, r2
 80007a2:	4048      	eors	r0, r1
	bne 1b
 80007a4:	d1f2      	bne.n	800078c <SystemClock_init2+0x132>

	@; )	update and confirm : VCO divider for PLLRCLK (RCC_PLLCFGR_PLLR) RCLK frequency to be 1/2 of PLL VCO frequency, or (16 * (36/4))/2 =72
	mUPDATE_DEVICEREG_FIELD RCC_BASE, RCC_PLLCFGR, RCC_PLLCFGR_PLLR_Pos, RCC_PLLCFGR_PLLR_Msk, ( 0 << RCC_PLLCFGR_PLLR_Pos ) 
 80007a6:	f241 0300 	movw	r3, #4096	@ 0x1000
 80007aa:	f2c4 0302 	movt	r3, #16386	@ 0x4002
 80007ae:	f04f 62c0 	mov.w	r2, #100663296	@ 0x6000000
 80007b2:	f04f 0100 	mov.w	r1, #0
 80007b6:	68d8      	ldr	r0, [r3, #12]
 80007b8:	ea20 0002 	bic.w	r0, r0, r2
 80007bc:	ea40 0001 	orr.w	r0, r0, r1
 80007c0:	60d8      	str	r0, [r3, #12]
1:	mCONFIRM_DEVICEREG_FIELD RCC_BASE, RCC_PLLCFGR, RCC_PLLCFGR_PLLR_Pos, RCC_PLLCFGR_PLLR_Msk,( 0 << RCC_PLLCFGR_PLLR_Pos ) 
 80007c2:	f241 0300 	movw	r3, #4096	@ 0x1000
 80007c6:	f2c4 0302 	movt	r3, #16386	@ 0x4002
 80007ca:	f04f 62c0 	mov.w	r2, #100663296	@ 0x6000000
 80007ce:	f04f 0100 	mov.w	r1, #0
 80007d2:	68d8      	ldr	r0, [r3, #12]
 80007d4:	ea00 0002 	and.w	r0, r0, r2
 80007d8:	4048      	eors	r0, r1
	bne 1b
 80007da:	d1f2      	bne.n	80007c2 <SystemClock_init2+0x168>
	@; *)	update and confirm : VCO divider for PLLPCLK (RCC_PLLCFGR_PLLP) (PCLK is alternate to SysClk for driving ADCs)
	@; *)	update and confirm : VCO divider for PLLPCLK (RCC_PLLCFGR_PLLQ)	(QCLK is alternate to SysClk or PCLK for driving various peripherals)

	@; )    update and confirm : source of PLL reference clock input ( RCC_PLLCFGR_PLLSRC ) 
	@; !!wmh Header file has hinky separate definitions for individual bits in the bit-field and also as bit-codes.  Why? 
	mUPDATE_DEVICEREG_FIELD RCC_BASE, RCC_PLLCFGR, RCC_PLLCFGR_PLLSRC_Pos, RCC_PLLCFGR_PLLSRC_Msk, RCC_PLLCFGR_PLLSRC_HSI
 80007dc:	f241 0300 	movw	r3, #4096	@ 0x1000
 80007e0:	f2c4 0302 	movt	r3, #16386	@ 0x4002
 80007e4:	f04f 0203 	mov.w	r2, #3
 80007e8:	f04f 0102 	mov.w	r1, #2
 80007ec:	68d8      	ldr	r0, [r3, #12]
 80007ee:	ea20 0002 	bic.w	r0, r0, r2
 80007f2:	ea40 0001 	orr.w	r0, r0, r1
 80007f6:	60d8      	str	r0, [r3, #12]
1:	mCONFIRM_DEVICEREG_FIELD RCC_BASE, RCC_PLLCFGR, RCC_PLLCFGR_PLLSRC_Pos, RCC_PLLCFGR_PLLSRC_Msk, RCC_PLLCFGR_PLLSRC_HSI
 80007f8:	f241 0300 	movw	r3, #4096	@ 0x1000
 80007fc:	f2c4 0302 	movt	r3, #16386	@ 0x4002
 8000800:	f04f 0203 	mov.w	r2, #3
 8000804:	f04f 0102 	mov.w	r1, #2
 8000808:	68d8      	ldr	r0, [r3, #12]
 800080a:	ea00 0002 	and.w	r0, r0, r2
 800080e:	4048      	eors	r0, r1
	bne 1b
 8000810:	d1f2      	bne.n	80007f8 <SystemClock_init2+0x19e>

	@; )	update and confirm : turn PLL 'ON' (RCC_CR_PLLON=1, RCC_CR_PLLRDY=1)
	mUPDATE_DEVICEREG_BIT_TO_1 	RCC_BASE, RCC_CR, 	RCC_CR_PLLON_Pos, 	RCC_CR_PLLON_Msk
 8000812:	f241 0000 	movw	r0, #4096	@ 0x1000
 8000816:	f2c4 0002 	movt	r0, #16386	@ 0x4002
 800081a:	6801      	ldr	r1, [r0, #0]
 800081c:	f041 7180 	orr.w	r1, r1, #16777216	@ 0x1000000
 8000820:	6001      	str	r1, [r0, #0]
1:	mCONFIRM_DEVICEREG_BIT_EQ_1	RCC_BASE, RCC_CR, 	RCC_CR_PLLRDY_Pos, 	RCC_CR_PLLRDY_Msk	
 8000822:	f241 0000 	movw	r0, #4096	@ 0x1000
 8000826:	f2c4 0002 	movt	r0, #16386	@ 0x4002
 800082a:	6800      	ldr	r0, [r0, #0]
 800082c:	f000 7000 	and.w	r0, r0, #33554432	@ 0x2000000
 8000830:	f090 7000 	eors.w	r0, r0, #33554432	@ 0x2000000
	bne 1b
 8000834:	d1f5      	bne.n	8000822 <SystemClock_init2+0x1c8>

	@; )	update and confirm : switch over to clock as the main domain clock (RCC_PLLCFGR_PLLREN) (RCLK will used as SysClk when PLL is clock source)
	mUPDATE_DEVICEREG_BIT_TO_1 	RCC_BASE, RCC_PLLCFGR, 	RCC_PLLCFGR_PLLREN_Pos, 	RCC_PLLCFGR_PLLREN_Msk
 8000836:	f241 0000 	movw	r0, #4096	@ 0x1000
 800083a:	f2c4 0002 	movt	r0, #16386	@ 0x4002
 800083e:	68c1      	ldr	r1, [r0, #12]
 8000840:	f041 7180 	orr.w	r1, r1, #16777216	@ 0x1000000
 8000844:	60c1      	str	r1, [r0, #12]
1:	mCONFIRM_DEVICEREG_BIT_EQ_1	RCC_BASE, RCC_PLLCFGR, 	RCC_PLLCFGR_PLLREN_Pos, 	RCC_PLLCFGR_PLLREN_Msk
 8000846:	f241 0000 	movw	r0, #4096	@ 0x1000
 800084a:	f2c4 0002 	movt	r0, #16386	@ 0x4002
 800084e:	68c0      	ldr	r0, [r0, #12]
 8000850:	f000 7080 	and.w	r0, r0, #16777216	@ 0x1000000
 8000854:	f090 7080 	eors.w	r0, r0, #16777216	@ 0x1000000
	bne 1b
 8000858:	d1f5      	bne.n	8000846 <SystemClock_init2+0x1ec>
	@; *)	update and confirm : PPRE1 bus clock prescaler (RCC_CFGR_PPRE1)  (reset value is 0xxx = not prescaled)
	@; *)	update and confirm : PPRE2 bus clock prescaler (RCC_CFGR_PPRE2)  (reset value is 0xxx = not prescaled)
	@; *)	update and confirm : power scaling mode if necessary (PWR_CR5_R1MODE_SW,PWR_CR5_R1MODE_SWS)

	@; )	update and confirm : change SysClk source to PLL (RCC_CFGR_SW,RCC_CFGR_SWS)		               !!TODO check recent for bit vs field
	mUPDATE_DEVICEREG_FIELD  RCC_BASE, RCC_CFGR, 	RCC_CFGR_SW_Pos, RCC_CFGR_SW_Msk, RCC_CFGR_SW_PLL
 800085a:	f241 0300 	movw	r3, #4096	@ 0x1000
 800085e:	f2c4 0302 	movt	r3, #16386	@ 0x4002
 8000862:	f04f 0203 	mov.w	r2, #3
 8000866:	f04f 0103 	mov.w	r1, #3
 800086a:	6898      	ldr	r0, [r3, #8]
 800086c:	ea20 0002 	bic.w	r0, r0, r2
 8000870:	ea40 0001 	orr.w	r0, r0, r1
 8000874:	6098      	str	r0, [r3, #8]
1:	mCONFIRM_DEVICEREG_FIELD  RCC_BASE, RCC_CFGR, 	RCC_CFGR_SWS_Pos, RCC_CFGR_SWS_Msk, RCC_CFGR_SWS_PLL
 8000876:	f241 0300 	movw	r3, #4096	@ 0x1000
 800087a:	f2c4 0302 	movt	r3, #16386	@ 0x4002
 800087e:	f04f 020c 	mov.w	r2, #12
 8000882:	f04f 010c 	mov.w	r1, #12
 8000886:	6898      	ldr	r0, [r3, #8]
 8000888:	ea00 0002 	and.w	r0, r0, r2
 800088c:	4048      	eors	r0, r1
	bne 1b
 800088e:	d1f2      	bne.n	8000876 <SystemClock_init2+0x21c>
	@; defined in ENEE440_F24\_work\0816_STM32G491_TODOs\STM32G491_CubeMXproject_ws2\Project\Core\Src\main.c  
	@; there is the following mystery software delay which we'll emulate 
	@;	/* Insure 1us transition state at intermediate medium speed clock*/
	@; 	for (__IO uint32_t i = (170 >> 1); i !=0; i--);
	@; I (wmh) assume this is to give the hardware time to get the clock switched over, and that too much time is better than too little time 
	mov r0,0x400	@; software delay
 8000890:	f44f 6080 	mov.w	r0, #1024	@ 0x400
1:	subs r0,1
 8000894:	3801      	subs	r0, #1
	bne 1b
 8000896:	d1fd      	bne.n	8000894 <SystemClock_init2+0x23a>
	@; 	LL_RCC_SetAPB2Prescaler(LL_RCC_APB2_DIV_1);

	@; and things still to do
	@; 	*)	update SysTick and SystemCoreClock value

	pop {r7,pc}
 8000898:	bd80      	pop	{r7, pc}
	...

0800089c <device5_cmdHandler>:
@ r0: Pointer to the MoT command payload, command ID is the first byte.
@======================================================================
    .global device5_cmdHandler
    .thumb_func
device5_cmdHandler:
    push {r7, lr}
 800089c:	b580      	push	{r7, lr}
    ldrb r1, [r0], #1
 800089e:	f810 1b01 	ldrb.w	r1, [r0], #1
    and  r1, r1, #0x0F
 80008a2:	f001 010f 	and.w	r1, r1, #15
    tbb  [pc, r1]
 80008a6:	e8df f001 	tbb	[pc, r1]

080008aa <device5_cmds>:
 80008aa:	7503      	.short	0x7503
 80008ac:	b99a      	.short	0xb99a
 80008ae:	0e          	.byte	0x0e
	...

080008b0 <device5_initialize>:
@ "device5 has been initialized" to the console. Corresponds to command 0x00.
@======================================================================
    .text
    .thumb_func
device5_initialize:
    bl  ADC_init
 80008b0:	f000 f818 	bl	80008e4 <ADC_init>
    add r0, rDEVP, #device5_initmsg_OFFSET
 80008b4:	f105 0028 	add.w	r0, r5, #40	@ 0x28
    MOV_imm32 r1, consoleMsgs
 80008b8:	f640 416c 	movw	r1, #3180	@ 0xc6c
 80008bc:	f2c2 0100 	movt	r1, #8192	@ 0x2000
    bl  MoT_msgPost
 80008c0:	f001 ff0f 	bl	80026e2 <MoT_msgPost>
    pop {r7, pc}
 80008c4:	bd80      	pop	{r7, pc}

080008c6 <device5_trig>:
@ "device5 Trigger Enabled on PA1" to the console. Corresponds to command 0x04.
@======================================================================
    .global device5_trig
    .thumb_func
device5_trig:
	ldr r0, =trigger_state
 80008c6:	48c7      	ldr	r0, [pc, #796]	@ (8000be4 <insert_hex_into_stopmsg+0x42>)
	mov r1, #2
 80008c8:	f04f 0102 	mov.w	r1, #2
	str r1, [r0]
 80008cc:	6001      	str	r1, [r0, #0]
    bl    EXTI1_init
 80008ce:	f000 fac9 	bl	8000e64 <EXTI1_init>
    add   r0, rDEVP, #device5_trigmsg_OFFSET
 80008d2:	f505 70a6 	add.w	r0, r5, #332	@ 0x14c
    MOV_imm32 r1, consoleMsgs
 80008d6:	f640 416c 	movw	r1, #3180	@ 0xc6c
 80008da:	f2c2 0100 	movt	r1, #8192	@ 0x2000
    bl    MoT_msgPost
 80008de:	f001 ff00 	bl	80026e2 <MoT_msgPost>
    pop   {r7, pc}
 80008e2:	bd80      	pop	{r7, pc}

080008e4 <ADC_init>:
@ 9. Setting the sample time for Channel 1 in ADC_SMPR1.
@======================================================================
    .global ADC_init
    .thumb_func
ADC_init:
    push {r7, lr}
 80008e4:	b580      	push	{r7, lr}

    bl initPA0
 80008e6:	f000 f83d 	bl	8000964 <initPA0>
    MOV_imm32 r3, RCC_BASE
 80008ea:	f241 0300 	movw	r3, #4096	@ 0x1000
 80008ee:	f2c4 0302 	movt	r3, #16386	@ 0x4002
    ldr r1, [r3, #AHB2ENR]
 80008f2:	6cd9      	ldr	r1, [r3, #76]	@ 0x4c
    orr r1, r1, #ADCEN
 80008f4:	f441 5100 	orr.w	r1, r1, #8192	@ 0x2000
    str r1, [r3, #AHB2ENR]
 80008f8:	64d9      	str	r1, [r3, #76]	@ 0x4c

    ldr r1, [r3, #RCC_CCIPR]
 80008fa:	f8d3 1088 	ldr.w	r1, [r3, #136]	@ 0x88
    bic r1, r1, #(0b11 << 28)
 80008fe:	f021 5140 	bic.w	r1, r1, #805306368	@ 0x30000000
    orr r1, r1, #ADC12SEL
 8000902:	f041 5100 	orr.w	r1, r1, #536870912	@ 0x20000000
    str r1, [r3, #RCC_CCIPR]
 8000906:	f8c3 1088 	str.w	r1, [r3, #136]	@ 0x88

    MOV_imm32 r3, ADC1_BASE
 800090a:	f240 0300 	movw	r3, #0
 800090e:	f2c5 0300 	movt	r3, #20480	@ 0x5000
    ldr r1, [r3, #ADC_CR]
 8000912:	6899      	ldr	r1, [r3, #8]
    bic r1, r1, #DEEPPWD
 8000914:	f021 5100 	bic.w	r1, r1, #536870912	@ 0x20000000
    str r1, [r3, #ADC_CR]
 8000918:	6099      	str	r1, [r3, #8]

    ldr r1, [r3, #ADC_CR]
 800091a:	6899      	ldr	r1, [r3, #8]
    orr r1, r1, #ADVREGEN
 800091c:	f041 5180 	orr.w	r1, r1, #268435456	@ 0x10000000
    str r1, [r3, #ADC_CR]
 8000920:	6099      	str	r1, [r3, #8]

    mov r2, #0xFFFF
 8000922:	f64f 72ff 	movw	r2, #65535	@ 0xffff

08000926 <delay_loop>:
delay_loop:
    subs r2, r2, #1
 8000926:	3a01      	subs	r2, #1
    bne  delay_loop
 8000928:	d1fd      	bne.n	8000926 <delay_loop>

    ldr r1, [r3, #ADC_CR]
 800092a:	6899      	ldr	r1, [r3, #8]
    orr r1, r1, #ADCAL
 800092c:	f041 4100 	orr.w	r1, r1, #2147483648	@ 0x80000000
    str r1, [r3, #ADC_CR]
 8000930:	6099      	str	r1, [r3, #8]

08000932 <wait_Calibration>:

wait_Calibration:
    ldr r1, [r3, #ADC_CR]
 8000932:	6899      	ldr	r1, [r3, #8]
    tst r1, #ADCAL
 8000934:	f011 4f00 	tst.w	r1, #2147483648	@ 0x80000000
    bne wait_Calibration
 8000938:	d1fb      	bne.n	8000932 <wait_Calibration>

    ldr r1, [r3, #ADC_CR]
 800093a:	6899      	ldr	r1, [r3, #8]
    orr r1, r1, #ADEN
 800093c:	f041 0101 	orr.w	r1, r1, #1
    str r1, [r3, #ADC_CR]
 8000940:	6099      	str	r1, [r3, #8]

08000942 <wait_ADC_ready>:

wait_ADC_ready:
    ldr r1, [r3, #ADC_ISR]
 8000942:	6819      	ldr	r1, [r3, #0]
    tst r1, #ADRDY
 8000944:	f011 0f01 	tst.w	r1, #1
    beq wait_ADC_ready
 8000948:	d0fb      	beq.n	8000942 <wait_ADC_ready>

    ldr r1, [r3, #ADC_SQR1]
 800094a:	6b19      	ldr	r1, [r3, #48]	@ 0x30
    bic r1, r1, #(0x1F << 6)
 800094c:	f421 61f8 	bic.w	r1, r1, #1984	@ 0x7c0
    orr r1, r1, #(1 << 6)
 8000950:	f041 0140 	orr.w	r1, r1, #64	@ 0x40
    str r1, [r3, #ADC_SQR1]
 8000954:	6319      	str	r1, [r3, #48]	@ 0x30

    ldr r1, [r3, #0x14]
 8000956:	6959      	ldr	r1, [r3, #20]
    bic r1, r1, #(0x7 << (1*3))
 8000958:	f021 0138 	bic.w	r1, r1, #56	@ 0x38
    orr r1, r1, #(0x7 << (1*3))
 800095c:	f041 0138 	orr.w	r1, r1, #56	@ 0x38
    str r1, [r3, #0x14]
 8000960:	6159      	str	r1, [r3, #20]

    pop {r7, pc}
 8000962:	bd80      	pop	{r7, pc}

08000964 <initPA0>:
@ 2. Configures PA0 to Analog Mode in GPIOA_MODER.
@ 3. Disables pull-up/pull-down resistors for PA0 in GPIOA_PUPDR.
@======================================================================
.thumb_func
initPA0:
    push {r7, lr}
 8000964:	b580      	push	{r7, lr}

    MOV_imm32 r3, RCC_BASE
 8000966:	f241 0300 	movw	r3, #4096	@ 0x1000
 800096a:	f2c4 0302 	movt	r3, #16386	@ 0x4002
    ldr r1, [r3, #AHB2ENR]
 800096e:	6cd9      	ldr	r1, [r3, #76]	@ 0x4c
    orr r1, r1, #GPIOAEN
 8000970:	f041 0101 	orr.w	r1, r1, #1
    str r1, [r3, #AHB2ENR]
 8000974:	64d9      	str	r1, [r3, #76]	@ 0x4c

    MOV_imm32 r3, GPIOA_BASE
 8000976:	f240 0300 	movw	r3, #0
 800097a:	f6c4 0300 	movt	r3, #18432	@ 0x4800
    ldr r1, [r3, #MODER]
 800097e:	6819      	ldr	r1, [r3, #0]
    bic r1, r1, #(0b11 << (PA0 * 2))
 8000980:	f021 0103 	bic.w	r1, r1, #3
    orr r1, r1, #(0b11 << (PA0 * 2))
 8000984:	f041 0103 	orr.w	r1, r1, #3
    str r1, [r3, #MODER]
 8000988:	6019      	str	r1, [r3, #0]

    ldr r1, [r3, #0x0C]
 800098a:	68d9      	ldr	r1, [r3, #12]
    bic r1, r1, #(0b11 << (PA0 * 2))
 800098c:	f021 0103 	bic.w	r1, r1, #3
    str r1, [r3, #0x0C]
 8000990:	60d9      	str	r1, [r3, #12]

    pop {r7, pc}
 8000992:	bd80      	pop	{r7, pc}

08000994 <report_ADC_amp>:
@ formatted message to the console. Corresponds to command 0x01.
@======================================================================
.global report_ADC_amp
.thumb_func
report_ADC_amp:
    bl report
 8000994:	f000 f80f 	bl	80009b6 <report>
    bl insert_hex_into_stopmsg
 8000998:	f000 f903 	bl	8000ba2 <insert_hex_into_stopmsg>
    MOV_imm32 r0, device5_voltage_reportmsg
 800099c:	f240 00b0 	movw	r0, #176	@ 0xb0
 80009a0:	f2c2 0000 	movt	r0, #8192	@ 0x2000
    MOV_imm32 r1, consoleMsgs
 80009a4:	f640 416c 	movw	r1, #3180	@ 0xc6c
 80009a8:	f2c2 0100 	movt	r1, #8192	@ 0x2000
    bl MoT_msgPost
 80009ac:	f001 fe99 	bl	80026e2 <MoT_msgPost>
    mov r0, #0
 80009b0:	f04f 0000 	mov.w	r0, #0
    pop {r7, pc}
 80009b4:	bd80      	pop	{r7, pc}

080009b6 <report>:
@ r0: Returns the processed 12-bit ADC value.
@======================================================================
.global report
.thumb_func
report:
    push {r7, lr}
 80009b6:	b580      	push	{r7, lr}

    MOV_imm32 r3, ADC1_BASE
 80009b8:	f240 0300 	movw	r3, #0
 80009bc:	f2c5 0300 	movt	r3, #20480	@ 0x5000

    ldr r1, [r3, #ADC_CR]
 80009c0:	6899      	ldr	r1, [r3, #8]
    orr r1, r1, #ADSTART
 80009c2:	f041 0104 	orr.w	r1, r1, #4
    str r1, [r3, #ADC_CR]
 80009c6:	6099      	str	r1, [r3, #8]

080009c8 <wait_conversion>:

wait_conversion:
    ldr r1, [r3, #ADC_ISR]
 80009c8:	6819      	ldr	r1, [r3, #0]
    tst r1, #EOC
 80009ca:	f011 0f04 	tst.w	r1, #4
    beq wait_conversion
 80009ce:	d0fb      	beq.n	80009c8 <wait_conversion>

    ldr r0, [r3, #ADC_DR]
 80009d0:	6c18      	ldr	r0, [r3, #64]	@ 0x40
    ldr r1, =0x0FFF
 80009d2:	f640 71ff 	movw	r1, #4095	@ 0xfff
    ands r0, r0, r1
 80009d6:	4008      	ands	r0, r1
	bl pull_up_down
 80009d8:	f001 faf2 	bl	8001fc0 <pull_up_down>
    pop {r7, pc}
 80009dc:	bd80      	pop	{r7, pc}

080009de <device5_checklimits>:
@ r0: Pointer to command payload containing V_low and V_high.
@======================================================================
.global device5_checklimits
.thumb_func
device5_checklimits:
    ldrh  r1, [r0], #2
 80009de:	f830 1b02 	ldrh.w	r1, [r0], #2
    bl    swap_low2bytes_r1
 80009e2:	f001 fa89 	bl	8001ef8 <swap_low2bytes_r1>
    str   r1, [rDEVP, #device5_BELOW]
 80009e6:	f8c5 1020 	str.w	r1, [r5, #32]
    ldrh  r1, [r0], #2
 80009ea:	f830 1b02 	ldrh.w	r1, [r0], #2
    bl    swap_low2bytes_r1
 80009ee:	f001 fa83 	bl	8001ef8 <swap_low2bytes_r1>
    str   r1, [rDEVP, #device5_ABOVE]
 80009f2:	f8c5 1024 	str.w	r1, [r5, #36]	@ 0x24

    MOV_imm32 r0, device5_EQUALtask
 80009f6:	f640 204b 	movw	r0, #2635	@ 0xa4b
 80009fa:	f6c0 0000 	movt	r0, #2048	@ 0x800
    mov   r1, #NULL
 80009fe:	f04f 0100 	mov.w	r1, #0
    bl    MoT_taskUpdate
 8000a02:	f001 fe54 	bl	80026ae <MoT_taskUpdate>

	MOV_imm32 r0, device5_monitormsg
 8000a06:	f240 00e8 	movw	r0, #232	@ 0xe8
 8000a0a:	f2c2 0000 	movt	r0, #8192	@ 0x2000
    MOV_imm32 r1, consoleMsgs
 8000a0e:	f640 416c 	movw	r1, #3180	@ 0xc6c
 8000a12:	f2c2 0100 	movt	r1, #8192	@ 0x2000
    bl MoT_msgPost
 8000a16:	f001 fe64 	bl	80026e2 <MoT_msgPost>
    pop {r7, pc}
 8000a1a:	bd80      	pop	{r7, pc}

08000a1c <device5_stop_monitor>:
@ the console. Corresponds to command 0x03.
@======================================================================
.global device5_stop_monitor
.thumb_func
device5_stop_monitor:
    MOV_imm32 r0, device5_skiptask
 8000a1c:	f640 309d 	movw	r0, #2973	@ 0xb9d
 8000a20:	f6c0 0000 	movt	r0, #2048	@ 0x800
    mov r1, #NULL
 8000a24:	f04f 0100 	mov.w	r1, #0
    bl MoT_taskUpdate
 8000a28:	f001 fe41 	bl	80026ae <MoT_taskUpdate>
    mov r0, #0
 8000a2c:	f04f 0000 	mov.w	r0, #0
    MOV_imm32 r0, device5_stop_monitor_return_resutlsmsg
 8000a30:	f240 0060 	movw	r0, #96	@ 0x60
 8000a34:	f2c2 0000 	movt	r0, #8192	@ 0x2000
    MOV_imm32 r1, consoleMsgs
 8000a38:	f640 416c 	movw	r1, #3180	@ 0xc6c
 8000a3c:	f2c2 0100 	movt	r1, #8192	@ 0x2000
    bl    MoT_msgPost
 8000a40:	f001 fe4f 	bl	80026e2 <MoT_msgPost>
    mov r0, #0
 8000a44:	f04f 0000 	mov.w	r0, #0
    pop {r7, pc}
 8000a48:	bd80      	pop	{r7, pc}

08000a4a <device5_EQUALtask>:
@ After handling its logic, it passes control to the next MoT task.
@======================================================================
.global device5_EQUALtask
.thumb_func
device5_EQUALtask:
    bl report
 8000a4a:	f7ff ffb4 	bl	80009b6 <report>

    ldr r1, [rDEVP, #device5_ABOVE]
 8000a4e:	f8d5 1024 	ldr.w	r1, [r5, #36]	@ 0x24
    cmp r0, r1
 8000a52:	4288      	cmp	r0, r1
    bgt cross_above
 8000a54:	dc0e      	bgt.n	8000a74 <cross_above>

    ldr r2, [rDEVP, #device5_BELOW]
 8000a56:	f8d5 2020 	ldr.w	r2, [r5, #32]
    cmp r0, r2
 8000a5a:	4290      	cmp	r0, r2
    blt cross_below
 8000a5c:	db1f      	blt.n	8000a9e <cross_below>

    MOV_imm32 r0, device5_EQUALtask
 8000a5e:	f640 204b 	movw	r0, #2635	@ 0xa4b
 8000a62:	f6c0 0000 	movt	r0, #2048	@ 0x800
    mov r1, #NULL
 8000a66:	f04f 0100 	mov.w	r1, #0
    bl MoT_taskUpdate
 8000a6a:	f001 fe20 	bl	80026ae <MoT_taskUpdate>

    ldr rDEVP, [rDEVP, #NEXTTASK]
 8000a6e:	68ad      	ldr	r5, [r5, #8]
    ldr pc, [rDEVP, #XEQTASK]
 8000a70:	f8d5 f004 	ldr.w	pc, [r5, #4]

08000a74 <cross_above>:

cross_above:
    MOV_imm32 r0, device5_abovemsg
 8000a74:	f240 1014 	movw	r0, #276	@ 0x114
 8000a78:	f2c2 0000 	movt	r0, #8192	@ 0x2000
    MOV_imm32 r1, consoleMsgs
 8000a7c:	f640 416c 	movw	r1, #3180	@ 0xc6c
 8000a80:	f2c2 0100 	movt	r1, #8192	@ 0x2000
    bl MoT_msgPost
 8000a84:	f001 fe2d 	bl	80026e2 <MoT_msgPost>

    MOV_imm32 r0, device5_ABOVEtask
 8000a88:	f640 20c9 	movw	r0, #2761	@ 0xac9
 8000a8c:	f6c0 0000 	movt	r0, #2048	@ 0x800
    mov r1, #NULL
 8000a90:	f04f 0100 	mov.w	r1, #0
    bl MoT_taskUpdate
 8000a94:	f001 fe0b 	bl	80026ae <MoT_taskUpdate>

    ldr rDEVP, [rDEVP, #NEXTTASK]
 8000a98:	68ad      	ldr	r5, [r5, #8]
    ldr pc, [rDEVP, #XEQTASK]
 8000a9a:	f8d5 f004 	ldr.w	pc, [r5, #4]

08000a9e <cross_below>:

cross_below:
    MOV_imm32 r0, device5_belowmsg
 8000a9e:	f240 1034 	movw	r0, #308	@ 0x134
 8000aa2:	f2c2 0000 	movt	r0, #8192	@ 0x2000
    MOV_imm32 r1, consoleMsgs
 8000aa6:	f640 416c 	movw	r1, #3180	@ 0xc6c
 8000aaa:	f2c2 0100 	movt	r1, #8192	@ 0x2000
    bl MoT_msgPost
 8000aae:	f001 fe18 	bl	80026e2 <MoT_msgPost>

    MOV_imm32 r0, device5_BELOWtask
 8000ab2:	f640 3033 	movw	r0, #2867	@ 0xb33
 8000ab6:	f6c0 0000 	movt	r0, #2048	@ 0x800
    mov r1, #NULL
 8000aba:	f04f 0100 	mov.w	r1, #0
    bl MoT_taskUpdate
 8000abe:	f001 fdf6 	bl	80026ae <MoT_taskUpdate>

    ldr rDEVP, [rDEVP, #NEXTTASK]
 8000ac2:	68ad      	ldr	r5, [r5, #8]
    ldr pc, [rDEVP, #XEQTASK]
 8000ac4:	f8d5 f004 	ldr.w	pc, [r5, #4]

08000ac8 <device5_ABOVEtask>:
@ After handling its logic, it passes control to the next MoT task.
@======================================================================
.global device5_ABOVEtask
.thumb_func
device5_ABOVEtask:
    bl report
 8000ac8:	f7ff ff75 	bl	80009b6 <report>

    ldr r1, [rDEVP, #device5_ABOVE]
 8000acc:	f8d5 1024 	ldr.w	r1, [r5, #36]	@ 0x24
    cmp r0, r1
 8000ad0:	4288      	cmp	r0, r1
    ble crossed_back_inside
 8000ad2:	dd0a      	ble.n	8000aea <crossed_back_inside>

    MOV_imm32 r0, device5_ABOVEtask
 8000ad4:	f640 20c9 	movw	r0, #2761	@ 0xac9
 8000ad8:	f6c0 0000 	movt	r0, #2048	@ 0x800
    mov r1, #NULL
 8000adc:	f04f 0100 	mov.w	r1, #0
    bl MoT_taskUpdate
 8000ae0:	f001 fde5 	bl	80026ae <MoT_taskUpdate>

    ldr rDEVP, [rDEVP, #NEXTTASK]
 8000ae4:	68ad      	ldr	r5, [r5, #8]
    ldr pc, [rDEVP, #XEQTASK]
 8000ae6:	f8d5 f004 	ldr.w	pc, [r5, #4]

08000aea <crossed_back_inside>:

crossed_back_inside:
    ldr r2, [rDEVP, #device5_BELOW]
 8000aea:	f8d5 2020 	ldr.w	r2, [r5, #32]
    cmp r0, r2
 8000aee:	4290      	cmp	r0, r2
    blt cross_below_from_above
 8000af0:	db0a      	blt.n	8000b08 <cross_below_from_above>

    MOV_imm32 r0, device5_EQUALtask
 8000af2:	f640 204b 	movw	r0, #2635	@ 0xa4b
 8000af6:	f6c0 0000 	movt	r0, #2048	@ 0x800
    mov r1, #NULL
 8000afa:	f04f 0100 	mov.w	r1, #0
    bl MoT_taskUpdate
 8000afe:	f001 fdd6 	bl	80026ae <MoT_taskUpdate>

    ldr rDEVP, [rDEVP, #NEXTTASK]
 8000b02:	68ad      	ldr	r5, [r5, #8]
    ldr pc, [rDEVP, #XEQTASK]
 8000b04:	f8d5 f004 	ldr.w	pc, [r5, #4]

08000b08 <cross_below_from_above>:

cross_below_from_above:
    MOV_imm32 r0, device5_belowmsg
 8000b08:	f240 1034 	movw	r0, #308	@ 0x134
 8000b0c:	f2c2 0000 	movt	r0, #8192	@ 0x2000
    MOV_imm32 r1, consoleMsgs
 8000b10:	f640 416c 	movw	r1, #3180	@ 0xc6c
 8000b14:	f2c2 0100 	movt	r1, #8192	@ 0x2000
    bl MoT_msgPost
 8000b18:	f001 fde3 	bl	80026e2 <MoT_msgPost>

    MOV_imm32 r0, device5_BELOWtask
 8000b1c:	f640 3033 	movw	r0, #2867	@ 0xb33
 8000b20:	f6c0 0000 	movt	r0, #2048	@ 0x800
    mov r1, #NULL
 8000b24:	f04f 0100 	mov.w	r1, #0
    bl MoT_taskUpdate
 8000b28:	f001 fdc1 	bl	80026ae <MoT_taskUpdate>

    ldr rDEVP, [rDEVP, #NEXTTASK]
 8000b2c:	68ad      	ldr	r5, [r5, #8]
    ldr pc, [rDEVP, #XEQTASK]
 8000b2e:	f8d5 f004 	ldr.w	pc, [r5, #4]

08000b32 <device5_BELOWtask>:
@ After handling its logic, it passes control to the next MoT task.
@======================================================================
.global device5_BELOWtask
.thumb_func
device5_BELOWtask:
    bl report
 8000b32:	f7ff ff40 	bl	80009b6 <report>

    ldr r2, [rDEVP, #device5_BELOW]
 8000b36:	f8d5 2020 	ldr.w	r2, [r5, #32]
    cmp r0, r2
 8000b3a:	4290      	cmp	r0, r2
    bge crossed_back_inside_below
 8000b3c:	da0a      	bge.n	8000b54 <crossed_back_inside_below>

    MOV_imm32 r0, device5_BELOWtask
 8000b3e:	f640 3033 	movw	r0, #2867	@ 0xb33
 8000b42:	f6c0 0000 	movt	r0, #2048	@ 0x800
    mov r1, #NULL
 8000b46:	f04f 0100 	mov.w	r1, #0
    bl MoT_taskUpdate
 8000b4a:	f001 fdb0 	bl	80026ae <MoT_taskUpdate>

    ldr rDEVP, [rDEVP, #NEXTTASK]
 8000b4e:	68ad      	ldr	r5, [r5, #8]
    ldr pc, [rDEVP, #XEQTASK]
 8000b50:	f8d5 f004 	ldr.w	pc, [r5, #4]

08000b54 <crossed_back_inside_below>:

crossed_back_inside_below:
    ldr r1, [rDEVP, #device5_ABOVE]
 8000b54:	f8d5 1024 	ldr.w	r1, [r5, #36]	@ 0x24
    cmp r0, r1
 8000b58:	4288      	cmp	r0, r1
    bgt cross_above_from_below
 8000b5a:	dc0a      	bgt.n	8000b72 <cross_above_from_below>

    MOV_imm32 r0, device5_EQUALtask
 8000b5c:	f640 204b 	movw	r0, #2635	@ 0xa4b
 8000b60:	f6c0 0000 	movt	r0, #2048	@ 0x800
    mov r1, #NULL
 8000b64:	f04f 0100 	mov.w	r1, #0
    bl MoT_taskUpdate
 8000b68:	f001 fda1 	bl	80026ae <MoT_taskUpdate>

    ldr rDEVP, [rDEVP, #NEXTTASK]
 8000b6c:	68ad      	ldr	r5, [r5, #8]
    ldr pc, [rDEVP, #XEQTASK]
 8000b6e:	f8d5 f004 	ldr.w	pc, [r5, #4]

08000b72 <cross_above_from_below>:

cross_above_from_below:
    MOV_imm32 r0, device5_abovemsg
 8000b72:	f240 1014 	movw	r0, #276	@ 0x114
 8000b76:	f2c2 0000 	movt	r0, #8192	@ 0x2000
    MOV_imm32 r1, consoleMsgs
 8000b7a:	f640 416c 	movw	r1, #3180	@ 0xc6c
 8000b7e:	f2c2 0100 	movt	r1, #8192	@ 0x2000
    bl MoT_msgPost
 8000b82:	f001 fdae 	bl	80026e2 <MoT_msgPost>

    MOV_imm32 r0, device5_ABOVEtask
 8000b86:	f640 20c9 	movw	r0, #2761	@ 0xac9
 8000b8a:	f6c0 0000 	movt	r0, #2048	@ 0x800
    mov r1, #NULL
 8000b8e:	f04f 0100 	mov.w	r1, #0
    bl MoT_taskUpdate
 8000b92:	f001 fd8c 	bl	80026ae <MoT_taskUpdate>

    ldr rDEVP, [rDEVP, #NEXTTASK]
 8000b96:	68ad      	ldr	r5, [r5, #8]
    ldr pc, [rDEVP, #XEQTASK]
 8000b98:	f8d5 f004 	ldr.w	pc, [r5, #4]

08000b9c <device5_skiptask>:
@ to explicitly stop other device-specific periodic tasks.
@======================================================================
.global device5_skiptask
.thumb_func
device5_skiptask:
    ldr rDEVP, [rDEVP, #NEXTTASK]
 8000b9c:	68ad      	ldr	r5, [r5, #8]
    ldr pc, [rDEVP, #XEQTASK]
 8000b9e:	f8d5 f004 	ldr.w	pc, [r5, #4]

08000ba2 <insert_hex_into_stopmsg>:
@ r0: Input ADC value (12-bit).
@======================================================================
.global insert_hex_into_stopmsg
.thumb_func
insert_hex_into_stopmsg:
    push {r4-r7, lr}
 8000ba2:	b5f0      	push	{r4, r5, r6, r7, lr}

    MOV_imm32 r3, device5_voltage_reportmsg
 8000ba4:	f240 03b0 	movw	r3, #176	@ 0xb0
 8000ba8:	f2c2 0300 	movt	r3, #8192	@ 0x2000
    add r3, r3, #48
 8000bac:	f103 0330 	add.w	r3, r3, #48	@ 0x30
    add r3, r3, #2
 8000bb0:	f103 0302 	add.w	r3, r3, #2

    mov r4, r0
 8000bb4:	4604      	mov	r4, r0

    lsrs r5, r4, #8
 8000bb6:	0a25      	lsrs	r5, r4, #8
    and r5, r5, #0xF
 8000bb8:	f005 050f 	and.w	r5, r5, #15
    bl nibble_to_ascii
 8000bbc:	f001 f9b8 	bl	8001f30 <nibble_to_ascii>
    strb r0, [r3], #1
 8000bc0:	f803 0b01 	strb.w	r0, [r3], #1

    lsrs r5, r4, #4
 8000bc4:	0925      	lsrs	r5, r4, #4
    and r5, r5, #0xF
 8000bc6:	f005 050f 	and.w	r5, r5, #15
    bl nibble_to_ascii
 8000bca:	f001 f9b1 	bl	8001f30 <nibble_to_ascii>
    strb r0, [r3], #1
 8000bce:	f803 0b01 	strb.w	r0, [r3], #1

    mov r5, r4
 8000bd2:	4625      	mov	r5, r4
    and r5, r5, #0xF
 8000bd4:	f005 050f 	and.w	r5, r5, #15
    bl nibble_to_ascii
 8000bd8:	f001 f9aa 	bl	8001f30 <nibble_to_ascii>
    strb r0, [r3], #1
 8000bdc:	f803 0b01 	strb.w	r0, [r3], #1

    pop {r4-r7, pc}
 8000be0:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000be2:	0000      	.short	0x0000
	ldr r0, =trigger_state
 8000be4:	2000156c 	.word	0x2000156c

08000be8 <device4_cmdHandler>:
@ r1: Used to store and manipulate the command ID.
@======================================================================
.global device4_cmdHandler
.thumb_func
device4_cmdHandler:
    push   {r7, lr}
 8000be8:	b580      	push	{r7, lr}
    ldrb   r1, [r0], #1
 8000bea:	f810 1b01 	ldrb.w	r1, [r0], #1
    and    r1, r1, #0x0F
 8000bee:	f001 010f 	and.w	r1, r1, #15
    tbb    [pc, r1]
 8000bf2:	e8df f001 	tbb	[pc, r1]

08000bf6 <device4_cmds>:
 8000bf6:	7258      	.short	0x7258
 8000bf8:	e283      	.short	0xe283
 8000bfa:	63          	.byte	0x63

08000bfb <device4_inittxt>:
 8000bfb:	64          	.byte	0x64
 8000bfc:	63697665 	.word	0x63697665
 8000c00:	68203465 	.word	0x68203465
 8000c04:	62207361 	.word	0x62207361
 8000c08:	206e6565 	.word	0x206e6565
 8000c0c:	74696e69 	.word	0x74696e69
 8000c10:	696c6169 	.word	0x696c6169
 8000c14:	0a64657a 	.word	0x0a64657a
 8000c18:	000d      	.short	0x000d

08000c1a <device4_constxt>:
 8000c1a:	6564      	.short	0x6564
 8000c1c:	65636976 	.word	0x65636976
 8000c20:	65732034 	.word	0x65732034
 8000c24:	6f742074 	.word	0x6f742074
 8000c28:	6e6f6320 	.word	0x6e6f6320
 8000c2c:	6e617473 	.word	0x6e617473
 8000c30:	6f762074 	.word	0x6f762074
 8000c34:	6761746c 	.word	0x6761746c
 8000c38:	000d0a65 	.word	0x000d0a65

08000c3c <device4_trans2txt>:
 8000c3c:	746c6f56 	.word	0x746c6f56
 8000c40:	20656761 	.word	0x20656761
 8000c44:	6e617274 	.word	0x6e617274
 8000c48:	69746973 	.word	0x69746973
 8000c4c:	64656e6f 	.word	0x64656e6f
 8000c50:	0d0a      	.short	0x0d0a
	...

08000c53 <device4_stoptxt>:
 8000c53:	64          	.byte	0x64
 8000c54:	63697665 	.word	0x63697665
 8000c58:	68203465 	.word	0x68203465
 8000c5c:	73207361 	.word	0x73207361
 8000c60:	70706f74 	.word	0x70706f74
 8000c64:	6f206465 	.word	0x6f206465
 8000c68:	75707475 	.word	0x75707475
 8000c6c:	676e6974 	.word	0x676e6974
 8000c70:	70206120 	.word	0x70206120
 8000c74:	6f697265 	.word	0x6f697265
 8000c78:	20636964 	.word	0x20636964
 8000c7c:	6e676973 	.word	0x6e676973
 8000c80:	0d0a6c61 	.word	0x0d0a6c61
	...

08000c85 <device4_trigtxt>:
 8000c85:	64          	.byte	0x64
 8000c86:	7665      	.short	0x7665
 8000c88:	34656369 	.word	0x34656369
 8000c8c:	69725420 	.word	0x69725420
 8000c90:	72656767 	.word	0x72656767
 8000c94:	616e4520 	.word	0x616e4520
 8000c98:	64656c62 	.word	0x64656c62
 8000c9c:	206e6f20 	.word	0x206e6f20
 8000ca0:	0a314150 	.word	0x0a314150
 8000ca4:	000d      	.short	0x000d

08000ca6 <device4_initialize>:
@ it posts the message "device4 has been initialized" to the console.
@======================================================================
.global device4_initialize
.thumb_func
device4_initialize:
    bl    DAC1_CH2_init
 8000ca6:	f000 f8b8 	bl	8000e1a <DAC1_CH2_init>
    add   r0, rDEVP, #device4_initmsg_OFFSET
 8000caa:	f105 0034 	add.w	r0, r5, #52	@ 0x34
    MOV_imm32 r1, consoleMsgs
 8000cae:	f640 416c 	movw	r1, #3180	@ 0xc6c
 8000cb2:	f2c2 0100 	movt	r1, #8192	@ 0x2000
    bl    MoT_msgPost
 8000cb6:	f001 fd14 	bl	80026e2 <MoT_msgPost>
    pop   {r7, pc}
 8000cba:	bd80      	pop	{r7, pc}

08000cbc <device4_trig_on>:
@ or handled by the EXTI1 interrupt handler logic.
@======================================================================
.global device4_trig_on
.thumb_func
device4_trig_on:
	ldr r3, =trigger_state
 8000cbc:	4b68      	ldr	r3, [pc, #416]	@ (8000e60 <DAC1_CH2_output+0x10>)
	mov r1, #1
 8000cbe:	f04f 0101 	mov.w	r1, #1
	str r1, [r3]
 8000cc2:	6019      	str	r1, [r3, #0]
    bl    EXTI1_init
 8000cc4:	f000 f8ce 	bl	8000e64 <EXTI1_init>
    add   r0, rDEVP, #device4_trigmsg_OFFSET
 8000cc8:	f105 0074 	add.w	r0, r5, #116	@ 0x74
    MOV_imm32 r1, consoleMsgs
 8000ccc:	f640 416c 	movw	r1, #3180	@ 0xc6c
 8000cd0:	f2c2 0100 	movt	r1, #8192	@ 0x2000
    bl    MoT_msgPost
 8000cd4:	f001 fd05 	bl	80026e2 <MoT_msgPost>
    pop   {r7, pc}
 8000cd8:	bd80      	pop	{r7, pc}

08000cda <device4_constvol>:
@     Output (for MoT_msgPost), pointer to message link.
@======================================================================
.global device4_constvol
.thumb_func
device4_constvol:
    ldrh  r1, [r0]
 8000cda:	8801      	ldrh	r1, [r0, #0]
    bl    swap_low2bytes_r1
 8000cdc:	f001 f90c 	bl	8001ef8 <swap_low2bytes_r1>
    mov   r0, r1
 8000ce0:	4608      	mov	r0, r1
    bl    DAC1_CH2_output
 8000ce2:	f000 f8b5 	bl	8000e50 <DAC1_CH2_output>
    MOV_imm32 r0, device4_constval
 8000ce6:	f240 10cc 	movw	r0, #460	@ 0x1cc
 8000cea:	f2c2 0000 	movt	r0, #8192	@ 0x2000
    MOV_imm32 r1, consoleMsgs
 8000cee:	f640 416c 	movw	r1, #3180	@ 0xc6c
 8000cf2:	f2c2 0100 	movt	r1, #8192	@ 0x2000
    bl    MoT_msgPost
 8000cf6:	f001 fcf4 	bl	80026e2 <MoT_msgPost>
    pop   {r7, pc}
 8000cfa:	bd80      	pop	{r7, pc}

08000cfc <device4_transvol>:
@ r0: Input, pointer to command payload. Output (for MoT_msgPost), pointer to message link.
@======================================================================
.global device4_transvol
.thumb_func
device4_transvol:
    ldrh  r1, [r0], #2
 8000cfc:	f830 1b02 	ldrh.w	r1, [r0], #2
    bl    swap_low2bytes_r1
 8000d00:	f001 f8fa 	bl	8001ef8 <swap_low2bytes_r1>
    str   r1, [rDEVP, #device4_VALUE]
 8000d04:	f8c5 1020 	str.w	r1, [r5, #32]
    ldrh  r1, [r0], #2
 8000d08:	f830 1b02 	ldrh.w	r1, [r0], #2
    bl    swap_low2bytes_r1
 8000d0c:	f001 f8f4 	bl	8001ef8 <swap_low2bytes_r1>
    str   r1, [rDEVP, #device4_CYCLES]
 8000d10:	f8c5 1028 	str.w	r1, [r5, #40]	@ 0x28
    ldrh  r1, [r0], #2
 8000d14:	f830 1b02 	ldrh.w	r1, [r0], #2
    bl    swap_low2bytes_r1
 8000d18:	f001 f8ee 	bl	8001ef8 <swap_low2bytes_r1>
    str   r1, [rDEVP, #device4_TARGET]
 8000d1c:	f8c5 1024 	str.w	r1, [r5, #36]	@ 0x24
    ldrh  r1, [r0], #2
 8000d20:	f830 1b02 	ldrh.w	r1, [r0], #2
    bl    swap_low2bytes_r1
 8000d24:	f001 f8e8 	bl	8001ef8 <swap_low2bytes_r1>
    str   r1, [rDEVP, #device4_RELOAD]
 8000d28:	f8c5 102c 	str.w	r1, [r5, #44]	@ 0x2c
    str   r1, [rDEVP, #device4_COUNT]
 8000d2c:	f8c5 1030 	str.w	r1, [r5, #48]	@ 0x30
    MOV_imm32 r0, device4_ONtask
 8000d30:	f640 5057 	movw	r0, #3415	@ 0xd57
 8000d34:	f6c0 0000 	movt	r0, #2048	@ 0x800
    mov   r1, #NULL
 8000d38:	f04f 0100 	mov.w	r1, #0
    bl    MoT_taskUpdate
 8000d3c:	f001 fcb7 	bl	80026ae <MoT_taskUpdate>
    MOV_imm32 r0, device4_trans2
 8000d40:	f240 10dc 	movw	r0, #476	@ 0x1dc
 8000d44:	f2c2 0000 	movt	r0, #8192	@ 0x2000
    MOV_imm32 r1, consoleMsgs
 8000d48:	f640 416c 	movw	r1, #3180	@ 0xc6c
 8000d4c:	f2c2 0100 	movt	r1, #8192	@ 0x2000
    bl    MoT_msgPost
 8000d50:	f001 fcc7 	bl	80026e2 <MoT_msgPost>
    pop   {r7, pc}
 8000d54:	bd80      	pop	{r7, pc}

08000d56 <device4_ONtask>:
@   3. Schedules 'device4_OFFtask' as the next task.
@======================================================================
.global device4_ONtask
.thumb_func
device4_ONtask:
    ldr r1, [rDEVP, #device4_COUNT]
 8000d56:	f8d5 1030 	ldr.w	r1, [r5, #48]	@ 0x30
    subs r1, r1, #1
 8000d5a:	3901      	subs	r1, #1
    str r1, [rDEVP, #device4_COUNT]
 8000d5c:	f8c5 1030 	str.w	r1, [r5, #48]	@ 0x30
    cbnz r1, 1f
 8000d60:	b979      	cbnz	r1, 8000d82 <device4_ONtask+0x2c>
    ldr r0, [rDEVP, #device4_VALUE]
 8000d62:	f8d5 0020 	ldr.w	r0, [r5, #32]
    bl  DAC1_CH2_output
 8000d66:	f000 f873 	bl	8000e50 <DAC1_CH2_output>
    ldr r1, [rDEVP, #device4_CYCLES]
 8000d6a:	f8d5 1028 	ldr.w	r1, [r5, #40]	@ 0x28
    str r1, [rDEVP, #device4_COUNT]
 8000d6e:	f8c5 1030 	str.w	r1, [r5, #48]	@ 0x30
    MOV_imm32 r0, device4_OFFtask
 8000d72:	f640 5089 	movw	r0, #3465	@ 0xd89
 8000d76:	f6c0 0000 	movt	r0, #2048	@ 0x800
    mov r1, #NULL
 8000d7a:	f04f 0100 	mov.w	r1, #0
    bl  MoT_taskUpdate
 8000d7e:	f001 fc96 	bl	80026ae <MoT_taskUpdate>
1:
    ldr rDEVP, [rDEVP, #NEXTTASK]
 8000d82:	68ad      	ldr	r5, [r5, #8]
    ldr pc, [rDEVP, #XEQTASK]
 8000d84:	f8d5 f004 	ldr.w	pc, [r5, #4]

08000d88 <device4_OFFtask>:
@   3. Schedules 'device4_ONtask' as the next task.
@======================================================================
.global device4_OFFtask
.thumb_func
device4_OFFtask:
    ldr r1, [rDEVP, #device4_COUNT]
 8000d88:	f8d5 1030 	ldr.w	r1, [r5, #48]	@ 0x30
    subs r1, r1, #1
 8000d8c:	3901      	subs	r1, #1
    str r1, [rDEVP, #device4_COUNT]
 8000d8e:	f8c5 1030 	str.w	r1, [r5, #48]	@ 0x30
    cbnz r1, 1f
 8000d92:	b979      	cbnz	r1, 8000db4 <device4_OFFtask+0x2c>
    ldr r0, [rDEVP, #device4_TARGET]
 8000d94:	f8d5 0024 	ldr.w	r0, [r5, #36]	@ 0x24
    bl  DAC1_CH2_output
 8000d98:	f000 f85a 	bl	8000e50 <DAC1_CH2_output>
    ldr r1, [rDEVP, #device4_RELOAD]
 8000d9c:	f8d5 102c 	ldr.w	r1, [r5, #44]	@ 0x2c
    str r1, [rDEVP, #device4_COUNT]
 8000da0:	f8c5 1030 	str.w	r1, [r5, #48]	@ 0x30
    MOV_imm32 r0, device4_ONtask
 8000da4:	f640 5057 	movw	r0, #3415	@ 0xd57
 8000da8:	f6c0 0000 	movt	r0, #2048	@ 0x800
    mov r1, #NULL
 8000dac:	f04f 0100 	mov.w	r1, #0
    bl  MoT_taskUpdate
 8000db0:	f001 fc7d 	bl	80026ae <MoT_taskUpdate>
1:
    ldr rDEVP, [rDEVP, #NEXTTASK]
 8000db4:	68ad      	ldr	r5, [r5, #8]
    ldr pc, [rDEVP, #XEQTASK]
 8000db6:	f8d5 f004 	ldr.w	pc, [r5, #4]

08000dba <device4_stop_periodictask>:
@ to the console.
@======================================================================
.global device4_stop_periodictask
.thumb_func
device4_stop_periodictask:
    MOV_imm32 r0, device4_skiptask
 8000dba:	f640 50ed 	movw	r0, #3565	@ 0xded
 8000dbe:	f6c0 0000 	movt	r0, #2048	@ 0x800
    mov r1, #NULL
 8000dc2:	f04f 0100 	mov.w	r1, #0
    bl MoT_taskUpdate
 8000dc6:	f001 fc72 	bl	80026ae <MoT_taskUpdate>
    mov r0, #0
 8000dca:	f04f 0000 	mov.w	r0, #0
    bl DAC1_CH2_output
 8000dce:	f000 f83f 	bl	8000e50 <DAC1_CH2_output>
    MOV_imm32 r0, device4_stopmsg
 8000dd2:	f240 10ec 	movw	r0, #492	@ 0x1ec
 8000dd6:	f2c2 0000 	movt	r0, #8192	@ 0x2000
    MOV_imm32 r1, consoleMsgs
 8000dda:	f640 416c 	movw	r1, #3180	@ 0xc6c
 8000dde:	f2c2 0100 	movt	r1, #8192	@ 0x2000
    bl    MoT_msgPost
 8000de2:	f001 fc7e 	bl	80026e2 <MoT_msgPost>
    mov r0, #0
 8000de6:	f04f 0000 	mov.w	r0, #0
    pop {r7, pc}
 8000dea:	bd80      	pop	{r7, pc}

08000dec <device4_skiptask>:
@ by loading the next task's context (rDEVP) and jumping to its execution address.
@======================================================================
.global device4_skiptask
.thumb_func
device4_skiptask:
    ldr rDEVP, [rDEVP, #NEXTTASK]
 8000dec:	68ad      	ldr	r5, [r5, #8]
    ldr pc, [rDEVP, #XEQTASK]
 8000dee:	f8d5 f004 	ldr.w	pc, [r5, #4]

08000df2 <PA5init>:
@    by the DAC peripheral.
@======================================================================
.global PA5init
.thumb_func
PA5init:
    push   {r7, lr}
 8000df2:	b580      	push	{r7, lr}
    MOV_imm32 r3, RCC_BASE
 8000df4:	f241 0300 	movw	r3, #4096	@ 0x1000
 8000df8:	f2c4 0302 	movt	r3, #16386	@ 0x4002
    ldr    r1, [r3, #AHB2ENR]
 8000dfc:	6cd9      	ldr	r1, [r3, #76]	@ 0x4c
    orr    r1, r1, #GPIOAEN
 8000dfe:	f041 0101 	orr.w	r1, r1, #1
    str    r1, [r3, #AHB2ENR]
 8000e02:	64d9      	str	r1, [r3, #76]	@ 0x4c
    MOV_imm32 r3, GPIOA_BASE
 8000e04:	f240 0300 	movw	r3, #0
 8000e08:	f6c4 0300 	movt	r3, #18432	@ 0x4800
    ldr    r1, [r3, #MODER]
 8000e0c:	6819      	ldr	r1, [r3, #0]
    bic    r1, r1, #(0b11 << (5*2))
 8000e0e:	f421 6140 	bic.w	r1, r1, #3072	@ 0xc00
    orr    r1, r1, #(0b11 << (5*2))
 8000e12:	f441 6140 	orr.w	r1, r1, #3072	@ 0xc00
    str    r1, [r3, #MODER]
 8000e16:	6019      	str	r1, [r3, #0]
    pop    {r7, pc}
 8000e18:	bd80      	pop	{r7, pc}

08000e1a <DAC1_CH2_init>:
@ 4. Enables DAC1 Channel 2 by setting the EN2 bit in the DAC_CR register.
@======================================================================
.global DAC1_CH2_init
.thumb_func
DAC1_CH2_init:
    push   {r7, lr}
 8000e1a:	b580      	push	{r7, lr}
    bl     PA5init
 8000e1c:	f7ff ffe9 	bl	8000df2 <PA5init>
    MOV_imm32 r3, RCC_BASE
 8000e20:	f241 0300 	movw	r3, #4096	@ 0x1000
 8000e24:	f2c4 0302 	movt	r3, #16386	@ 0x4002
    ldr    r1, [r3, #AHB2ENR]
 8000e28:	6cd9      	ldr	r1, [r3, #76]	@ 0x4c
    orr    r1, r1, #DAC1EN
 8000e2a:	f441 3180 	orr.w	r1, r1, #65536	@ 0x10000
    str    r1, [r3, #AHB2ENR]
 8000e2e:	64d9      	str	r1, [r3, #76]	@ 0x4c
    ldr    r1, [r3, #AHB2RSTR]
 8000e30:	6ad9      	ldr	r1, [r3, #44]	@ 0x2c
    orr    r1, r1, #DAC1RST
 8000e32:	f441 3180 	orr.w	r1, r1, #65536	@ 0x10000
    str    r1, [r3, #AHB2RSTR]
 8000e36:	62d9      	str	r1, [r3, #44]	@ 0x2c
    bic    r1, r1, #DAC1RST
 8000e38:	f421 3180 	bic.w	r1, r1, #65536	@ 0x10000
    str    r1, [r3, #AHB2RSTR]
 8000e3c:	62d9      	str	r1, [r3, #44]	@ 0x2c
    MOV_imm32 r3, DAC1_BASE
 8000e3e:	f640 0300 	movw	r3, #2048	@ 0x800
 8000e42:	f2c5 0300 	movt	r3, #20480	@ 0x5000
    ldr    r1, [r3, #CR]
 8000e46:	6819      	ldr	r1, [r3, #0]
    orr    r1, r1, #CR_EN2
 8000e48:	f441 3180 	orr.w	r1, r1, #65536	@ 0x10000
    str    r1, [r3, #CR]
 8000e4c:	6019      	str	r1, [r3, #0]
    pop    {r7, pc}
 8000e4e:	bd80      	pop	{r7, pc}

08000e50 <DAC1_CH2_output>:
@ r0: Input, the 12-bit value to output (0x000 to 0xFFF).
@======================================================================
.global DAC1_CH2_output
.thumb_func
DAC1_CH2_output:
    push   {r7, lr}
 8000e50:	b580      	push	{r7, lr}
    MOV_imm32 r3, DAC1_BASE
 8000e52:	f640 0300 	movw	r3, #2048	@ 0x800
 8000e56:	f2c5 0300 	movt	r3, #20480	@ 0x5000
    str    r0, [r3, #DAC_DHR12R2]
 8000e5a:	6158      	str	r0, [r3, #20]
    pop    {r7, pc}
 8000e5c:	bd80      	pop	{r7, pc}
 8000e5e:	0000      	.short	0x0000
	ldr r3, =trigger_state
 8000e60:	2000156c 	.word	0x2000156c

08000e64 <EXTI1_init>:
@ r0: May point to a 16-bit DAC value if trigger_state indicates Device 4.
@======================================================================
.global EXTI1_init
.thumb_func
EXTI1_init:
     push {r7, lr}
 8000e64:	b580      	push	{r7, lr}

	ldr r4, =trigger_state
 8000e66:	4c4f      	ldr	r4, [pc, #316]	@ (8000fa4 <report_triggered+0x6>)
	ldr r1, [r4]
 8000e68:	6821      	ldr	r1, [r4, #0]
	cmp r1, #1
 8000e6a:	2901      	cmp	r1, #1
	bne Rest_and_DAC
 8000e6c:	d105      	bne.n	8000e7a <Rest_and_DAC>

08000e6e <DAC_specific>:

DAC_specific:
	ldrh  r1, [r0], #2
 8000e6e:	f830 1b02 	ldrh.w	r1, [r0], #2
    bl    swap_low2bytes_r1
 8000e72:	f001 f841 	bl	8001ef8 <swap_low2bytes_r1>
    ldr   r2, =device4_TRIG_VAL
 8000e76:	4a4c      	ldr	r2, [pc, #304]	@ (8000fa8 <report_triggered+0xa>)
    str   r1, [r2]
 8000e78:	6011      	str	r1, [r2, #0]

08000e7a <Rest_and_DAC>:

Rest_and_DAC:
    MOV_imm32 r3, RCC_BASE
 8000e7a:	f241 0300 	movw	r3, #4096	@ 0x1000
 8000e7e:	f2c4 0302 	movt	r3, #16386	@ 0x4002
    ldr     r1, [r3, #AHB2ENR]
 8000e82:	6cd9      	ldr	r1, [r3, #76]	@ 0x4c
    orr     r1, r1, #GPIOAEN
 8000e84:	f041 0101 	orr.w	r1, r1, #1
    str     r1, [r3, #AHB2ENR]
 8000e88:	64d9      	str	r1, [r3, #76]	@ 0x4c

    MOV_imm32 r3, GPIOA_BASE
 8000e8a:	f240 0300 	movw	r3, #0
 8000e8e:	f6c4 0300 	movt	r3, #18432	@ 0x4800
    ldr     r1, [r3, #MODER]
 8000e92:	6819      	ldr	r1, [r3, #0]
    bic     r1, r1, #(0b11 << 2)
 8000e94:	f021 010c 	bic.w	r1, r1, #12
    str     r1, [r3, #MODER]
 8000e98:	6019      	str	r1, [r3, #0]

    ldr     r1, [r3, #0x0C]
 8000e9a:	68d9      	ldr	r1, [r3, #12]
    bic     r1, r1, #(0b11 << 2)
 8000e9c:	f021 010c 	bic.w	r1, r1, #12
    orr     r1, r1, #(0b10 << 2)
 8000ea0:	f041 0108 	orr.w	r1, r1, #8
    str     r1, [r3, #0x0C]
 8000ea4:	60d9      	str	r1, [r3, #12]

    MOV_imm32 r3, RCC_BASE
 8000ea6:	f241 0300 	movw	r3, #4096	@ 0x1000
 8000eaa:	f2c4 0302 	movt	r3, #16386	@ 0x4002
    ldr     r1, [r3, #0x60]
 8000eae:	6e19      	ldr	r1, [r3, #96]	@ 0x60
    orr     r1, r1, #(1 << 0)
 8000eb0:	f041 0101 	orr.w	r1, r1, #1
    str     r1, [r3, #0x60]
 8000eb4:	6619      	str	r1, [r3, #96]	@ 0x60

    MOV_imm32 r3, 0x40010000
 8000eb6:	f240 0300 	movw	r3, #0
 8000eba:	f2c4 0301 	movt	r3, #16385	@ 0x4001
    movs    r1, #0
 8000ebe:	2100      	movs	r1, #0
    str     r1, [r3, #0x08]
 8000ec0:	6099      	str	r1, [r3, #8]

    MOV_imm32 r3, 0x40010400
 8000ec2:	f240 4300 	movw	r3, #1024	@ 0x400
 8000ec6:	f2c4 0301 	movt	r3, #16385	@ 0x4001

    ldr     r1, [r3, #0x00]
 8000eca:	6819      	ldr	r1, [r3, #0]
    orr     r1, r1, #(1 << 1)
 8000ecc:	f041 0102 	orr.w	r1, r1, #2
    str     r1, [r3, #0x00]
 8000ed0:	6019      	str	r1, [r3, #0]

    ldr     r1, [r3, #0x08]
 8000ed2:	6899      	ldr	r1, [r3, #8]
    orr     r1, r1, #(1 << 1)
 8000ed4:	f041 0102 	orr.w	r1, r1, #2
    str     r1, [r3, #0x08]
 8000ed8:	6099      	str	r1, [r3, #8]

    movs    r1, #(1 << 1)
 8000eda:	2102      	movs	r1, #2
    str     r1, [r3, #0x14]
 8000edc:	6159      	str	r1, [r3, #20]

    movs    r0, #7
 8000ede:	2007      	movs	r0, #7
    movs    r1, #1
 8000ee0:	2101      	movs	r1, #1
    lsl     r1, r1, r0
 8000ee2:	fa01 f100 	lsl.w	r1, r1, r0
    ldr     r2, =0xE000E100
 8000ee6:	4a31      	ldr	r2, [pc, #196]	@ (8000fac <report_triggered+0xe>)
    str     r1, [r2]
 8000ee8:	6011      	str	r1, [r2, #0]

    pop {r7, pc}
 8000eea:	bd80      	pop	{r7, pc}

08000eec <EXTI1_IRQHandler>:
@ Registers r0-r7 and lr are saved and restored.
@======================================================================
 .global EXTI1_IRQHandler
.thumb_func
EXTI1_IRQHandler:
    push {r0-r7, lr}
 8000eec:	b5ff      	push	{r0, r1, r2, r3, r4, r5, r6, r7, lr}
	mov r0, #100
 8000eee:	f04f 0064 	mov.w	r0, #100	@ 0x64
	bl delay
 8000ef2:	f001 f84e 	bl	8001f92 <delay>
    MOVW    r0, #:lower16:0x40010414
 8000ef6:	f240 4014 	movw	r0, #1044	@ 0x414
    MOVT    r0, #:upper16:0x40010414
 8000efa:	f2c4 0001 	movt	r0, #16385	@ 0x4001
    movs    r1, #(1 << 1)
 8000efe:	2102      	movs	r1, #2
    str     r1, [r0]
 8000f00:	6001      	str	r1, [r0, #0]

	ldr r0, =trigger_state
 8000f02:	4828      	ldr	r0, [pc, #160]	@ (8000fa4 <report_triggered+0x6>)
	ldr r1, [r0]
 8000f04:	6801      	ldr	r1, [r0, #0]
	cmp r1, #1
 8000f06:	2901      	cmp	r1, #1
	beq device4_EXTI1_IRQHandler
 8000f08:	d010      	beq.n	8000f2c <device4_EXTI1_IRQHandler>

	cmp r1, #2
 8000f0a:	2902      	cmp	r1, #2
	beq device5_EXTI1_IRQHandler
 8000f0c:	d013      	beq.n	8000f36 <device5_EXTI1_IRQHandler>

	cmp r1, #8
 8000f0e:	2908      	cmp	r1, #8
	beq device3_cmd_8_EXTI1_IRQHandler
 8000f10:	d042      	beq.n	8000f98 <device3_cmd_8_EXTI1_IRQHandler>

	bl device6_timer_output_disable
 8000f12:	f000 fda7 	bl	8001a64 <device6_timer_output_disable>
	cmp r1, #3
 8000f16:	2903      	cmp	r1, #3
	beq device6_cmd_1_EXTI1_IRQHandler
 8000f18:	d00f      	beq.n	8000f3a <device6_cmd_1_EXTI1_IRQHandler>

	cmp r1, #4
 8000f1a:	2904      	cmp	r1, #4
	beq device6_cmd_2_EXTI1_IRQHandler
 8000f1c:	d018      	beq.n	8000f50 <device6_cmd_2_EXTI1_IRQHandler>

	cmp r1, #5
 8000f1e:	2905      	cmp	r1, #5
	beq device6_cmd_3_EXTI1_IRQHandler
 8000f20:	d021      	beq.n	8000f66 <device6_cmd_3_EXTI1_IRQHandler>

	cmp r1, #6
 8000f22:	2906      	cmp	r1, #6
	beq device6_cmd_4_EXTI1_IRQHandler
 8000f24:	d026      	beq.n	8000f74 <device6_cmd_4_EXTI1_IRQHandler>

	cmp r1, #7
 8000f26:	2907      	cmp	r1, #7
	beq device6_cmd_5_EXTI1_IRQHandler
 8000f28:	d02f      	beq.n	8000f8a <device6_cmd_5_EXTI1_IRQHandler>

    pop {r0-r7, pc}
 8000f2a:	bdff      	pop	{r0, r1, r2, r3, r4, r5, r6, r7, pc}

08000f2c <device4_EXTI1_IRQHandler>:
@ 'device4_TRIG_VAL' and then calls 'DAC1_CH2_output' to output this
@ voltage on DAC1 Channel 2 (PA5).
@======================================================================
.thumb_func
device4_EXTI1_IRQHandler:
    ldr   r2, =device4_TRIG_VAL
 8000f2c:	4a1e      	ldr	r2, [pc, #120]	@ (8000fa8 <report_triggered+0xa>)
    ldr r0, [r2]
 8000f2e:	6810      	ldr	r0, [r2, #0]
    bl      DAC1_CH2_output
 8000f30:	f7ff ff8e 	bl	8000e50 <DAC1_CH2_output>
	pop {r0-r7, pc}
 8000f34:	bdff      	pop	{r0, r1, r2, r3, r4, r5, r6, r7, pc}

08000f36 <device5_EXTI1_IRQHandler>:
@ It then calls 'report_triggered' which handles ADC operations
@ for Device 5 in a triggered context (e.g., performs an ADC read and reports it).
@======================================================================
.thumb_func
device5_EXTI1_IRQHandler:
    bl      report_triggered
 8000f36:	f000 f832 	bl	8000f9e <report_triggered>

08000f3a <device6_cmd_1_EXTI1_IRQHandler>:
@ Then, it calls 'device6_pwm_enable' to start or update the PWM signal
@ on TIM2_CH1 (PA5) with these parameters.
@======================================================================
.thumb_func
device6_cmd_1_EXTI1_IRQHandler:
	ldr r6, =temp_pwm_arr_val
 8000f3a:	4e1d      	ldr	r6, [pc, #116]	@ (8000fb0 <report_triggered+0x12>)
	ldr r6, [r6]
 8000f3c:	6836      	ldr	r6, [r6, #0]
	ldr r5, =pwm_arr_val
 8000f3e:	4d1d      	ldr	r5, [pc, #116]	@ (8000fb4 <report_triggered+0x16>)
	str r6, [r5]
 8000f40:	602e      	str	r6, [r5, #0]

	ldr r6, =temp_pwm_arr_duty
 8000f42:	4e1d      	ldr	r6, [pc, #116]	@ (8000fb8 <report_triggered+0x1a>)
	ldrb r6, [r6]
 8000f44:	7836      	ldrb	r6, [r6, #0]
	ldr r5, =pwm_arr_duty
 8000f46:	4d1d      	ldr	r5, [pc, #116]	@ (8000fbc <report_triggered+0x1e>)
	strb r6, [r5]
 8000f48:	702e      	strb	r6, [r5, #0]

	bl device6_pwm_enable
 8000f4a:	f000 fde7 	bl	8001b1c <device6_pwm_enable>
	pop {r0-r7, pc}
 8000f4e:	bdff      	pop	{r0, r1, r2, r3, r4, r5, r6, r7, pc}

08000f50 <device6_cmd_2_EXTI1_IRQHandler>:
@ parameters into active operational variables.
@ Then, it calls 'device6_pwm_enable' to start/update the PFM signal.
@======================================================================
.thumb_func
device6_cmd_2_EXTI1_IRQHandler:
	ldr r6, =temp_pwm_arr_val
 8000f50:	4e17      	ldr	r6, [pc, #92]	@ (8000fb0 <report_triggered+0x12>)
	ldr r6, [r6]
 8000f52:	6836      	ldr	r6, [r6, #0]
	ldr r5, =pwm_arr_val
 8000f54:	4d17      	ldr	r5, [pc, #92]	@ (8000fb4 <report_triggered+0x16>)
	str r6, [r5]
 8000f56:	602e      	str	r6, [r5, #0]

	ldr r6, =temp_pwm_arr_duty
 8000f58:	4e17      	ldr	r6, [pc, #92]	@ (8000fb8 <report_triggered+0x1a>)
	ldrb r6, [r6]
 8000f5a:	7836      	ldrb	r6, [r6, #0]
	ldr r5, =pwm_arr_duty
 8000f5c:	4d17      	ldr	r5, [pc, #92]	@ (8000fbc <report_triggered+0x1e>)
	strb r6, [r5]
 8000f5e:	702e      	strb	r6, [r5, #0]

	bl device6_pwm_enable
 8000f60:	f000 fddc 	bl	8001b1c <device6_pwm_enable>
	pop {r0-r7, pc}
 8000f64:	bdff      	pop	{r0, r1, r2, r3, r4, r5, r6, r7, pc}

08000f66 <device6_cmd_3_EXTI1_IRQHandler>:
@ into the active operational variable 'simple_pulse_width_ticks_val'.
@ Then, it calls 'device6_simple_pulse_enable' to generate a single pulse.
@======================================================================
.thumb_func
device6_cmd_3_EXTI1_IRQHandler:
	ldr r6, =temp_simple_pulse_width_ticks_val
 8000f66:	4e16      	ldr	r6, [pc, #88]	@ (8000fc0 <report_triggered+0x22>)
	ldr r6, [r6]
 8000f68:	6836      	ldr	r6, [r6, #0]
	ldr r5, =simple_pulse_width_ticks_val
 8000f6a:	4d16      	ldr	r5, [pc, #88]	@ (8000fc4 <report_triggered+0x26>)
	str r6, [r5]
 8000f6c:	602e      	str	r6, [r5, #0]

	bl device6_simple_pulse_enable
 8000f6e:	f000 fe46 	bl	8001bfe <device6_simple_pulse_enable>
	pop {r0-r7, pc}
 8000f72:	bdff      	pop	{r0, r1, r2, r3, r4, r5, r6, r7, pc}

08000f74 <device6_cmd_4_EXTI1_IRQHandler>:
@ ('opm_delay_ticks_val', 'opm_width_ticks_val').
@ Then, it calls 'device6_opm_enable' to generate a single pulse with specified delay and width.
@======================================================================
.thumb_func
device6_cmd_4_EXTI1_IRQHandler:
	ldr r6, =temp_opm_delay_ticks_val
 8000f74:	4e14      	ldr	r6, [pc, #80]	@ (8000fc8 <report_triggered+0x2a>)
	ldr r6, [r6]
 8000f76:	6836      	ldr	r6, [r6, #0]
	ldr r5, =opm_delay_ticks_val
 8000f78:	4d14      	ldr	r5, [pc, #80]	@ (8000fcc <report_triggered+0x2e>)
	str r6, [r5]
 8000f7a:	602e      	str	r6, [r5, #0]

	ldr r6, =temp_opm_width_ticks_val
 8000f7c:	4e14      	ldr	r6, [pc, #80]	@ (8000fd0 <report_triggered+0x32>)
	ldr r6, [r6]
 8000f7e:	6836      	ldr	r6, [r6, #0]
	ldr r5, =opm_width_ticks_val
 8000f80:	4d14      	ldr	r5, [pc, #80]	@ (8000fd4 <report_triggered+0x36>)
	str r6, [r5]
 8000f82:	602e      	str	r6, [r5, #0]

	bl device6_opm_enable
 8000f84:	f000 fe04 	bl	8001b90 <device6_opm_enable>
	pop {r0-r7, pc}
 8000f88:	bdff      	pop	{r0, r1, r2, r3, r4, r5, r6, r7, pc}

08000f8a <device6_cmd_5_EXTI1_IRQHandler>:
@ Then, it calls 'device6_single_freq_cycle_enable' to generate a single pulse
@ cycle at the specified frequency.
@======================================================================
.thumb_func
device6_cmd_5_EXTI1_IRQHandler:
	ldr r6, =temp_single_freq_cycle_target_hz_val
 8000f8a:	4e13      	ldr	r6, [pc, #76]	@ (8000fd8 <report_triggered+0x3a>)
	ldr r6, [r6]
 8000f8c:	6836      	ldr	r6, [r6, #0]
	ldr r5, =single_freq_cycle_target_hz_val
 8000f8e:	4d13      	ldr	r5, [pc, #76]	@ (8000fdc <report_triggered+0x3e>)
	str r6, [r5]
 8000f90:	602e      	str	r6, [r5, #0]

	bl device6_single_freq_cycle_enable
 8000f92:	f000 fe40 	bl	8001c16 <device6_single_freq_cycle_enable>
	pop {r0-r7, pc}
 8000f96:	bdff      	pop	{r0, r1, r2, r3, r4, r5, r6, r7, pc}

08000f98 <device3_cmd_8_EXTI1_IRQHandler>:
@ It then calls 'device3_input_read' to read the state of a GPIO pin
@ The main IRQ handler already saved r0-r7, lr.
@======================================================================
.thumb_func
device3_cmd_8_EXTI1_IRQHandler:
	pop {r0-r6}
 8000f98:	bc7f      	pop	{r0, r1, r2, r3, r4, r5, r6}
	bl device3_input_read
 8000f9a:	f000 f8e1 	bl	8001160 <device3_input_read>

08000f9e <report_triggered>:
@ then pushes r7 and lr (standard function prologue), and finally branches
@ to 'report_ADC_amp' to perform the ADC reading and reporting.
@======================================================================
.thumb_func
report_triggered:
	pop {r0-r6}
 8000f9e:	bc7f      	pop	{r0, r1, r2, r3, r4, r5, r6}
	b report_ADC_amp
 8000fa0:	f7ff bcf8 	b.w	8000994 <report_ADC_amp>
	ldr r4, =trigger_state
 8000fa4:	2000156c 	.word	0x2000156c
    ldr   r2, =device4_TRIG_VAL
 8000fa8:	2000020c 	.word	0x2000020c
    ldr     r2, =0xE000E100
 8000fac:	e000e100 	.word	0xe000e100
	ldr r6, =temp_pwm_arr_val
 8000fb0:	20000634 	.word	0x20000634
	ldr r5, =pwm_arr_val
 8000fb4:	20000654 	.word	0x20000654
	ldr r6, =temp_pwm_arr_duty
 8000fb8:	20000638 	.word	0x20000638
	ldr r5, =pwm_arr_duty
 8000fbc:	20000658 	.word	0x20000658
	ldr r6, =temp_simple_pulse_width_ticks_val
 8000fc0:	20000650 	.word	0x20000650
	ldr r5, =simple_pulse_width_ticks_val
 8000fc4:	20000670 	.word	0x20000670
	ldr r6, =temp_opm_delay_ticks_val
 8000fc8:	2000063c 	.word	0x2000063c
	ldr r5, =opm_delay_ticks_val
 8000fcc:	2000065c 	.word	0x2000065c
	ldr r6, =temp_opm_width_ticks_val
 8000fd0:	20000640 	.word	0x20000640
	ldr r5, =opm_width_ticks_val
 8000fd4:	20000660 	.word	0x20000660
	ldr r6, =temp_single_freq_cycle_target_hz_val
 8000fd8:	2000064c 	.word	0x2000064c
	ldr r5, =single_freq_cycle_target_hz_val
 8000fdc:	2000066c 	.word	0x2000066c

08000fe0 <PA8_init>:
@ This setup prepares PA8 to be driven HIGH or LOW by the microcontroller.
@======================================================================
    .global PA8_init
    .thumb_func
PA8_init:
    push {r7, lr}
 8000fe0:	b580      	push	{r7, lr}

    MOV_imm32 r3, RCC_BASE
 8000fe2:	f241 0300 	movw	r3, #4096	@ 0x1000
 8000fe6:	f2c4 0302 	movt	r3, #16386	@ 0x4002
    ldr r1, [r3, #AHB2ENR]
 8000fea:	6cd9      	ldr	r1, [r3, #76]	@ 0x4c
    orr r1, r1, #GPIOAEN
 8000fec:	f041 0101 	orr.w	r1, r1, #1
    str r1, [r3, #AHB2ENR]
 8000ff0:	64d9      	str	r1, [r3, #76]	@ 0x4c

    MOV_imm32 r3, GPIOA_BASE
 8000ff2:	f240 0300 	movw	r3, #0
 8000ff6:	f6c4 0300 	movt	r3, #18432	@ 0x4800
    ldr r1, [r3, #MODER]
 8000ffa:	6819      	ldr	r1, [r3, #0]

    bic r1, r1, #(0b11 << (PA8 * 2))
 8000ffc:	f421 3140 	bic.w	r1, r1, #196608	@ 0x30000

    orr r1, r1, #(0b01 << (PA8 * 2))
 8001000:	f441 3180 	orr.w	r1, r1, #65536	@ 0x10000
    str r1, [r3, #MODER]
 8001004:	6019      	str	r1, [r3, #0]

    ldr r1, [r3, #OTYPER]
 8001006:	6859      	ldr	r1, [r3, #4]

    bic r1, r1, #(1 << PA8)
 8001008:	f421 7180 	bic.w	r1, r1, #256	@ 0x100
    str r1, [r3, #OTYPER]
 800100c:	6059      	str	r1, [r3, #4]

    ldr r1, [r3, #OPUPDR]
 800100e:	68d9      	ldr	r1, [r3, #12]

    bic r1, r1, #(0b11 << (PA8 * 2))
 8001010:	f421 3140 	bic.w	r1, r1, #196608	@ 0x30000
    str r1, [r3, #OPUPDR]
 8001014:	60d9      	str	r1, [r3, #12]

    pop {r7, pc}
 8001016:	bd80      	pop	{r7, pc}

08001018 <PA8_input_init>:
@ This prepares PA8 to read its digital state.
@======================================================================
    .global PA8_input_init
    .thumb_func
PA8_input_init:
    push {r7, lr}
 8001018:	b580      	push	{r7, lr}

    MOV_imm32 r3, RCC_BASE
 800101a:	f241 0300 	movw	r3, #4096	@ 0x1000
 800101e:	f2c4 0302 	movt	r3, #16386	@ 0x4002
    ldr r1, [r3, #AHB2ENR]
 8001022:	6cd9      	ldr	r1, [r3, #76]	@ 0x4c
    orr r1, r1, #GPIOAEN
 8001024:	f041 0101 	orr.w	r1, r1, #1
    str r1, [r3, #AHB2ENR]
 8001028:	64d9      	str	r1, [r3, #76]	@ 0x4c

    MOV_imm32 r3, GPIOA_BASE
 800102a:	f240 0300 	movw	r3, #0
 800102e:	f6c4 0300 	movt	r3, #18432	@ 0x4800
    ldr r1, [r3, #MODER]
 8001032:	6819      	ldr	r1, [r3, #0]
    bic r1, r1, #(0b11 << (PA8 * 2))
 8001034:	f421 3140 	bic.w	r1, r1, #196608	@ 0x30000
    str r1, [r3, #MODER]
 8001038:	6019      	str	r1, [r3, #0]

    ldr r1, [r3, #OPUPDR]
 800103a:	68d9      	ldr	r1, [r3, #12]
    bic r1, r1, #(0b11 << (PA8 * 2))
 800103c:	f421 3140 	bic.w	r1, r1, #196608	@ 0x30000
    str r1, [r3, #OPUPDR]
 8001040:	60d9      	str	r1, [r3, #12]

    pop {r7, pc}
 8001042:	bd80      	pop	{r7, pc}

08001044 <PA8_read>:
@   r0: 0 if PA8 is LOW, 1 if PA8 is HIGH.
@======================================================================
    .global PA8_read
    .thumb_func
PA8_read:
    push {r7, lr}
 8001044:	b580      	push	{r7, lr}
    MOV_imm32 r1, 0x48000010
 8001046:	f240 0110 	movw	r1, #16
 800104a:	f6c4 0100 	movt	r1, #18432	@ 0x4800
    ldrb    r0, [r1, #0]
 800104e:	7808      	ldrb	r0, [r1, #0]
    ldrb    r0, [r1, #1]
 8001050:	7848      	ldrb	r0, [r1, #1]
    ands    r0, r0, #1
 8001052:	f010 0001 	ands.w	r0, r0, #1
    pop {r7, pc}
 8001056:	bd80      	pop	{r7, pc}

08001058 <low_n_skip>:
@ 3. Passes execution control to the next MoT task in the system.
@======================================================================
.global low_n_skip
    .thumb_func
low_n_skip:
    MOV_imm32 r0, monitor_task
 8001058:	f241 3047 	movw	r0, #4935	@ 0x1347
 800105c:	f6c0 0000 	movt	r0, #2048	@ 0x800
  	mov     r1, #NULL
 8001060:	f04f 0100 	mov.w	r1, #0
    bl      MoT_taskUpdate
 8001064:	f001 fb23 	bl	80026ae <MoT_taskUpdate>
    MOV_imm32 r0, device3_input_lowmsg
 8001068:	f240 206c 	movw	r0, #620	@ 0x26c
 800106c:	f2c2 0000 	movt	r0, #8192	@ 0x2000
    MOV_imm32 r1, consoleMsgs
 8001070:	f640 416c 	movw	r1, #3180	@ 0xc6c
 8001074:	f2c2 0100 	movt	r1, #8192	@ 0x2000
    bl MoT_msgPost
 8001078:	f001 fb33 	bl	80026e2 <MoT_msgPost>
    ldr rDEVP, [rDEVP, #NEXTTASK]
 800107c:	68ad      	ldr	r5, [r5, #8]
    ldr pc, [rDEVP, #XEQTASK]
 800107e:	f8d5 f004 	ldr.w	pc, [r5, #4]

08001082 <high_n_skip>:
@ 3. Passes execution control to the next MoT task in the system.
@======================================================================
.global high_n_skip
    .thumb_func
high_n_skip:
    MOV_imm32 r0, monitor_task
 8001082:	f241 3047 	movw	r0, #4935	@ 0x1347
 8001086:	f6c0 0000 	movt	r0, #2048	@ 0x800
  	mov     r1, #NULL
 800108a:	f04f 0100 	mov.w	r1, #0
    bl      MoT_taskUpdate
 800108e:	f001 fb0e 	bl	80026ae <MoT_taskUpdate>
    MOV_imm32 r0, device3_input_highmsg
 8001092:	f240 208c 	movw	r0, #652	@ 0x28c
 8001096:	f2c2 0000 	movt	r0, #8192	@ 0x2000
    MOV_imm32 r1, consoleMsgs
 800109a:	f640 416c 	movw	r1, #3180	@ 0xc6c
 800109e:	f2c2 0100 	movt	r1, #8192	@ 0x2000
    bl MoT_msgPost
 80010a2:	f001 fb1e 	bl	80026e2 <MoT_msgPost>
    ldr rDEVP, [rDEVP, #NEXTTASK]
 80010a6:	68ad      	ldr	r5, [r5, #8]
    ldr pc, [rDEVP, #XEQTASK]
 80010a8:	f8d5 f004 	ldr.w	pc, [r5, #4]

080010ac <no_change>:
@    posting any specific change or state message.
@======================================================================
.global no_change
    .thumb_func
no_change:
    MOV_imm32 r0, monitor_task
 80010ac:	f241 3047 	movw	r0, #4935	@ 0x1347
 80010b0:	f6c0 0000 	movt	r0, #2048	@ 0x800
  	mov     r1, #NULL
 80010b4:	f04f 0100 	mov.w	r1, #0
    bl      MoT_taskUpdate
 80010b8:	f001 faf9 	bl	80026ae <MoT_taskUpdate>
    ldr rDEVP, [rDEVP, #NEXTTASK]
 80010bc:	68ad      	ldr	r5, [r5, #8]
    ldr pc, [rDEVP, #XEQTASK]
 80010be:	f8d5 f004 	ldr.w	pc, [r5, #4]

080010c2 <PA8_to_high>:
@ which atomically sets PA8 HIGH without affecting other pins.
@======================================================================
	.global PA8_to_high
	.thumb_func
PA8_to_high:
	push {r7, lr}
 80010c2:	b580      	push	{r7, lr}

    MOV_imm32 r3, GPIOA_BASE
 80010c4:	f240 0300 	movw	r3, #0
 80010c8:	f6c4 0300 	movt	r3, #18432	@ 0x4800
	mov r1, #(1 << 8)
 80010cc:	f44f 7180 	mov.w	r1, #256	@ 0x100
	str r1, [r3, #GPIOx_BSRR]
 80010d0:	6199      	str	r1, [r3, #24]

	pop {r7, pc}
 80010d2:	bd80      	pop	{r7, pc}

080010d4 <PA8_to_low>:
@ without affecting other pins.
@======================================================================
	.global PA8_to_low
	.thumb_func
PA8_to_low:
	push {r7, lr}
 80010d4:	b580      	push	{r7, lr}

    MOV_imm32 r3, GPIOA_BASE
 80010d6:	f240 0300 	movw	r3, #0
 80010da:	f6c4 0300 	movt	r3, #18432	@ 0x4800
	mov r1, #(1 << 24)
 80010de:	f04f 7180 	mov.w	r1, #16777216	@ 0x1000000
	str r1, [r3, #GPIOx_BSRR]
 80010e2:	6199      	str	r1, [r3, #24]

	pop {r7, pc}
 80010e4:	bd80      	pop	{r7, pc}

080010e6 <PA8_output_init>:
@    in the GPIOA_OPUPDR register.
@======================================================================
    .global PA8_output_init
    .thumb_func
PA8_output_init:
    push {r0-r3, lr}
 80010e6:	b50f      	push	{r0, r1, r2, r3, lr}

    MOV_imm32 r0, RCC_BASE
 80010e8:	f241 0000 	movw	r0, #4096	@ 0x1000
 80010ec:	f2c4 0002 	movt	r0, #16386	@ 0x4002
    ldr r1, [r0, #AHB2ENR]
 80010f0:	6cc1      	ldr	r1, [r0, #76]	@ 0x4c
    orr r1, r1, #GPIOAEN
 80010f2:	f041 0101 	orr.w	r1, r1, #1
    str r1, [r0, #AHB2ENR]
 80010f6:	64c1      	str	r1, [r0, #76]	@ 0x4c

    MOV_imm32 r0, GPIOA_BASE
 80010f8:	f240 0000 	movw	r0, #0
 80010fc:	f6c4 0000 	movt	r0, #18432	@ 0x4800
    ldr r1, [r0, #MODER]
 8001100:	6801      	ldr	r1, [r0, #0]

    MOV_imm32 r2, (0b11 << (PA8 * 2))
 8001102:	f240 0200 	movw	r2, #0
 8001106:	f2c0 0203 	movt	r2, #3
    bic r1, r1, r2
 800110a:	ea21 0102 	bic.w	r1, r1, r2

    MOV_imm32 r2, (0b01 << (PA8 * 2))
 800110e:	f240 0200 	movw	r2, #0
 8001112:	f2c0 0201 	movt	r2, #1
    orr r1, r1, r2
 8001116:	ea41 0102 	orr.w	r1, r1, r2
    str r1, [r0, #MODER]
 800111a:	6001      	str	r1, [r0, #0]

    ldr r1, [r0, #OPUPDR]
 800111c:	68c1      	ldr	r1, [r0, #12]
    MOV_imm32 r2, (0b11 << (PA8 * 2))
 800111e:	f240 0200 	movw	r2, #0
 8001122:	f2c0 0203 	movt	r2, #3
    bic r1, r1, r2
 8001126:	ea21 0102 	bic.w	r1, r1, r2
    str r1, [r0, #OPUPDR]
 800112a:	60c1      	str	r1, [r0, #12]

    pop {r0-r3, pc}
 800112c:	bd0f      	pop	{r0, r1, r2, r3, pc}
	...

08001130 <device3_cmdHandler>:
@ r1: Used to store and manipulate the command ID.
@======================================================================
    .global device3_cmdHandler
    .thumb_func
device3_cmdHandler:
    push {r7, lr}
 8001130:	b580      	push	{r7, lr}
    ldrb r1, [r0], #1
 8001132:	f810 1b01 	ldrb.w	r1, [r0], #1
    and  r1, r1, #0x0F
 8001136:	f001 010f 	and.w	r1, r1, #15
    tbb  [pc, r1]
 800113a:	e8df f001 	tbb	[pc, r1]

0800113e <device3_cmds>:
 800113e:	9706      	.short	0x9706
 8001140:	11d3b5a6 	.word	0x11d3b5a6
 8001144:	80624918 	.word	0x80624918
 8001148:	75          	.byte	0x75
	...

0800114a <device3_initialize>:
@ it posts the message "device3 has been initialized" to the console.
@======================================================================
	.global device3_initialize
	.thumb_func
device3_initialize:
    bl PA8_init
 800114a:	f7ff ff49 	bl	8000fe0 <PA8_init>
    add r0, rDEVP, #device3_initmsg_OFFSET
 800114e:	f105 002c 	add.w	r0, r5, #44	@ 0x2c
    MOV_imm32 r1, consoleMsgs
 8001152:	f640 416c 	movw	r1, #3180	@ 0xc6c
 8001156:	f2c2 0100 	movt	r1, #8192	@ 0x2000
    bl MoT_msgPost
 800115a:	f001 fac2 	bl	80026e2 <MoT_msgPost>
    pop {r7, pc}
 800115e:	bd80      	pop	{r7, pc}

08001160 <device3_input_read>:
@ Finally, it posts "Input is HIGH" or "Input is LOW" to the console accordingly.
@======================================================================
	.global device3_input_read
	.thumb_func
device3_input_read:
	bl PA8_input_init
 8001160:	f7ff ff5a 	bl	8001018 <PA8_input_init>
	bl PA8_read
 8001164:	f7ff ff6e 	bl	8001044 <PA8_read>
	cmp r0, #0
 8001168:	2800      	cmp	r0, #0
	beq low
 800116a:	d026      	beq.n	80011ba <low>
	b high
 800116c:	e01a      	b.n	80011a4 <high>

0800116e <device3_scheduled_read>:
@ r0: Pointer to command payload containing the 16-bit delay.
@======================================================================
    .global device3_scheduled_read
    .thumb_func
device3_scheduled_read:
	bl PA8_input_init
 800116e:	f7ff ff53 	bl	8001018 <PA8_input_init>
    mov r5, r0
 8001172:	4605      	mov	r5, r0
    MOV_imm32 r0, device3_waitingmsg
 8001174:	f240 20f0 	movw	r0, #752	@ 0x2f0
 8001178:	f2c2 0000 	movt	r0, #8192	@ 0x2000
    MOV_imm32 r1, consoleMsgs
 800117c:	f640 416c 	movw	r1, #3180	@ 0xc6c
 8001180:	f2c2 0100 	movt	r1, #8192	@ 0x2000
    bl MoT_msgPost
 8001184:	f001 faad 	bl	80026e2 <MoT_msgPost>
    mov r0, r5
 8001188:	4628      	mov	r0, r5
    bl PA8_input_init
 800118a:	f7ff ff45 	bl	8001018 <PA8_input_init>
    bl arg_retrieve_half
 800118e:	f000 fef3 	bl	8001f78 <arg_retrieve_half>
    mov r5, r0
 8001192:	4605      	mov	r5, r0
    mov r0, r1
 8001194:	4608      	mov	r0, r1
    bl delay
 8001196:	f000 fefc 	bl	8001f92 <delay>
    mov r0, r5
 800119a:	4628      	mov	r0, r5
    bl PA8_read
 800119c:	f7ff ff52 	bl	8001044 <PA8_read>
    cmp r0, #0
 80011a0:	2800      	cmp	r0, #0
    beq low
 80011a2:	d00a      	beq.n	80011ba <low>

080011a4 <high>:
high:
    MOV_imm32 r0, device3_input_highmsg
 80011a4:	f240 208c 	movw	r0, #652	@ 0x28c
 80011a8:	f2c2 0000 	movt	r0, #8192	@ 0x2000
    MOV_imm32 r1, consoleMsgs
 80011ac:	f640 416c 	movw	r1, #3180	@ 0xc6c
 80011b0:	f2c2 0100 	movt	r1, #8192	@ 0x2000
    bl MoT_msgPost
 80011b4:	f001 fa95 	bl	80026e2 <MoT_msgPost>
    b done
 80011b8:	e009      	b.n	80011ce <done>

080011ba <low>:
low:
    MOV_imm32 r0, device3_input_lowmsg
 80011ba:	f240 206c 	movw	r0, #620	@ 0x26c
 80011be:	f2c2 0000 	movt	r0, #8192	@ 0x2000
    MOV_imm32 r1, consoleMsgs
 80011c2:	f640 416c 	movw	r1, #3180	@ 0xc6c
 80011c6:	f2c2 0100 	movt	r1, #8192	@ 0x2000
    bl MoT_msgPost
 80011ca:	f001 fa8a 	bl	80026e2 <MoT_msgPost>

080011ce <done>:
done:
    pop {r7, pc}
 80011ce:	bd80      	pop	{r7, pc}

080011d0 <device3_monitored>:
@ Schedules the 'monitor_task' using 'MoT_taskUpdate' to periodically check PA8.
@======================================================================
    .global device3_monitored
    .thumb_func
device3_monitored:
	MOV_imm32 r0, device3_monitormsg
 80011d0:	f240 3014 	movw	r0, #788	@ 0x314
 80011d4:	f2c2 0000 	movt	r0, #8192	@ 0x2000
    MOV_imm32 r1, consoleMsgs
 80011d8:	f640 416c 	movw	r1, #3180	@ 0xc6c
 80011dc:	f2c2 0100 	movt	r1, #8192	@ 0x2000
    bl MoT_msgPost
 80011e0:	f001 fa7f 	bl	80026e2 <MoT_msgPost>
	bl PA8_input_init
 80011e4:	f7ff ff18 	bl	8001018 <PA8_input_init>
	bl PA8_read
 80011e8:	f7ff ff2c 	bl	8001044 <PA8_read>
    str r1, [rDEVP, #device3_PREVIOUS]
 80011ec:	f8c5 1028 	str.w	r1, [r5, #40]	@ 0x28
    mov     r1, #NULL
 80011f0:	f04f 0100 	mov.w	r1, #0
  	MOV_imm32 r0, monitor_task
 80011f4:	f241 3047 	movw	r0, #4935	@ 0x1347
 80011f8:	f6c0 0000 	movt	r0, #2048	@ 0x800
    bl      MoT_taskUpdate
 80011fc:	f001 fa57 	bl	80026ae <MoT_taskUpdate>
    pop {r7, pc}
 8001200:	bd80      	pop	{r7, pc}

08001202 <device3_trig>:
@ Posts "Trigger on PA1" to the console.
@======================================================================
    .global device3_trig
    .thumb_func
device3_trig:
	bl PA8_input_init
 8001202:	f7ff ff09 	bl	8001018 <PA8_input_init>
  	ldr r0, =trigger_state
 8001206:	4866      	ldr	r0, [pc, #408]	@ (80013a0 <device3_skiptask+0x8>)
	mov r1, #8
 8001208:	f04f 0108 	mov.w	r1, #8
	str r1, [r0]
 800120c:	6001      	str	r1, [r0, #0]
	bl    EXTI1_init
 800120e:	f7ff fe29 	bl	8000e64 <EXTI1_init>
    MOV_imm32 r0, device3_trigmsg
 8001212:	f240 3038 	movw	r0, #824	@ 0x338
 8001216:	f2c2 0000 	movt	r0, #8192	@ 0x2000
    MOV_imm32 r1, consoleMsgs
 800121a:	f640 416c 	movw	r1, #3180	@ 0xc6c
 800121e:	f2c2 0100 	movt	r1, #8192	@ 0x2000
    bl      MoT_msgPost
 8001222:	f001 fa5e 	bl	80026e2 <MoT_msgPost>
    pop {r7, pc}
 8001226:	bd80      	pop	{r7, pc}

08001228 <device3_trig_result>:
@ the message "Result from Trigger" to the console.
@======================================================================
    .global device3_trig_result
    .thumb_func
device3_trig_result:
    MOV_imm32 r0, device3_trig_resultmsg
 8001228:	f240 30a4 	movw	r0, #932	@ 0x3a4
 800122c:	f2c2 0000 	movt	r0, #8192	@ 0x2000
    MOV_imm32 r1, consoleMsgs
 8001230:	f640 416c 	movw	r1, #3180	@ 0xc6c
 8001234:	f2c2 0100 	movt	r1, #8192	@ 0x2000
    bl      MoT_msgPost
 8001238:	f001 fa53 	bl	80026e2 <MoT_msgPost>
    pop {r7, pc}
 800123c:	bd80      	pop	{r7, pc}

0800123e <device3_stop_monitor>:
@ stopping would have been reported by 'monitor_task' itself.
@======================================================================
.global device3_stop_monitor
.thumb_func
device3_stop_monitor:
    MOV_imm32 r0, device3_skiptask
 800123e:	f241 3099 	movw	r0, #5017	@ 0x1399
 8001242:	f6c0 0000 	movt	r0, #2048	@ 0x800
    mov r1, #NULL
 8001246:	f04f 0100 	mov.w	r1, #0
    bl MoT_taskUpdate
 800124a:	f001 fa30 	bl	80026ae <MoT_taskUpdate>
    mov r0, #0
 800124e:	f04f 0000 	mov.w	r0, #0
    MOV_imm32 r0, device3_stop_monitor_return_resutlsmsg
 8001252:	f240 307c 	movw	r0, #892	@ 0x37c
 8001256:	f2c2 0000 	movt	r0, #8192	@ 0x2000
    MOV_imm32 r1, consoleMsgs
 800125a:	f640 416c 	movw	r1, #3180	@ 0xc6c
 800125e:	f2c2 0100 	movt	r1, #8192	@ 0x2000
    bl    MoT_msgPost
 8001262:	f001 fa3e 	bl	80026e2 <MoT_msgPost>
    mov r0, #0
 8001266:	f04f 0000 	mov.w	r0, #0
    pop {r7, pc}
 800126a:	bd80      	pop	{r7, pc}

0800126c <device3_set_low>:
@ Posts "Input is LOW" to the console as confirmation
@======================================================================
	.global device3_set_low
	.thumb_func
device3_set_low:
	bl PA8_output_init
 800126c:	f7ff ff3b 	bl	80010e6 <PA8_output_init>
    bl PA8_to_low
 8001270:	f7ff ff30 	bl	80010d4 <PA8_to_low>
	MOV_imm32 r0, device3_output_lowmsg
 8001274:	f240 20ac 	movw	r0, #684	@ 0x2ac
 8001278:	f2c2 0000 	movt	r0, #8192	@ 0x2000
    MOV_imm32 r1, consoleMsgs
 800127c:	f640 416c 	movw	r1, #3180	@ 0xc6c
 8001280:	f2c2 0100 	movt	r1, #8192	@ 0x2000
    bl MoT_msgPost
 8001284:	f001 fa2d 	bl	80026e2 <MoT_msgPost>
    pop {r7, pc}
 8001288:	bd80      	pop	{r7, pc}

0800128a <device3_set_high>:
@ Posts "Input is HIGH" to the console as confirmation
@======================================================================
	.global device3_set_high
	.thumb_func
device3_set_high:
	bl PA8_output_init
 800128a:	f7ff ff2c 	bl	80010e6 <PA8_output_init>
    bl PA8_to_high
 800128e:	f7ff ff18 	bl	80010c2 <PA8_to_high>
	MOV_imm32 r0, device3_output_highmsg
 8001292:	f240 20cc 	movw	r0, #716	@ 0x2cc
 8001296:	f2c2 0000 	movt	r0, #8192	@ 0x2000
    MOV_imm32 r1, consoleMsgs
 800129a:	f640 416c 	movw	r1, #3180	@ 0xc6c
 800129e:	f2c2 0100 	movt	r1, #8192	@ 0x2000
    bl MoT_msgPost
 80012a2:	f001 fa1e 	bl	80026e2 <MoT_msgPost>
    pop {r7, pc}
 80012a6:	bd80      	pop	{r7, pc}

080012a8 <device3_scheduled_output>:
@ r0: Pointer to command payload containing 16-bit delay then 16-bit state.
@======================================================================
	.global device3_scheduled_output
	.thumb_func
device3_scheduled_output:
	bl PA8_output_init
 80012a8:	f7ff ff1d 	bl	80010e6 <PA8_output_init>
	mov r5, r0
 80012ac:	4605      	mov	r5, r0
	MOV_imm32 r0, device3_schedule_onmsg
 80012ae:	f240 30fc 	movw	r0, #1020	@ 0x3fc
 80012b2:	f2c2 0000 	movt	r0, #8192	@ 0x2000
    MOV_imm32 r1, consoleMsgs
 80012b6:	f640 416c 	movw	r1, #3180	@ 0xc6c
 80012ba:	f2c2 0100 	movt	r1, #8192	@ 0x2000
    bl MoT_msgPost
 80012be:	f001 fa10 	bl	80026e2 <MoT_msgPost>
    mov r0, r5
 80012c2:	4628      	mov	r0, r5
	bl arg_retrieve_half
 80012c4:	f000 fe58 	bl	8001f78 <arg_retrieve_half>
	mov r5, r0
 80012c8:	4605      	mov	r5, r0
	mov r0, r1
 80012ca:	4608      	mov	r0, r1
    bl delay
 80012cc:	f000 fe61 	bl	8001f92 <delay>
    mov r0, r5
 80012d0:	4628      	mov	r0, r5
	ldrh r1, [r0], #2
 80012d2:	f830 1b02 	ldrh.w	r1, [r0], #2
	cbz r1, off
 80012d6:	b111      	cbz	r1, 80012de <off>

080012d8 <on>:
on:
    bl PA8_to_high
 80012d8:	f7ff fef3 	bl	80010c2 <PA8_to_high>
	pop {r7, pc}
 80012dc:	bd80      	pop	{r7, pc}

080012de <off>:
off:
	bl PA8_to_low
 80012de:	f7ff fef9 	bl	80010d4 <PA8_to_low>
    pop {r7, pc}
 80012e2:	bd80      	pop	{r7, pc}

080012e4 <device3_repetitive>:
@ r0: Pointer to command payload.
@======================================================================
	.global device3_repetitive
	.thumb_func
device3_repetitive:
	mov r7, r0
 80012e4:	4607      	mov	r7, r0
	MOV_imm32 r0, device3_repetitive_onmsg
 80012e6:	f240 30cc 	movw	r0, #972	@ 0x3cc
 80012ea:	f2c2 0000 	movt	r0, #8192	@ 0x2000
    MOV_imm32 r1, consoleMsgs
 80012ee:	f640 416c 	movw	r1, #3180	@ 0xc6c
 80012f2:	f2c2 0100 	movt	r1, #8192	@ 0x2000
    bl MoT_msgPost
 80012f6:	f001 f9f4 	bl	80026e2 <MoT_msgPost>
    mov r0, r7
 80012fa:	4638      	mov	r0, r7
	bl PA8_output_init
 80012fc:	f7ff fef3 	bl	80010e6 <PA8_output_init>
	mov r7, r6
 8001300:	4637      	mov	r7, r6
    bl arg_retrieve_half
 8001302:	f000 fe39 	bl	8001f78 <arg_retrieve_half>
    mov r6, r1
 8001306:	460e      	mov	r6, r1
	bl arg_retrieve_half
 8001308:	f000 fe36 	bl	8001f78 <arg_retrieve_half>
	str r1, [rDEVP, #device3_T_OFF]
 800130c:	f8c5 1020 	str.w	r1, [r5, #32]
	bl arg_retrieve_half
 8001310:	f000 fe32 	bl	8001f78 <arg_retrieve_half>
	str r1, [rDEVP, #device3_T_ON]
 8001314:	f8c5 1024 	str.w	r1, [r5, #36]	@ 0x24

08001318 <loop>:
loop:
	ldrh r1, [rDEVP, device3_T_OFF]
 8001318:	f8b5 1020 	ldrh.w	r1, [r5, #32]
	mov r7, r0
 800131c:	4607      	mov	r7, r0
    mov r0, r1
 800131e:	4608      	mov	r0, r1
    bl delay
 8001320:	f000 fe37 	bl	8001f92 <delay>
    bl PA8_to_high
 8001324:	f7ff fecd 	bl	80010c2 <PA8_to_high>
    mov r0, r7
 8001328:	4638      	mov	r0, r7
	ldrh r1, [rDEVP, device3_T_ON]
 800132a:	f8b5 1024 	ldrh.w	r1, [r5, #36]	@ 0x24
	mov r7, r0
 800132e:	4607      	mov	r7, r0
    mov r0, r1
 8001330:	4608      	mov	r0, r1
    bl delay
 8001332:	f000 fe2e 	bl	8001f92 <delay>
    bl PA8_to_low
 8001336:	f7ff fecd 	bl	80010d4 <PA8_to_low>
    mov r0, r7
 800133a:	4638      	mov	r0, r7
	sub r6, r6, #1
 800133c:	f1a6 0601 	sub.w	r6, r6, #1
	cmp r6, #0
 8001340:	2e00      	cmp	r6, #0
	bne loop
 8001342:	d1e9      	bne.n	8001318 <loop>
	pop {r7, pc}
 8001344:	bd80      	pop	{r7, pc}

08001346 <monitor_task>:
@ task for Device 3.
@======================================================================
	.global monitor_task
    .thumb_func
monitor_task:
	mov r0, #100
 8001346:	f04f 0064 	mov.w	r0, #100	@ 0x64
	bl delay
 800134a:	f000 fe22 	bl	8001f92 <delay>
    bl  PA8_input_init
 800134e:	f7ff fe63 	bl	8001018 <PA8_input_init>
    bl  PA8_read
 8001352:	f7ff fe77 	bl	8001044 <PA8_read>
    mov r2, r0
 8001356:	4602      	mov	r2, r0
    ldr r1, [rDEVP, #device3_PREVIOUS]
 8001358:	f8d5 1028 	ldr.w	r1, [r5, #40]	@ 0x28
    str r2, [rDEVP, #device3_PREVIOUS]
 800135c:	f8c5 2028 	str.w	r2, [r5, #40]	@ 0x28
    cmp r1, r2
 8001360:	4291      	cmp	r1, r2
    beq no_change
 8001362:	d008      	beq.n	8001376 <no_change>
    ldr r0, =device3_change_detectedmsg
 8001364:	480f      	ldr	r0, [pc, #60]	@ (80013a4 <device3_skiptask+0xc>)
    ldr r1, =consoleMsgs
 8001366:	4910      	ldr	r1, [pc, #64]	@ (80013a8 <device3_skiptask+0x10>)
    bl  MoT_msgPost
 8001368:	f001 f9bb 	bl	80026e2 <MoT_msgPost>
    ldr r0, [rDEVP, #device3_PREVIOUS]
 800136c:	f8d5 0028 	ldr.w	r0, [r5, #40]	@ 0x28
    cmp r0, #0
 8001370:	2800      	cmp	r0, #0
    bne high_n_skip
 8001372:	d103      	bne.n	800137c <high_n_skip>
    b low_n_skip
 8001374:	e009      	b.n	800138a <low_n_skip>

08001376 <no_change>:
no_change:
    ldr rDEVP, [rDEVP, #NEXTTASK]
 8001376:	68ad      	ldr	r5, [r5, #8]
    ldr pc, [rDEVP, #XEQTASK]
 8001378:	f8d5 f004 	ldr.w	pc, [r5, #4]

0800137c <high_n_skip>:
high_n_skip:
    ldr r0, =device3_input_highmsg
 800137c:	480b      	ldr	r0, [pc, #44]	@ (80013ac <device3_skiptask+0x14>)
    ldr r1, =consoleMsgs
 800137e:	490a      	ldr	r1, [pc, #40]	@ (80013a8 <device3_skiptask+0x10>)
    bl  MoT_msgPost
 8001380:	f001 f9af 	bl	80026e2 <MoT_msgPost>
    ldr rDEVP, [rDEVP, #NEXTTASK]
 8001384:	68ad      	ldr	r5, [r5, #8]
    ldr pc, [rDEVP, #XEQTASK]
 8001386:	f8d5 f004 	ldr.w	pc, [r5, #4]

0800138a <low_n_skip>:
low_n_skip:
    ldr r0, =device3_input_lowmsg
 800138a:	4809      	ldr	r0, [pc, #36]	@ (80013b0 <device3_skiptask+0x18>)
    ldr r1, =consoleMsgs
 800138c:	4906      	ldr	r1, [pc, #24]	@ (80013a8 <device3_skiptask+0x10>)
    bl  MoT_msgPost
 800138e:	f001 f9a8 	bl	80026e2 <MoT_msgPost>
    ldr rDEVP, [rDEVP, #NEXTTASK]
 8001392:	68ad      	ldr	r5, [r5, #8]
    ldr pc, [rDEVP, #XEQTASK]
 8001394:	f8d5 f004 	ldr.w	pc, [r5, #4]

08001398 <device3_skiptask>:
@ This is used, for example, to stop the 'monitor_task'.
@======================================================================
.global device3_skiptask
.thumb_func
device3_skiptask:
    ldr rDEVP, [rDEVP, #NEXTTASK]
 8001398:	68ad      	ldr	r5, [r5, #8]
    ldr pc, [rDEVP, #XEQTASK]
 800139a:	f8d5 f004 	ldr.w	pc, [r5, #4]
 800139e:	0000      	.short	0x0000
  	ldr r0, =trigger_state
 80013a0:	2000156c 	.word	0x2000156c
    ldr r0, =device3_change_detectedmsg
 80013a4:	2000035c 	.word	0x2000035c
    ldr r1, =consoleMsgs
 80013a8:	20000c6c 	.word	0x20000c6c
    ldr r0, =device3_input_highmsg
 80013ac:	2000028c 	.word	0x2000028c
    ldr r0, =device3_input_lowmsg
 80013b0:	2000026c 	.word	0x2000026c

080013b4 <blueBUTTON_cmdHandler>:
	@; The command dispatcher in device0 branches here from a devicelist entry after receiving a valid command string 
	@; This function is dispatched using the 1st byte in the command buffer.  
	@; The first byte in a MoT command is the index into the devicelist[] which selected this device to be dispatched 
	@; The value of the second byte in the MoT command buffer selects the command in userLED_cmds[] jump table below 
	@; subsequent bytes in the command buffer may be arguments of any type depending on the device specification. 
	push {r7,lr}		@;this 'push' is balanced with a 'pop' at exit of each of the routines of the dispatch table below
 80013b4:	b580      	push	{r7, lr}
	ldrb r1,[r0],#1		@;read function code from the command buffer and advance r0 to point to the command's argument list (if any) 
 80013b6:	f810 1b01 	ldrb.w	r1, [r0], #1
	and r1,0x03			@;limit range of function codes to 0-3 for safety (error-checking would be nice but isnt done here)	
 80013ba:	f001 0103 	and.w	r1, r1, #3
	tbb [pc,r1]
 80013be:	e8df f001 	tbb	[pc, r1]

080013c2 <fns_blueBUTTON>:
 80013c2:	3c23      	.short	0x3c23
 80013c4:	5247      	.short	0x5247

080013c6 <bBINITIALIZED_msgtxt>:
 80013c6:	6c62      	.short	0x6c62
 80013c8:	55426575 	.word	0x55426575
 80013cc:	4e4f5454 	.word	0x4e4f5454
 80013d0:	20736920 	.word	0x20736920
 80013d4:	74696e69 	.word	0x74696e69
 80013d8:	696c6169 	.word	0x696c6169
 80013dc:	0a64657a 	.word	0x0a64657a
 80013e0:	000d      	.short	0x000d

080013e2 <bBMONITORED_msgtxt>:
 80013e2:	6c62      	.short	0x6c62
 80013e4:	55426575 	.word	0x55426575
 80013e8:	4e4f5454 	.word	0x4e4f5454
 80013ec:	20736920 	.word	0x20736920
 80013f0:	696e6f6d 	.word	0x696e6f6d
 80013f4:	65726f74 	.word	0x65726f74
 80013f8:	000d0a64 	.word	0x000d0a64

080013fc <bBuserLEDon_cmdbin>:
 80013fc:	0101      	.short	0x0101

080013fe <bBuserLEDoff_cmdbin>:
 80013fe:	0201      	.short	0x0201

08001400 <bBuserLEDoff_cmd1bin>:
 8001400:	0201      	.short	0x0201

08001402 <bBuserLEDon_cmd2bin>:
 8001402:	0101      	.short	0x0101

08001404 <bBuserLEDoff_cmd3bin>:
 8001404:	0201      	.short	0x0201

08001406 <init_blueBUTTON>:
	@; --- blueBUTTON device commands
	@; functions below are those being dispatched by blueBUTTON_cmdHandler() defined above
	.global init_blueBUTTON
	.thumb_func
init_blueBUTTON:	//wrapper provided for use of initPC13() MoT command without cmd_blueBUTTON dispatcher
	push {r7,lr}	@;this 'push' balances the 'pop' at exit of the MoT command below
 8001406:	b580      	push	{r7, lr}

08001408 <initPC13>:
	.thumb_func
initPC13: @;configure bit 13 of GPIOC as input
	@; set port enable bit (manual pg 492)
	ldr r3,=RCC_BASE			@;load RCC struct address
 8001408:	4b3b      	ldr	r3, [pc, #236]	@ (80014f8 <blueBUTTON_wait_for_release+0x36>)
	ldr r2,[r3,#RCC_AHB2ENR]	@;get current values of device enables
 800140a:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
	orr r2,#(1<<GPIOxEN)		@;enable port
 800140c:	f042 0204 	orr.w	r2, r2, #4
	str r2,[r3,#RCC_AHB2ENR]	@; ..
 8001410:	64da      	str	r2, [r3, #76]	@ 0x4c
	
	@; configure as an input (manual pg 578)
	ldr r3,=GPIOx_BASE			@;load GPIOx struct address
 8001412:	4b3a      	ldr	r3, [pc, #232]	@ (80014fc <blueBUTTON_wait_for_release+0x3a>)
	ldr r2,[r3,#MODER]			@;get current mode values of port
 8001414:	681a      	ldr	r2, [r3, #0]
	bic r2,#(3<<(2*BITn))		@;clear current mode value of port bit
 8001416:	f022 6240 	bic.w	r2, r2, #201326592	@ 0xc000000
	orr	r2,#(0<<(2*BITn))		@;set new mode value of port bit to input
 800141a:	f042 0200 	orr.w	r2, r2, #0
	str r2,[r3,#MODER]			@; ..
 800141e:	601a      	str	r2, [r3, #0]
	
	@; configure with no pullup, pulldown
	ldr r2,[r3,#OPUPDR]			@;get current pu/pd settings of port
 8001420:	68da      	ldr	r2, [r3, #12]
	bic r2,#(3<<(2*BITn))		@;clear current pupd value of port bit (=no pu/pd)
 8001422:	f022 6240 	bic.w	r2, r2, #201326592	@ 0xc000000
	str r2,[r3,#OPUPDR]			@; ..
 8001426:	60da      	str	r2, [r3, #12]
	
	@; post message about change	
	add r0,rDEVP,#bBINITIALIZED_msg			@; r0= address of message descriptor
 8001428:	f105 0020 	add.w	r0, r5, #32
	MOV_imm32 r1,consoleMsgs					@; consoleMsgs is defined in MoTdevice_device0
 800142c:	f640 416c 	movw	r1, #3180	@ 0xc6c
 8001430:	f2c2 0100 	movt	r1, #8192	@ 0x2000
	bl MoT_msgPost							@; and post it. MoT_msgPost must only be called from device command or task so rDEVP is implicit
 8001434:	f001 f955 	bl	80026e2 <MoT_msgPost>
	pop {r7,pc}								@;  to balance command dispatch
 8001438:	bd80      	pop	{r7, pc}

0800143a <bBuserLED_on>:

	.global bBuserLED_on @;unnecessary extra calls to  MoT_cmdPost(MoT_cmdLink_t *, MoTlistAnchor_t *) to test internal-command queuing 
	.thumb_func
 bBuserLED_on:
	MOV_imm32 r0,bBuserLEDon_cmd			@;defined above
 800143a:	f240 406c 	movw	r0, #1132	@ 0x46c
 800143e:	f2c2 0000 	movt	r0, #8192	@ 0x2000
	MOV_imm32 r1,internalCmds				@; in MoTdevice_device0.S (in libMoTsystem.a)
 8001442:	f241 41b0 	movw	r1, #5296	@ 0x14b0
 8001446:	f2c2 0100 	movt	r1, #8192	@ 0x2000
	bl MoT_cmdPost							@; in MoTservices_v5_04.S (in libMoTsystem.a)
 800144a:	f001 f94a 	bl	80026e2 <MoT_msgPost>
	MOV_imm32 r0,bBuserLEDon_cmd2			@; ..
	MOV_imm32 r1,internalCmds				@; ..
	bl MoT_cmdPost							@; ..
.endif
	@; return value is don't care for test
	pop {r7,pc}								@; to balance command dispatch 
 800144e:	bd80      	pop	{r7, pc}

08001450 <bBuserLED_off>:

	.global bBuserLED_off @;many unnecessary extra calls to  MoT_cmdPost(MoT_cmdLink_t *, MoTlistAnchor_t *) to test internal-command queuing 
	.thumb_func
 bBuserLED_off:
	MOV_imm32 r0,bBuserLEDoff_cmd			@;defined above
 8001450:	f240 407c 	movw	r0, #1148	@ 0x47c
 8001454:	f2c2 0000 	movt	r0, #8192	@ 0x2000
	MOV_imm32 r1,internalCmds				@; in MoTdevice_device0.S
 8001458:	f241 41b0 	movw	r1, #5296	@ 0x14b0
 800145c:	f2c2 0100 	movt	r1, #8192	@ 0x2000
	bl MoT_cmdPost							@; in MoTservices_xx.S
 8001460:	f001 f93f 	bl	80026e2 <MoT_msgPost>
	MOV_imm32 r0,bBuserLEDoff_cmd3			@; .
	MOV_imm32 r1,internalCmds				@; ..
	bl MoT_cmdPost							@; ..
.endif
	@; return value is don't care for test
	pop {r7,pc}								@; to balance command dispatch 
 8001464:	bd80      	pop	{r7, pc}

08001466 <blueBUTTON_monitor>:

	.global blueBUTTON_monitor
	.thumb_func
blueBUTTON_monitor:  	@; install button monitoring task
	MOV_imm32 r0,blueBUTTON_wait_for_press 	@;change blueBUTTON task to 'wait for press'  
 8001466:	f241 408f 	movw	r0, #5263	@ 0x148f
 800146a:	f6c0 0000 	movt	r0, #2048	@ 0x800
	mov r1,#NULL							@; ..
 800146e:	f04f 0100 	mov.w	r1, #0
	bl MoT_taskUpdate						@; .. 
 8001472:	f001 f91c 	bl	80026ae <MoT_taskUpdate>
	@; post message about change	
	add r0,rDEVP,#bBMONITORED_msg			@; r0= address of message descriptor
 8001476:	f105 0030 	add.w	r0, r5, #48	@ 0x30
	MOV_imm32 r1,consoleMsgs					@; consoleMsgs is defined in MoTdevice_device0
 800147a:	f640 416c 	movw	r1, #3180	@ 0xc6c
 800147e:	f2c2 0100 	movt	r1, #8192	@ 0x2000
	bl MoT_msgPost							@; and post it. MoT_msgPost must only be called from device command or task so rDEVP is implicit
 8001482:	f001 f92e 	bl	80026e2 <MoT_msgPost>
	pop {r7,pc}								@;  to balance command dispatch
 8001486:	bd80      	pop	{r7, pc}

08001488 <blueBUTTON_skiptask>:
	@; --- blueBUTTON tasks

	.global blueBUTTON_skiptask 			@;default blueBUTTON initial task. global for debug
	.thumb_func
blueBUTTON_skiptask:		
	ldr rDEVP,[rDEVP,#NEXTTASK]				@;proceed to next device/task on list 
 8001488:	68ad      	ldr	r5, [r5, #8]
	ldr pc,[rDEVP,#XEQTASK]					@;  ..
 800148a:	f8d5 f004 	ldr.w	pc, [r5, #4]

0800148e <blueBUTTON_wait_for_press>:

	.global blueBUTTON_wait_for_press
	.thumb_func
 blueBUTTON_wait_for_press:
	ldr r3,=GPIOx_BASE						@;load button GPIO struct address
 800148e:	4b1b      	ldr	r3, [pc, #108]	@ (80014fc <blueBUTTON_wait_for_release+0x3a>)
	ldr r0,[r3,#IDR]						@;get current button value
 8001490:	6918      	ldr	r0, [r3, #16]
	ands r0,r0,#(1<<(1*BITn))				@;mask it
 8001492:	f410 5000 	ands.w	r0, r0, #8192	@ 0x2000
	bne 1f									@;if button is not pressed
 8001496:	d111      	bne.n	80014bc <blueBUTTON_wait_for_press+0x2e>
	@; here if button is pressed
	MOV_imm32 r0,bBuserLEDon_cmd			@;send command to turn LED on
 8001498:	f240 406c 	movw	r0, #1132	@ 0x46c
 800149c:	f2c2 0000 	movt	r0, #8192	@ 0x2000
	MOV_imm32 r1,internalCmds				@; ..
 80014a0:	f241 41b0 	movw	r1, #5296	@ 0x14b0
 80014a4:	f2c2 0100 	movt	r1, #8192	@ 0x2000
	bl MoT_cmdPost							@; ..
 80014a8:	f001 f91b 	bl	80026e2 <MoT_msgPost>
	MOV_imm32 r0,blueBUTTON_wait_for_release@;change blueBUTTON task to 'wait for release'  
 80014ac:	f241 40c3 	movw	r0, #5315	@ 0x14c3
 80014b0:	f6c0 0000 	movt	r0, #2048	@ 0x800
	mov r1,#NULL							@; ..
 80014b4:	f04f 0100 	mov.w	r1, #0
	bl MoT_taskUpdate						@; .. 
 80014b8:	f001 f8f9 	bl	80026ae <MoT_taskUpdate>
1:	ldr rDEVP,[rDEVP,#NEXTTASK]				@; proceed to next device/task on list
 80014bc:	68ad      	ldr	r5, [r5, #8]
	ldr pc,[rDEVP,#XEQTASK]					@; ..
 80014be:	f8d5 f004 	ldr.w	pc, [r5, #4]

080014c2 <blueBUTTON_wait_for_release>:

	
	.global blueBUTTON_wait_for_release
	.thumb_func
 blueBUTTON_wait_for_release:
	ldr r3,=GPIOx_BASE						@;load button GPIO struct address
 80014c2:	4b0e      	ldr	r3, [pc, #56]	@ (80014fc <blueBUTTON_wait_for_release+0x3a>)
	ldr r0,[r3,#IDR]						@;get current button value
 80014c4:	6918      	ldr	r0, [r3, #16]
	ands r0,r0,#(1<<(1*BITn))				@;mask it
 80014c6:	f410 5000 	ands.w	r0, r0, #8192	@ 0x2000
	beq 1f									@;if button is pressed
 80014ca:	d011      	beq.n	80014f0 <blueBUTTON_wait_for_release+0x2e>
	@; here if button was released
	MOV_imm32 r0,bBuserLEDoff_cmd			@;send command to turn LED off
 80014cc:	f240 407c 	movw	r0, #1148	@ 0x47c
 80014d0:	f2c2 0000 	movt	r0, #8192	@ 0x2000
	MOV_imm32 r1,internalCmds				@; ..
 80014d4:	f241 41b0 	movw	r1, #5296	@ 0x14b0
 80014d8:	f2c2 0100 	movt	r1, #8192	@ 0x2000
	bl MoT_cmdPost							@; ..
 80014dc:	f001 f901 	bl	80026e2 <MoT_msgPost>
	MOV_imm32 r0,blueBUTTON_wait_for_press 	@;change blueBUTTON task to 'wait for press'  
 80014e0:	f241 408f 	movw	r0, #5263	@ 0x148f
 80014e4:	f6c0 0000 	movt	r0, #2048	@ 0x800
	mov r1,#NULL							@; ..
 80014e8:	f04f 0100 	mov.w	r1, #0
	bl MoT_taskUpdate						@; .. 
 80014ec:	f001 f8df 	bl	80026ae <MoT_taskUpdate>
1:	ldr rDEVP,[rDEVP,#NEXTTASK]				@; proceed to next device/task on list
 80014f0:	68ad      	ldr	r5, [r5, #8]
	ldr pc,[rDEVP,#XEQTASK]					@; ..
 80014f2:	f8d5 f004 	ldr.w	pc, [r5, #4]
 80014f6:	0000      	.short	0x0000
	ldr r3,=RCC_BASE			@;load RCC struct address
 80014f8:	40021000 	.word	0x40021000
	ldr r3,=GPIOx_BASE			@;load GPIOx struct address
 80014fc:	48000800 	.word	0x48000800

08001500 <userLED_cmdHandler>:
	@; The command dispatcher branches here from the devicelist entry after receiving a valid command string 
	@; The first byte of a MoT command was the index into the devicelist which dispatched this cmdHandler (see main())  
	@; The second byte in the MoT command selects and wxecutes a command in userLED_cmds[] jump table below 
	@; subsequent bytes in the command may be arguments of any type depending on the device specification. 
	@; See userLED_cmds (below) for the actions of various command userLED command codes.
	push {r7,lr}		@; 'push' balanced with a matching 'pop' at exit of the routines in the dispatch table below
 8001500:	b580      	push	{r7, lr}
	ldrb r1,[r0],#1		@; read command from the command buffer and advance r0 to point to the argument list (if any) 
 8001502:	f810 1b01 	ldrb.w	r1, [r0], #1
	and r1,0x07			@; limit range of command codes to 0-7 for safety 	
 8001506:	f001 0107 	and.w	r1, r1, #7
	tbb [pc,r1]
 800150a:	e8df f001 	tbb	[pc, r1]

0800150e <userLED_cmds>:
 800150e:	483d      	.short	0x483d
 8001510:	91785e53 	.word	0x91785e53
 8001514:	9c9c      	.short	0x9c9c

08001516 <INITIALIZED_msgtxt>:
 8001516:	7375      	.short	0x7375
 8001518:	454c7265 	.word	0x454c7265
 800151c:	73692044 	.word	0x73692044
 8001520:	696e6920 	.word	0x696e6920
 8001524:	6c616974 	.word	0x6c616974
 8001528:	64657a69 	.word	0x64657a69
 800152c:	0d0a      	.short	0x0d0a
	...

0800152f <ON_msgtxt>:
 800152f:	75          	.byte	0x75
 8001530:	4c726573 	.word	0x4c726573
 8001534:	69204445 	.word	0x69204445
 8001538:	4f272073 	.word	0x4f272073
 800153c:	0d0a274e 	.word	0x0d0a274e
	...

08001541 <OFF_msgtxt>:
 8001541:	75          	.byte	0x75
 8001542:	6573      	.short	0x6573
 8001544:	44454c72 	.word	0x44454c72
 8001548:	20736920 	.word	0x20736920
 800154c:	46464f27 	.word	0x46464f27
 8001550:	000d0a27 	.word	0x000d0a27

08001554 <BLINKING_msgtxt>:
 8001554:	72657375 	.word	0x72657375
 8001558:	2044454c 	.word	0x2044454c
 800155c:	42207369 	.word	0x42207369
 8001560:	4b4e494c 	.word	0x4b4e494c
 8001564:	0a474e49 	.word	0x0a474e49
 8001568:	000d      	.short	0x000d

0800156a <DEFAULT_MSGTXT>:
 800156a:	6874      	.short	0x6874
 800156c:	69207369 	.word	0x69207369
 8001570:	68742073 	.word	0x68742073
 8001574:	65642065 	.word	0x65642065
 8001578:	6c756166 	.word	0x6c756166
 800157c:	656d2074 	.word	0x656d2074
 8001580:	67617373 	.word	0x67617373
 8001584:	000d0a65 	.word	0x000d0a65

08001588 <userLED_INITcmd>:
@; IMPORTANT: userLED_cmdHandler() saves its entering context with 'push {r7,lr}', so commands below must exit with 'pop {r7,pc}'

	.thumb_func
userLED_INITcmd: 
//	push {r7,lr}								@; done above at command entry, so dont do here!
	bl userLED_init								@; in \LL_device_support\userLED.S
 8001588:	f000 f892 	bl	80016b0 <initGPIOA5>
	@; post the 'initialized' message
	add r0,rDEVP,#INITIALIZED_msg				@; r0= address of the 'initialized' message
 800158c:	f105 002c 	add.w	r0, r5, #44	@ 0x2c
	MOV_imm32 r1,consoleMsgs						@; consoleMsgs is defined in MoTdevice_device0
 8001590:	f640 416c 	movw	r1, #3180	@ 0xc6c
 8001594:	f2c2 0100 	movt	r1, #8192	@ 0x2000
	bl MoT_msgPost								@; msgPost is only called by commands or tasks (rDEVP is needed)
 8001598:	f001 f8a3 	bl	80026e2 <MoT_msgPost>
	@; returns here with r0 == 0 : success, r0 == -1 failed to post. return value not used at present
	@; return to command dispatcher
	pop {r7,pc}									@; command is completed
 800159c:	bd80      	pop	{r7, pc}

0800159e <userLED_ONcmd>:

	.thumb_func
userLED_ONcmd: 
//	push {r7,lr}								@; done above at command entry, so dont do here!
	bl userLED_ON								@; in userLED.S
 800159e:	f000 f8b3 	bl	8001708 <setPA5>
	@; post the 'ON' message
	add r0,rDEVP,#ON_msg						@; r0= address of the 'initialized' message
 80015a2:	f105 003c 	add.w	r0, r5, #60	@ 0x3c
	MOV_imm32 r1,consoleMsgs						@; consoleMsgs is defined in MoTdevice_device0
 80015a6:	f640 416c 	movw	r1, #3180	@ 0xc6c
 80015aa:	f2c2 0100 	movt	r1, #8192	@ 0x2000
	bl MoT_msgPost								@; msgPost is only called by commands or tasks (rDEVP is needed)
 80015ae:	f001 f898 	bl	80026e2 <MoT_msgPost>
	@; returns here with r0 == 0 : success, r0 == -1 failed to post. return value not used at present
	@; return to command dispatcher
	pop {r7,pc}									@; command is completed
 80015b2:	bd80      	pop	{r7, pc}

080015b4 <userLED_OFFcmd>:

	.thumb_func
userLED_OFFcmd: 
//	push {r7,lr}								@; done above at command entry, so dont do here!
	bl userLED_OFF								@; in userLED.S
 80015b4:	f000 f8af 	bl	8001716 <resetPA5>
	@; post the 'OFF' message
	add r0,rDEVP,#OFF_msg						@; r0= address of the 'initialized' message
 80015b8:	f105 004c 	add.w	r0, r5, #76	@ 0x4c
	MOV_imm32 r1,consoleMsgs						@; consoleMsgs is defined in MoTdevice_device0
 80015bc:	f640 416c 	movw	r1, #3180	@ 0xc6c
 80015c0:	f2c2 0100 	movt	r1, #8192	@ 0x2000
	bl MoT_msgPost								@; msgPost is only called by commands or tasks (rDEVP is needed)
 80015c4:	f001 f88d 	bl	80026e2 <MoT_msgPost>
	@; returns here with r0 == 0 : success, r0 == -1 failed to post. return value not used at present
	@; return to command dispatcher
	pop {r7,pc}									@; command is completed									
 80015c8:	bd80      	pop	{r7, pc}

080015ca <userLED_BLINKinstall>:
	.global userLED_BLINKinstall				@;made global for debug
	.thumb_func	
userLED_BLINKinstall: @;function sets blink rate and installs userLED_ONtask
	@;here with r0 pointing to 32bit uint32_t in command tail ":0103FFFF0000FE" (ULED_RELOAD=0xFFFF) gives ~1Hz
//	push {r7,lr}								@; done above at command entry, so dont do here
	ldr r1,[r0]									@; get count value from command-tail
 80015ca:	6801      	ldr	r1, [r0, #0]
	str r1,[rDEVP,#ULED_RELOAD]					@; set devices reload and count values
 80015cc:	f8c5 1024 	str.w	r1, [r5, #36]	@ 0x24
	str r1,[rDEVP,#ULED_COUNT]					@;	..
 80015d0:	f8c5 1028 	str.w	r1, [r5, #40]	@ 0x28
	@;set tasks initial execution vectors 
	MOV_imm32 r0,userLED_ONtask
 80015d4:	f241 6053 	movw	r0, #5715	@ 0x1653
 80015d8:	f6c0 0000 	movt	r0, #2048	@ 0x800
	mov r1,#NULL
 80015dc:	f04f 0100 	mov.w	r1, #0
	bl MoT_taskUpdate
 80015e0:	f001 f865 	bl	80026ae <MoT_taskUpdate>
	bl userLED_ON								@; turn the LED on
 80015e4:	f000 f890 	bl	8001708 <setPA5>
	@; post the 'blinking' message
	add r0,rDEVP,#BLINKING_msg					@; r0= address of the 'blinking' message
 80015e8:	f105 005c 	add.w	r0, r5, #92	@ 0x5c
	MOV_imm32 r1,consoleMsgs						@; consoleMsgs is defined in MoTdevice_device0
 80015ec:	f640 416c 	movw	r1, #3180	@ 0xc6c
 80015f0:	f2c2 0100 	movt	r1, #8192	@ 0x2000
	bl MoT_msgPost								@; msgPost is only called by commands or tasks 
 80015f4:	f001 f875 	bl	80026e2 <MoT_msgPost>
	@; returns here with r0 == 0 : success, r0 == -1 failed to post. return value not used at present
	@; return to command dispatcher
	mov r0,#0									@; set 'no follow-on command' marker (obsolete?) 
 80015f8:	f04f 0000 	mov.w	r0, #0
	pop {r7,pc}									@; command is completed							
 80015fc:	bd80      	pop	{r7, pc}

080015fe <userLED_REPORTcmd>:

	.global userLED_REPORTcmd					@; made global for debug
	.thumb_func
userLED_REPORTcmd: @;
//	push {r7,lr}								@; done above at command entry, so dont do here
	bl userLED_status							@; get masked image of LED port bit in r0
 80015fe:	f000 f874 	bl	80016ea <readPA5>
	cbnz r0,1f
 8001602:	b950      	cbnz	r0, 800161a <userLED_REPORTcmd+0x1c>
	@;here if BITn in r0 is '0'
	@; post the 'OFF' message
	add r0,rDEVP,#OFF_msg						@; r0= address of the 'initialized' message
 8001604:	f105 004c 	add.w	r0, r5, #76	@ 0x4c
	MOV_imm32 r1,consoleMsgs						@; consoleMsgs is defined in MoTdevice_device0
 8001608:	f640 416c 	movw	r1, #3180	@ 0xc6c
 800160c:	f2c2 0100 	movt	r1, #8192	@ 0x2000
	bl MoT_msgPost								@; msgPost is only called by commands or tasks 
 8001610:	f001 f867 	bl	80026e2 <MoT_msgPost>
	@; returns here with r0 == 0 : success, r0 == -1 failed to post. return value not used at present
	@; return to command dispatcher
	mov r0,#0									@; set 'no follow-on command' marker (obsolete?) 
 8001614:	f04f 0000 	mov.w	r0, #0
	pop {r7,pc}									@; command is completed
 8001618:	bd80      	pop	{r7, pc}
1:	@;here if BITn in r0 is '1'
	@; post the 'ON' message
	add r0,rDEVP,#ON_msg						@; r0= address of the 'initialized' message
 800161a:	f105 003c 	add.w	r0, r5, #60	@ 0x3c
	MOV_imm32 r1,consoleMsgs						@; consoleMsgs is defined in MoTdevice_device0
 800161e:	f640 416c 	movw	r1, #3180	@ 0xc6c
 8001622:	f2c2 0100 	movt	r1, #8192	@ 0x2000
	bl MoT_msgPost								@; msgPost is only called bu commands or tasks 
 8001626:	f001 f85c 	bl	80026e2 <MoT_msgPost>
	@; returns here with r0 == 0 : success, r0 == -1 failed to post. return value not used at present
	@; return to command dispatcher
	mov r0,#0									@; set 'no follow-on command' marker (obsolete?) 
 800162a:	f04f 0000 	mov.w	r0, #0
	pop {r7,pc}									@; command is completed							
 800162e:	bd80      	pop	{r7, pc}

08001630 <userLED_SKIPinstall>:

	.global userLED_SKIPinstall					@; made global for debug
	.thumb_func
userLED_SKIPinstall:
	MOV_imm32 r0,userLED_skiptask
 8001630:	f241 604d 	movw	r0, #5709	@ 0x164d
 8001634:	f6c0 0000 	movt	r0, #2048	@ 0x800
	mov r1,#NULL
 8001638:	f04f 0100 	mov.w	r1, #0
	bl MoT_taskUpdate
 800163c:	f001 f837 	bl	80026ae <MoT_taskUpdate>
	@;return to cmdHandlers caller
	mov r0,#0									@; set 'no follow-on command' marker (obsolete?) 
 8001640:	f04f 0000 	mov.w	r0, #0
	pop {r7,pc}									@; command is completed							
 8001644:	bd80      	pop	{r7, pc}

08001646 <userLED_NOP>:

	.thumb_func
userLED_NOP:  @; userLED command #6 and  #7 are placeholders for unimplemented commands
	@;return to cmdHandlers caller
//	push {r7,lr}								@; done above at command entry, so dont do here
	mov r0,#0									@; set 'no follow-on command' marker (obsolete?) 
 8001646:	f04f 0000 	mov.w	r0, #0
	pop {r7,pc}									@; command is completed							
 800164a:	bd80      	pop	{r7, pc}

0800164c <userLED_skiptask>:
@; When a device has nothing to do, a 'skiptask' must execute to continue the task sequence of the task-cycle
	.global userLED_skiptask 					@;default userLED initial task. made global for debug
	.thumb_func
userLED_skiptask:								@; the userLED default task
	@; proceed to next device/task on list
	ldr rDEVP,[rDEVP,#NEXTTASK]					@; get new rDEVP
 800164c:	68ad      	ldr	r5, [r5, #8]
	ldr pc,[rDEVP,#XEQTASK]						@; start task of new device
 800164e:	f8d5 f004 	ldr.w	pc, [r5, #4]

08001652 <userLED_ONtask>:

	@; cycle-counting version of a blinking LED task
	.global userLED_ONtask  @; changes to the alternate userLED_OFFtask after every ULED_RELOAD task cycles 
	.thumb_func
userLED_ONtask: @;  arrive here with rDEVP pointing to this device's data
	ldr r1,[rDEVP,#ULED_COUNT]					@; update cycle count
 8001652:	f8d5 1028 	ldr.w	r1, [r5, #40]	@ 0x28
	subs r1,#1									@; ..
 8001656:	3901      	subs	r1, #1
	str r1,[rDEVP,#ULED_COUNT]					@; ..
 8001658:	f8c5 1028 	str.w	r1, [r5, #40]	@ 0x28
	cbnz r1,1f									@; 
 800165c:	b969      	cbnz	r1, 800167a <userLED_ONtask+0x28>
	@; here when countdown is done
	ldr r1,[rDEVP,#ULED_RELOAD]					@; restart cycle countdown
 800165e:	f8d5 1024 	ldr.w	r1, [r5, #36]	@ 0x24
	str r1,[rDEVP,#ULED_COUNT]					@; ..
 8001662:	f8c5 1028 	str.w	r1, [r5, #40]	@ 0x28
	@; void MoT_taskUpdate( void (*Sfn)(), void (*Cfn)() ); //function called by a task to switch to a different task 
	MOV_imm32 r0,userLED_OFFtask				@; MoT_taskUpdate() arguments are the execution address of another task 
 8001666:	f241 6081 	movw	r0, #5761	@ 0x1681
 800166a:	f6c0 0000 	movt	r0, #2048	@ 0x800
	mov r1,#NULL								@;  The other task might be in asm (see line above) or C (not shown). 
 800166e:	f04f 0100 	mov.w	r1, #0
	bl MoT_taskUpdate							@;    MoT_taskUpdate(userLED_OFFtask,NULL) will install the LED 'OFF' task 
 8001672:	f001 f81c 	bl	80026ae <MoT_taskUpdate>
	bl userLED_OFF								@; turn the Green LED off in preparation for next task cycle
 8001676:	f000 f84e 	bl	8001716 <resetPA5>
1:	@; task for this device is done for now -- proceed to next device/task on list
	ldr rDEVP,[rDEVP,#NEXTTASK]					@; get new rDEVP
 800167a:	68ad      	ldr	r5, [r5, #8]
	ldr pc,[rDEVP,#XEQTASK]						@; start task of new device
 800167c:	f8d5 f004 	ldr.w	pc, [r5, #4]

08001680 <userLED_OFFtask>:

	@; alternate cycle-counting version of a blinking LED task
	.global userLED_OFFtask @; task cycle-count version. changes state every ULED_RELOAD task cycles 
	.thumb_func
userLED_OFFtask: @;  arrive here with rDEVP pointing to this device's data
	ldr r1,[rDEVP,#ULED_COUNT]					@; update cycle count
 8001680:	f8d5 1028 	ldr.w	r1, [r5, #40]	@ 0x28
	subs r1,#1									@; ..
 8001684:	3901      	subs	r1, #1
	str r1,[rDEVP,#ULED_COUNT]					@; ..
 8001686:	f8c5 1028 	str.w	r1, [r5, #40]	@ 0x28
	cbnz r1,1f									@; 
 800168a:	b969      	cbnz	r1, 80016a8 <userLED_OFFtask+0x28>
	@; here when countdown is done
	ldr r1,[rDEVP,#ULED_RELOAD]					@; restart cycle countdown
 800168c:	f8d5 1024 	ldr.w	r1, [r5, #36]	@ 0x24
	str r1,[rDEVP,#ULED_COUNT]					@; ..
 8001690:	f8c5 1028 	str.w	r1, [r5, #40]	@ 0x28
	MOV_imm32 r0,userLED_ONtask					@; setup for MoT_taskUpdate( void (*Sfn)(), void (*Cfn)() ) call. (see above)
 8001694:	f241 6053 	movw	r0, #5715	@ 0x1653
 8001698:	f6c0 0000 	movt	r0, #2048	@ 0x800
	mov r1,#NULL								@; ..
 800169c:	f04f 0100 	mov.w	r1, #0
	bl MoT_taskUpdate							@; ..
 80016a0:	f001 f805 	bl	80026ae <MoT_taskUpdate>
	bl userLED_ON								@; turn the Green LED on in preparation for next task cycle
 80016a4:	f000 f830 	bl	8001708 <setPA5>
1:	@; task for this device is done for now -- proceed to next device/task on list
	ldr rDEVP,[rDEVP,#NEXTTASK]					@; get new rDEVP
 80016a8:	68ad      	ldr	r5, [r5, #8]
	ldr pc,[rDEVP,#XEQTASK]						@; start task of new device
 80016aa:	f8d5 f004 	ldr.w	pc, [r5, #4]
	...

080016b0 <initGPIOA5>:
	.global userLED_init		@; alias function name so code elsewhere can be left as when hardware changes
	.thumb_func					@; make sure bit 0 is set in any absolute indirect references to this function
initGPIOA5: @;configure port bit PA5 as GPIO output with high-speed push/pull drivers and no pu/pd. 
	.thumb_func
userLED_init: 					@; see 'alias' remard above
	push {r7,lr}
 80016b0:	b580      	push	{r7, lr}

	@; set port clock enable bit in RCC_AHB2ENR (pg 252 of the manual)
	ldr r3,=RCC_BASE			@;load RCC struct address
 80016b2:	4b1c      	ldr	r3, [pc, #112]	@ (8001724 <resetPA5+0xe>)
	ldr r2,[r3,#RCC_AHB2ENR]	@;get current values of device enables
 80016b4:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
	orr r2,#(1<<GPIOAEN)		@;enable port
 80016b6:	f042 0201 	orr.w	r2, r2, #1
	str r2,[r3,#RCC_AHB2ENR]	@; ..
 80016ba:	64da      	str	r2, [r3, #76]	@ 0x4c
	
	@; configure PA5 as an output (pg 304 of the manual)
	ldr r3,=GPIOA_BASE			@;load GPIOA struct address
 80016bc:	f04f 4390 	mov.w	r3, #1207959552	@ 0x48000000
	ldr r2,[r3,#MODER]			@;get current mode values of port
 80016c0:	681a      	ldr	r2, [r3, #0]
	bic r2,#(3<<(2*PA5))		@;clear current mode value of port bit
 80016c2:	f422 6240 	bic.w	r2, r2, #3072	@ 0xc00
	orr	r2,#(1<<(2*PA5))		@;set new mode value of port bit to general purpose output
 80016c6:	f442 6280 	orr.w	r2, r2, #1024	@ 0x400
	str r2,[r3,#MODER]			@; ..
 80016ca:	601a      	str	r2, [r3, #0]
	
	@; configure output as push/pull (pg 304 of the manual)
	ldr r2,[r3,#OTYPER]			@;get current push/pull settings of port
 80016cc:	685a      	ldr	r2, [r3, #4]
	bic r2,#(1<<(1*PA5))		@;clear current control value of port bit (make output push/pull) 
 80016ce:	f022 0220 	bic.w	r2, r2, #32
	str r2,[r3,#OTYPER]			@; ..
 80016d2:	605a      	str	r2, [r3, #4]

	@; configure output as high speed (pg 304 of the manual)
	ldr r2,[r3,#OSPEEDR]		@;get current speed values of port
 80016d4:	689a      	ldr	r2, [r3, #8]
	bic r2,#(3<<(2*PA5))		@;clear current speed value of port bit
 80016d6:	f422 6240 	bic.w	r2, r2, #3072	@ 0xc00
	orr	r2,#(2<<(2*PA5))		@;set new speed of port bit as high speed
 80016da:	f442 6200 	orr.w	r2, r2, #2048	@ 0x800
	str r2,[r3,#OSPEEDR]		@; ..
 80016de:	609a      	str	r2, [r3, #8]

	@; configure output as no pullup, pulldown (pg 305 of the manual)
	ldr r2,[r3,#OPUPDR]			@;get current pu/pd settings of port
 80016e0:	68da      	ldr	r2, [r3, #12]
	bic r2,#(3<<(2*PA5))		@;clear current pupd value of port bit (=no pu/pd)
 80016e2:	f422 6240 	bic.w	r2, r2, #3072	@ 0xc00
	str r2,[r3,#OPUPDR]			@; ..
 80016e6:	60da      	str	r2, [r3, #12]

	pop {r7,pc}
 80016e8:	bd80      	pop	{r7, pc}

080016ea <readPA5>:
	.global userLED_status
	.global readPA5
	.thumb_func
readPA5: @;flip PA5 to its opposite state
userLED_status:
	push {r7,lr}
 80016ea:	b580      	push	{r7, lr}

	ldr r3,=GPIOA_BASE			@;load GPIOA struct address
 80016ec:	f04f 4390 	mov.w	r3, #1207959552	@ 0x48000000
	ldr r0,[r3,#IDR]			@;get current port values
 80016f0:	6918      	ldr	r0, [r3, #16]
	ands r0,r0,#(1<<(1*PA5))	@;mask port bit 
 80016f2:	f010 0020 	ands.w	r0, r0, #32
		
	pop {r7,pc}
 80016f6:	bd80      	pop	{r7, pc}

080016f8 <togglePA5>:
	.global userLED_toggle
	.global togglePA5
	.thumb_func
togglePA5: @;flip PA5 to its opposite state
userLED_toggle:
	push {r7,lr}
 80016f8:	b580      	push	{r7, lr}

	ldr r3,=GPIOA_BASE			@;load GPIOA struct address
 80016fa:	f04f 4390 	mov.w	r3, #1207959552	@ 0x48000000
	ldr r2,[r3,#IDR]			@;get current port values
 80016fe:	691a      	ldr	r2, [r3, #16]
	eor r2,r2,#(1<<(1*PA5))		@;toggle port bit 
 8001700:	f082 0220 	eor.w	r2, r2, #32
	str r2,[r3,#ODR]			@;update port values
 8001704:	615a      	str	r2, [r3, #20]
	
	pop {r7,pc}
 8001706:	bd80      	pop	{r7, pc}

08001708 <setPA5>:
	.global userLED_ON
	.global setPA5
	.thumb_func
setPA5: @;PA5 output = 1
userLED_ON:
	push {r7,lr}
 8001708:	b580      	push	{r7, lr}
	ldr r3,=GPIOA_BASE			@;load GPIOA struct address
 800170a:	f04f 4390 	mov.w	r3, #1207959552	@ 0x48000000
	mov r2,#(1<<(1*PA5))		@;PA5's position in 'SET' half of bit set/reset register
 800170e:	f04f 0220 	mov.w	r2, #32
	str r2,[r3,#BSRR]			@;set output bit PA5
 8001712:	619a      	str	r2, [r3, #24]
	
	pop {r7,pc}
 8001714:	bd80      	pop	{r7, pc}

08001716 <resetPA5>:
	.global userLED_OFF
	.global resetPA5
	.thumb_func
resetPA5: @;PA5 output = 0
userLED_OFF:
	push {r7,lr}
 8001716:	b580      	push	{r7, lr}
	ldr r3,=GPIOA_BASE			@;load GPIOA struct address
 8001718:	f04f 4390 	mov.w	r3, #1207959552	@ 0x48000000
	mov r2,#(1<<(16+(1*PA5)))	@;PA5's position in 'RESET' half of bit set/reset register
 800171c:	f44f 1200 	mov.w	r2, #2097152	@ 0x200000
	str r2,[r3,#BSRR]			@;reset output bit PA5
 8001720:	619a      	str	r2, [r3, #24]
	
	pop {r7,pc}
 8001722:	bd80      	pop	{r7, pc}
	ldr r3,=RCC_BASE			@;load RCC struct address
 8001724:	40021000 	.word	0x40021000

08001728 <device7_cmdHandler>:
@ r1: Used to store and manipulate the command ID.
@======================================================================
.global device7_cmdHandler
.thumb_func
device7_cmdHandler:
    push   {r7, lr}
 8001728:	b580      	push	{r7, lr}
    ldrb   r1, [r0], #1
 800172a:	f810 1b01 	ldrb.w	r1, [r0], #1
    and    r1, r1, #0x03
 800172e:	f001 0103 	and.w	r1, r1, #3
    tbb    [pc, r1]
 8001732:	e8df f001 	tbb	[pc, r1]

08001736 <device7_cmds>:
 8001736:	1102      	.short	0x1102
 8001738:	2f24      	.short	0x2f24

0800173a <device7_initialize>:
@ to the console.
@======================================================================
.global device7_initialize
.thumb_func
device7_initialize:
	bl device7_enable_clocks
 800173a:	f000 f839 	bl	80017b0 <device7_enable_clocks>
    bl device7_configure_gpios
 800173e:	f000 f854 	bl	80017ea <device7_configure_gpios>
    bl device7_configure_spi_peripheral
 8001742:	f000 f8ab 	bl	800189c <device7_configure_spi_peripheral>

    add   r0, rDEVP, #device7_init_msg_OFFSET
 8001746:	f105 0038 	add.w	r0, r5, #56	@ 0x38
    MOV_imm32 r1, consoleMsgs
 800174a:	f640 416c 	movw	r1, #3180	@ 0xc6c
 800174e:	f2c2 0100 	movt	r1, #8192	@ 0x2000
    bl    MoT_msgPost
 8001752:	f000 ffc6 	bl	80026e2 <MoT_msgPost>
    pop   {r7, pc}
 8001756:	bd80      	pop	{r7, pc}

08001758 <device7_write>:
@ r1: Used to hold the count of bytes to write.
@======================================================================
.global device7_write
.thumb_func
device7_write:
	ldrb r1, [r0], #1
 8001758:	f810 1b01 	ldrb.w	r1, [r0], #1
	bl store_message_bytes_into_write_arr
 800175c:	f000 f92f 	bl	80019be <store_message_bytes_into_write_arr>

08001760 <write>:
write:
	bl device7_write_byte_action
 8001760:	f000 f8ba 	bl	80018d8 <device7_write_byte_action>
	sub r1, r1, #1
 8001764:	f1a1 0101 	sub.w	r1, r1, #1
	cmp r1, #0
 8001768:	2900      	cmp	r1, #0
	bne write
 800176a:	d1f9      	bne.n	8001760 <write>

    add   r0, rDEVP, #device7_write_msg_OFFSET
 800176c:	f105 0070 	add.w	r0, r5, #112	@ 0x70
    MOV_imm32 r1, consoleMsgs
 8001770:	f640 416c 	movw	r1, #3180	@ 0xc6c
 8001774:	f2c2 0100 	movt	r1, #8192	@ 0x2000
    bl    MoT_msgPost
 8001778:	f000 ffb3 	bl	80026e2 <MoT_msgPost>
    pop   {r7, pc}
 800177c:	bd80      	pop	{r7, pc}

0800177e <device7_read>:
@ (up to 10 bytes) to the console.
@======================================================================
.global device7_read
.thumb_func
device7_read:
	bl device7_read_byte_action
 800177e:	f000 f8cf 	bl	8001920 <device7_read_byte_action>

    add   r0, rDEVP, #device7_read_msg_OFFSET
 8001782:	f105 00a0 	add.w	r0, r5, #160	@ 0xa0
    MOV_imm32 r1, consoleMsgs
 8001786:	f640 416c 	movw	r1, #3180	@ 0xc6c
 800178a:	f2c2 0100 	movt	r1, #8192	@ 0x2000
    bl    MoT_msgPost
 800178e:	f000 ffa8 	bl	80026e2 <MoT_msgPost>
    pop   {r7, pc}
 8001792:	bd80      	pop	{r7, pc}

08001794 <device7_clr_read_arr>:
@ to the console as confirmation.
@======================================================================
.global device7_clr_read_arr
.thumb_func
device7_clr_read_arr:
	bl arr_clear
 8001794:	f000 f8e1 	bl	800195a <arr_clear>

    add   r0, rDEVP, #device7_arr_msg_OFFSET
 8001798:	f105 00d4 	add.w	r0, r5, #212	@ 0xd4
    MOV_imm32 r1, consoleMsgs
 800179c:	f640 416c 	movw	r1, #3180	@ 0xc6c
 80017a0:	f2c2 0100 	movt	r1, #8192	@ 0x2000
    bl    MoT_msgPost
 80017a4:	f000 ff9d 	bl	80026e2 <MoT_msgPost>
    pop   {r7, pc}
 80017a8:	bd80      	pop	{r7, pc}

080017aa <device7_skiptask>:
@ next task's context (rDEVP) and jumping to its execution address.
@======================================================================
.global device7_skiptask
.thumb_func
device7_skiptask:
    ldr rDEVP, [rDEVP, #NEXTTASK]
 80017aa:	68ad      	ldr	r5, [r5, #8]
    ldr pc, [rDEVP, #XEQTASK]
 80017ac:	f8d5 f004 	ldr.w	pc, [r5, #4]

080017b0 <device7_enable_clocks>:
@ Data Synchronization Barriers (dsb) are used to ensure clock changes take effect.
@======================================================================
.global device7_enable_clocks
.thumb_func
device7_enable_clocks:
    push {r0-r2, lr}
 80017b0:	b507      	push	{r0, r1, r2, lr}
    MOV_imm32 r0, RCC_BASE
 80017b2:	f241 0000 	movw	r0, #4096	@ 0x1000
 80017b6:	f2c4 0002 	movt	r0, #16386	@ 0x4002
    ldr r1, [r0, #RCC_AHB2ENR]
 80017ba:	6cc1      	ldr	r1, [r0, #76]	@ 0x4c
    orr r1, r1, #RCC_AHB2ENR_GPIOBEN
 80017bc:	f041 0102 	orr.w	r1, r1, #2
    str r1, [r0, #RCC_AHB2ENR]
 80017c0:	64c1      	str	r1, [r0, #76]	@ 0x4c
    dsb
 80017c2:	f3bf 8f4f 	dsb	sy
    ldr r1, [r0, #RCC_APB1ENR1]
 80017c6:	6d81      	ldr	r1, [r0, #88]	@ 0x58
    orr r1, r1, #RCC_APB1ENR1_SPI2EN
 80017c8:	f441 4180 	orr.w	r1, r1, #16384	@ 0x4000
    str r1, [r0, #RCC_APB1ENR1]
 80017cc:	6581      	str	r1, [r0, #88]	@ 0x58
    dsb
 80017ce:	f3bf 8f4f 	dsb	sy

    ldr r1, [r0, #RCC_APB1RSTR1]
 80017d2:	6b81      	ldr	r1, [r0, #56]	@ 0x38
    orr r1, r1, #RCC_APB1RSTR1_SPI2RST
 80017d4:	f441 4180 	orr.w	r1, r1, #16384	@ 0x4000
    str r1, [r0, #RCC_APB1RSTR1]
 80017d8:	6381      	str	r1, [r0, #56]	@ 0x38
    dsb
 80017da:	f3bf 8f4f 	dsb	sy
    bic r1, r1, #RCC_APB1RSTR1_SPI2RST
 80017de:	f421 4180 	bic.w	r1, r1, #16384	@ 0x4000
    str r1, [r0, #RCC_APB1RSTR1]
 80017e2:	6381      	str	r1, [r0, #56]	@ 0x38
    dsb
 80017e4:	f3bf 8f4f 	dsb	sy

    pop {r0-r2, pc}
 80017e8:	bd07      	pop	{r0, r1, r2, pc}

080017ea <device7_configure_gpios>:
@ All AF pins are set to Push-Pull, Very High Speed, No Pull-up/down.
@======================================================================
.global device7_configure_gpios
.thumb_func
device7_configure_gpios:
    push {r0-r3, lr}
 80017ea:	b50f      	push	{r0, r1, r2, r3, lr}
    MOV_imm32 r0, GPIOB_BASE
 80017ec:	f240 4000 	movw	r0, #1024	@ 0x400
 80017f0:	f6c4 0000 	movt	r0, #18432	@ 0x4800

    ldr r1, [r0, #GPIOx_MODER]
 80017f4:	6801      	ldr	r1, [r0, #0]
    bic  r1, r1, #(0b11 << (PIN12*2))
 80017f6:	f021 7140 	bic.w	r1, r1, #50331648	@ 0x3000000
    orr  r1, r1, #(GPIO_MODER_OUTPUT << (PIN12*2))
 80017fa:	f041 7180 	orr.w	r1, r1, #16777216	@ 0x1000000
    str  r1, [r0, #GPIOx_MODER]
 80017fe:	6001      	str	r1, [r0, #0]

    ldr r1, [r0, #GPIOx_OTYPER]
 8001800:	6841      	ldr	r1, [r0, #4]
    bic r1, r1, #(1 << PIN12)
 8001802:	f421 5180 	bic.w	r1, r1, #4096	@ 0x1000
    str r1, [r0, #GPIOx_OTYPER]
 8001806:	6041      	str	r1, [r0, #4]

    ldr r1, [r0, #GPIOx_OSPEEDR]
 8001808:	6881      	ldr	r1, [r0, #8]
    orr r1, r1, #(GPIO_OSPEEDR_VHIGH << (PIN12*2))
 800180a:	f041 7140 	orr.w	r1, r1, #50331648	@ 0x3000000
    str r1, [r0, #GPIOx_OSPEEDR]
 800180e:	6081      	str	r1, [r0, #8]

    ldr r1, [r0, #GPIOx_PUPDR]
 8001810:	68c1      	ldr	r1, [r0, #12]
    bic r1, r1, #(0b11 << (PIN12*2))
 8001812:	f021 7140 	bic.w	r1, r1, #50331648	@ 0x3000000
    str r1, [r0, #GPIOx_PUPDR]
 8001816:	60c1      	str	r1, [r0, #12]

    movs r1, #(1 << PIN12)
 8001818:	f45f 5180 	movs.w	r1, #4096	@ 0x1000
    str r1, [r0, #GPIOx_BSRR]
 800181c:	6181      	str	r1, [r0, #24]

    ldr r1, [r0, #GPIOx_MODER]
 800181e:	6801      	ldr	r1, [r0, #0]
    bic r1, r1, #(0b11 << (PIN13*2))
 8001820:	f021 6140 	bic.w	r1, r1, #201326592	@ 0xc000000
    orr r1, r1, #(GPIO_MODER_AF << (PIN13*2))
 8001824:	f041 6100 	orr.w	r1, r1, #134217728	@ 0x8000000
    bic r1, r1, #(0b11 << (PIN14*2))
 8001828:	f021 5140 	bic.w	r1, r1, #805306368	@ 0x30000000
    orr r1, r1, #(GPIO_MODER_AF << (PIN14*2))
 800182c:	f041 5100 	orr.w	r1, r1, #536870912	@ 0x20000000
    bic r1, r1, #(0b11 << (PIN15*2))
 8001830:	f021 4140 	bic.w	r1, r1, #3221225472	@ 0xc0000000
    orr r1, r1, #(GPIO_MODER_AF << (PIN15*2))
 8001834:	f041 4100 	orr.w	r1, r1, #2147483648	@ 0x80000000
    str r1, [r0, #GPIOx_MODER]
 8001838:	6001      	str	r1, [r0, #0]

    ldr r1, [r0, #GPIOx_OTYPER]
 800183a:	6841      	ldr	r1, [r0, #4]
    movs r2, #((1 << PIN13) | (1 << PIN14) | (1 << PIN15))
 800183c:	f45f 4260 	movs.w	r2, #57344	@ 0xe000
    bic r1, r1, r2
 8001840:	ea21 0102 	bic.w	r1, r1, r2
    str r1, [r0, #GPIOx_OTYPER]
 8001844:	6041      	str	r1, [r0, #4]

    ldr r1, [r0, #GPIOx_OSPEEDR]
 8001846:	6881      	ldr	r1, [r0, #8]
    movs r2, #0
 8001848:	2200      	movs	r2, #0
    orr r2, r2, #(GPIO_OSPEEDR_VHIGH << (PIN13*2))
 800184a:	f042 6240 	orr.w	r2, r2, #201326592	@ 0xc000000
    orr r2, r2, #(GPIO_OSPEEDR_VHIGH << (PIN14*2))
 800184e:	f042 5240 	orr.w	r2, r2, #805306368	@ 0x30000000
    orr r2, r2, #(GPIO_OSPEEDR_VHIGH << (PIN15*2))
 8001852:	f042 4240 	orr.w	r2, r2, #3221225472	@ 0xc0000000
    orr r1, r1, r2
 8001856:	ea41 0102 	orr.w	r1, r1, r2
    str r1, [r0, #GPIOx_OSPEEDR]
 800185a:	6081      	str	r1, [r0, #8]

    ldr r1, [r0, #GPIOx_PUPDR]
 800185c:	68c1      	ldr	r1, [r0, #12]
    movs r2, #0
 800185e:	2200      	movs	r2, #0
    orr r2, r2, #(0b11 << (PIN13*2))
 8001860:	f042 6240 	orr.w	r2, r2, #201326592	@ 0xc000000
    orr r2, r2, #(0b11 << (PIN14*2))
 8001864:	f042 5240 	orr.w	r2, r2, #805306368	@ 0x30000000
    orr r2, r2, #(0b11 << (PIN15*2))
 8001868:	f042 4240 	orr.w	r2, r2, #3221225472	@ 0xc0000000
    bic r1, r1, r2
 800186c:	ea21 0102 	bic.w	r1, r1, r2
    str r1, [r0, #GPIOx_PUPDR]
 8001870:	60c1      	str	r1, [r0, #12]

    ldr r1, [r0, #GPIOx_AFRH]
 8001872:	6a41      	ldr	r1, [r0, #36]	@ 0x24

    movs r3, #0
 8001874:	2300      	movs	r3, #0
    orr  r3, r3, #(AF5 << ((PIN13-8)*4))
 8001876:	f443 03a0 	orr.w	r3, r3, #5242880	@ 0x500000
    orr  r3, r3, #(AF5 << ((PIN14-8)*4))
 800187a:	f043 63a0 	orr.w	r3, r3, #83886080	@ 0x5000000
    orr  r3, r3, #(AF5 << ((PIN15-8)*4))
 800187e:	f043 43a0 	orr.w	r3, r3, #1342177280	@ 0x50000000

    movs r2, #0
 8001882:	2200      	movs	r2, #0
    orr  r2, r2, #(0xF << ((PIN13-8)*4))
 8001884:	f442 0270 	orr.w	r2, r2, #15728640	@ 0xf00000
    orr  r2, r2, #(0xF << ((PIN14-8)*4))
 8001888:	f042 6270 	orr.w	r2, r2, #251658240	@ 0xf000000
    orr  r2, r2, #(0xF << ((PIN15-8)*4))
 800188c:	f042 4270 	orr.w	r2, r2, #4026531840	@ 0xf0000000

    bic r1, r1, r2
 8001890:	ea21 0102 	bic.w	r1, r1, r2
    orr r1, r1, r3
 8001894:	ea41 0103 	orr.w	r1, r1, r3
    str r1, [r0, #GPIOx_AFRH]
 8001898:	6241      	str	r1, [r0, #36]	@ 0x24

    pop {r0-r3, pc}
 800189a:	bd0f      	pop	{r0, r1, r2, r3, pc}

0800189c <device7_configure_spi_peripheral>:
@ 4. Enables SPI2 (sets SPE bit in SPI_CR1).
@======================================================================
.global device7_configure_spi_peripheral
.thumb_func
device7_configure_spi_peripheral:
    push {r0-r2, lr}
 800189c:	b507      	push	{r0, r1, r2, lr}
    MOV_imm32 r0, SPI2_BASE
 800189e:	f643 0000 	movw	r0, #14336	@ 0x3800
 80018a2:	f2c4 0000 	movt	r0, #16384	@ 0x4000

    ldr r1, [r0, #SPIx_CR1]
 80018a6:	6801      	ldr	r1, [r0, #0]
    bic r1, r1, #SPI_CR1_SPE
 80018a8:	f021 0140 	bic.w	r1, r1, #64	@ 0x40
    str r1, [r0, #SPIx_CR1]
 80018ac:	6001      	str	r1, [r0, #0]

    movs r1, #0
 80018ae:	2100      	movs	r1, #0
    orr r1, r1, #SPI_CR1_MSTR
 80018b0:	f041 0104 	orr.w	r1, r1, #4
    orr r1, r1, #SPI_CR1_BR_DIV16
 80018b4:	f041 0118 	orr.w	r1, r1, #24
    orr r1, r1, #SPI_CR1_SSM
 80018b8:	f441 7100 	orr.w	r1, r1, #512	@ 0x200
    orr r1, r1, #SPI_CR1_SSI
 80018bc:	f441 7180 	orr.w	r1, r1, #256	@ 0x100
    str r1, [r0, #SPIx_CR1]
 80018c0:	6001      	str	r1, [r0, #0]

    movs r2, #0
 80018c2:	2200      	movs	r2, #0
    orr r2, r2, #SPI_CR2_DS_8BIT
 80018c4:	f442 62e0 	orr.w	r2, r2, #1792	@ 0x700
    orr r2, r2, #SPI_CR2_FRXTH
 80018c8:	f442 5280 	orr.w	r2, r2, #4096	@ 0x1000
    str r2, [r0, #SPIx_CR2]
 80018cc:	6042      	str	r2, [r0, #4]

    ldr r1, [r0, #SPIx_CR1]
 80018ce:	6801      	ldr	r1, [r0, #0]
    orr r1, r1, #SPI_CR1_SPE
 80018d0:	f041 0140 	orr.w	r1, r1, #64	@ 0x40
    str r1, [r0, #SPIx_CR1]
 80018d4:	6001      	str	r1, [r0, #0]

    pop {r0-r2, pc}
 80018d6:	bd07      	pop	{r0, r1, r2, pc}

080018d8 <device7_write_byte_action>:
@ 9. De-asserts NSS (PB12 set HIGH).
@======================================================================
.global device7_write_byte_action
.thumb_func
device7_write_byte_action:
    push {r0-r7, lr}
 80018d8:	b5ff      	push	{r0, r1, r2, r3, r4, r5, r6, r7, lr}
	bl read_byte_from_write_arr
 80018da:	f000 f866 	bl	80019aa <read_byte_from_write_arr>
    mov r1, r0
 80018de:	4601      	mov	r1, r0

    MOV_imm32 r4, SPI2_BASE
 80018e0:	f643 0400 	movw	r4, #14336	@ 0x3800
 80018e4:	f2c4 0400 	movt	r4, #16384	@ 0x4000
    MOV_imm32 r6, GPIOB_BASE
 80018e8:	f240 4600 	movw	r6, #1024	@ 0x400
 80018ec:	f6c4 0600 	movt	r6, #18432	@ 0x4800

    movs r3, #(1 << (PIN12 + 16))
 80018f0:	f05f 5380 	movs.w	r3, #268435456	@ 0x10000000
    str r3, [r6, #GPIOx_BSRR]
 80018f4:	61b3      	str	r3, [r6, #24]

080018f6 <_wait_txe_write_byte>:

_wait_txe_write_byte:
    ldr r7, [r4, #SPIx_SR]
 80018f6:	68a7      	ldr	r7, [r4, #8]
    tst r7, #SPI_SR_TXE
 80018f8:	f017 0f02 	tst.w	r7, #2
    beq _wait_txe_write_byte
 80018fc:	d0fb      	beq.n	80018f6 <_wait_txe_write_byte>
    strb r1, [r4, #SPIx_DR]
 80018fe:	7321      	strb	r1, [r4, #12]

08001900 <_wait_rxne_write_byte>:

_wait_rxne_write_byte:
    ldr r7, [r4, #SPIx_SR]
 8001900:	68a7      	ldr	r7, [r4, #8]
    tst r7, #SPI_SR_RXNE
 8001902:	f017 0f01 	tst.w	r7, #1
    beq _wait_rxne_write_byte
 8001906:	d0fb      	beq.n	8001900 <_wait_rxne_write_byte>
    ldrb r2, [r4, #SPIx_DR]
 8001908:	7b22      	ldrb	r2, [r4, #12]

	mov r0, r2
 800190a:	4610      	mov	r0, r2
	bl write_byte_to_read_arr
 800190c:	f000 f843 	bl	8001996 <write_byte_to_read_arr>

08001910 <_wait_bsy_write_byte>:

_wait_bsy_write_byte:
    ldr r7, [r4, #SPIx_SR]
 8001910:	68a7      	ldr	r7, [r4, #8]
    tst r7, #SPI_SR_BSY
 8001912:	f017 0f80 	tst.w	r7, #128	@ 0x80
    bne _wait_bsy_write_byte
 8001916:	d1fb      	bne.n	8001910 <_wait_bsy_write_byte>
    movs r3, #(1 << PIN12)
 8001918:	f45f 5380 	movs.w	r3, #4096	@ 0x1000
    str r3, [r6, #GPIOx_BSRR]
 800191c:	61b3      	str	r3, [r6, #24]

    pop {r0-r7, pc}
 800191e:	bdff      	pop	{r0, r1, r2, r3, r4, r5, r6, r7, pc}

08001920 <device7_read_byte_action>:
@ placeholder 0s. This prepares the message for console output.
@======================================================================
.global device7_read_byte_action
.thumb_func
device7_read_byte_action:
    push {r1-r5, lr}
 8001920:	b53e      	push	{r1, r2, r3, r4, r5, lr}

    ldr r1, =read_arr
 8001922:	492c      	ldr	r1, [pc, #176]	@ (80019d4 <done_storing_message+0x2>)
    ldr r2, =device7_read_txt
 8001924:	4a2c      	ldr	r2, [pc, #176]	@ (80019d8 <done_storing_message+0x6>)
    add r2, r2, #11
 8001926:	f102 020b 	add.w	r2, r2, #11
    mov r3, #0
 800192a:	f04f 0300 	mov.w	r3, #0

0800192e <device7_loop>:

device7_loop:
    cmp r3, #MAX_ARR_SIZE
 800192e:	2b0a      	cmp	r3, #10
    bge device7_done
 8001930:	da12      	bge.n	8001958 <device7_done>

    ldrb r4, [r1], #1
 8001932:	f811 4b01 	ldrb.w	r4, [r1], #1

    mov r5, r4
 8001936:	4625      	mov	r5, r4
    lsr r5, r5, #4
 8001938:	ea4f 1515 	mov.w	r5, r5, lsr #4
    bl nibble_to_ascii
 800193c:	f000 faf8 	bl	8001f30 <nibble_to_ascii>
    strb r0, [r2], #1
 8001940:	f802 0b01 	strb.w	r0, [r2], #1

    mov r5, r4
 8001944:	4625      	mov	r5, r4
    and r5, r5, #0x0F
 8001946:	f005 050f 	and.w	r5, r5, #15
    bl nibble_to_ascii
 800194a:	f000 faf1 	bl	8001f30 <nibble_to_ascii>
    strb r0, [r2], #1
 800194e:	f802 0b01 	strb.w	r0, [r2], #1

    add r3, r3, #1
 8001952:	f103 0301 	add.w	r3, r3, #1
    b device7_loop
 8001956:	e7ea      	b.n	800192e <device7_loop>

08001958 <device7_done>:

device7_done:
    pop {r1-r5, pc}
 8001958:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}

0800195a <arr_clear>:
@ This ensures a clean state for subsequent SPI operations.
@======================================================================
.global arr_clear
.thumb_func
arr_clear:
    push {r0-r3, lr}
 800195a:	b50f      	push	{r0, r1, r2, r3, lr}

	ldr r0, =pointer_read
 800195c:	481f      	ldr	r0, [pc, #124]	@ (80019dc <done_storing_message+0xa>)
	mov r1, #0
 800195e:	f04f 0100 	mov.w	r1, #0
	strb r1, [r0]
 8001962:	7001      	strb	r1, [r0, #0]
	ldr r0, =pointer_write
 8001964:	481e      	ldr	r0, [pc, #120]	@ (80019e0 <done_storing_message+0xe>)
	strb r1, [r0]
 8001966:	7001      	strb	r1, [r0, #0]

    ldr r0, =read_arr
 8001968:	481a      	ldr	r0, [pc, #104]	@ (80019d4 <done_storing_message+0x2>)
    mov r1, #MAX_ARR_SIZE
 800196a:	f04f 010a 	mov.w	r1, #10
    mov r2, #0
 800196e:	f04f 0200 	mov.w	r2, #0

08001972 <clear_read_loop>:
clear_read_loop:
    cmp r1, #0
 8001972:	2900      	cmp	r1, #0
    beq done_clear_read
 8001974:	d003      	beq.n	800197e <done_clear_read>
    strb r2, [r0], #1
 8001976:	f800 2b01 	strb.w	r2, [r0], #1
    subs r1, r1, #1
 800197a:	3901      	subs	r1, #1
    b clear_read_loop
 800197c:	e7f9      	b.n	8001972 <clear_read_loop>

0800197e <done_clear_read>:
done_clear_read:

    ldr r0, =write_arr
 800197e:	4819      	ldr	r0, [pc, #100]	@ (80019e4 <done_storing_message+0x12>)
    mov r1, #MAX_ARR_SIZE
 8001980:	f04f 010a 	mov.w	r1, #10
    mov r2, #0
 8001984:	f04f 0200 	mov.w	r2, #0

08001988 <clear_write_loop>:
clear_write_loop:
    cmp r1, #0
 8001988:	2900      	cmp	r1, #0
    beq done_clear_write
 800198a:	d003      	beq.n	8001994 <done_clear_write>
    strb r2, [r0], #1
 800198c:	f800 2b01 	strb.w	r2, [r0], #1
    subs r1, r1, #1
 8001990:	3901      	subs	r1, #1
    b clear_write_loop
 8001992:	e7f9      	b.n	8001988 <clear_write_loop>

08001994 <done_clear_write>:
done_clear_write:

    pop {r0-r3, pc}
 8001994:	bd0f      	pop	{r0, r1, r2, r3, pc}

08001996 <write_byte_to_read_arr>:
@ r0: Input, the byte to be written to 'read_arr'.
@======================================================================
.global write_byte_to_read_arr
.thumb_func
write_byte_to_read_arr:
    push {r1-r3, lr}
 8001996:	b50e      	push	{r1, r2, r3, lr}

    ldr  r1, =pointer_read
 8001998:	4910      	ldr	r1, [pc, #64]	@ (80019dc <done_storing_message+0xa>)
    ldrb r3, [r1]
 800199a:	780b      	ldrb	r3, [r1, #0]
    ldr r2, =read_arr
 800199c:	4a0d      	ldr	r2, [pc, #52]	@ (80019d4 <done_storing_message+0x2>)
    add r2, r2, r3
 800199e:	441a      	add	r2, r3

    strb r0, [r2]
 80019a0:	7010      	strb	r0, [r2, #0]

    add r3, r3, #1
 80019a2:	f103 0301 	add.w	r3, r3, #1
    strb r3, [r1]
 80019a6:	700b      	strb	r3, [r1, #0]

    pop {r1-r3, pc}
 80019a8:	bd0e      	pop	{r1, r2, r3, pc}

080019aa <read_byte_from_write_arr>:
@ r0: Output, the byte read from 'write_arr'.
@======================================================================
.global read_byte_from_write_arr
.thumb_func
read_byte_from_write_arr:
    push {r1-r3, lr}
 80019aa:	b50e      	push	{r1, r2, r3, lr}

    ldr  r1, =pointer_write
 80019ac:	490c      	ldr	r1, [pc, #48]	@ (80019e0 <done_storing_message+0xe>)
    ldrb r3, [r1]
 80019ae:	780b      	ldrb	r3, [r1, #0]
    ldr r2, =write_arr
 80019b0:	4a0c      	ldr	r2, [pc, #48]	@ (80019e4 <done_storing_message+0x12>)
    add r2, r2, r3
 80019b2:	441a      	add	r2, r3

    ldrb r0, [r2]
 80019b4:	7810      	ldrb	r0, [r2, #0]

    add r3, r3, #1
 80019b6:	f103 0301 	add.w	r3, r3, #1
    strb r3, [r1]
 80019ba:	700b      	strb	r3, [r1, #0]

    pop {r1-r3, pc}
 80019bc:	bd0e      	pop	{r1, r2, r3, pc}

080019be <store_message_bytes_into_write_arr>:
@ r1: Input, the number of bytes to copy. Will be decremented to 0.
@======================================================================
.global store_message_bytes_into_write_arr
.thumb_func
store_message_bytes_into_write_arr:
    push {r0-r4, lr}
 80019be:	b51f      	push	{r0, r1, r2, r3, r4, lr}

    ldr r2, =write_arr
 80019c0:	4a08      	ldr	r2, [pc, #32]	@ (80019e4 <done_storing_message+0x12>)

080019c2 <loop_storing_message>:
loop_storing_message:
    cmp r1, #0
 80019c2:	2900      	cmp	r1, #0
    beq done_storing_message
 80019c4:	d005      	beq.n	80019d2 <done_storing_message>

    ldrb r3, [r0], #1
 80019c6:	f810 3b01 	ldrb.w	r3, [r0], #1
    strb r3, [r2], #1
 80019ca:	f802 3b01 	strb.w	r3, [r2], #1

    subs r1, r1, #1
 80019ce:	3901      	subs	r1, #1
    b loop_storing_message
 80019d0:	e7f7      	b.n	80019c2 <loop_storing_message>

080019d2 <done_storing_message>:

done_storing_message:
    pop {r0-r4, pc}
 80019d2:	bd1f      	pop	{r0, r1, r2, r3, r4, pc}
    ldr r1, =read_arr
 80019d4:	20000548 	.word	0x20000548
    ldr r2, =device7_read_txt
 80019d8:	200005d8 	.word	0x200005d8
	ldr r0, =pointer_read
 80019dc:	2000055c 	.word	0x2000055c
	ldr r0, =pointer_write
 80019e0:	2000055d 	.word	0x2000055d
    ldr r0, =write_arr
 80019e4:	20000552 	.word	0x20000552

080019e8 <device6_timer_base_init>:
@    for specific mode configuration (e.g., PWM, OPM).
@======================================================================
.global device6_timer_base_init
.thumb_func
device6_timer_base_init:
    push {r0-r3, lr}
 80019e8:	b50f      	push	{r0, r1, r2, r3, lr}

    MOV_imm32 r0, RCC_BASE
 80019ea:	f241 0000 	movw	r0, #4096	@ 0x1000
 80019ee:	f2c4 0002 	movt	r0, #16386	@ 0x4002
    ldr r1, [r0, #RCC_AHB2ENR]
 80019f2:	6cc1      	ldr	r1, [r0, #76]	@ 0x4c
    orr r1, r1, #GPIOAEN_BIT
 80019f4:	f041 0101 	orr.w	r1, r1, #1
    str r1, [r0, #RCC_AHB2ENR]
 80019f8:	64c1      	str	r1, [r0, #76]	@ 0x4c

    MOV_imm32 r0, GPIOA_BASE
 80019fa:	f240 0000 	movw	r0, #0
 80019fe:	f6c4 0000 	movt	r0, #18432	@ 0x4800
    ldr r1, [r0, #GPIOA_MODER]
 8001a02:	6801      	ldr	r1, [r0, #0]
    bic r1, r1, #(0b11 << PA5_MODER_Pos)
 8001a04:	f421 6140 	bic.w	r1, r1, #3072	@ 0xc00
    orr r1, r1, #(0b10 << PA5_MODER_Pos)
 8001a08:	f441 6100 	orr.w	r1, r1, #2048	@ 0x800
    str r1, [r0, #GPIOA_MODER]
 8001a0c:	6001      	str	r1, [r0, #0]

    ldr r1, [r0, #GPIOA_OTYPER]
 8001a0e:	6841      	ldr	r1, [r0, #4]
    bic r1, r1, #(1 << PA5_OTYPER_Pos)
 8001a10:	f021 0120 	bic.w	r1, r1, #32
    str r1, [r0, #GPIOA_OTYPER]
 8001a14:	6041      	str	r1, [r0, #4]

    ldr r1, [r0, #GPIOA_OSPEEDR]
 8001a16:	6881      	ldr	r1, [r0, #8]
    bic r1, r1, #(0b11 << PA5_OSPEEDR_Pos)
 8001a18:	f421 6140 	bic.w	r1, r1, #3072	@ 0xc00
    orr r1, r1, #(0b10 << PA5_OSPEEDR_Pos)
 8001a1c:	f441 6100 	orr.w	r1, r1, #2048	@ 0x800
    str r1, [r0, #GPIOA_OSPEEDR]
 8001a20:	6081      	str	r1, [r0, #8]

    ldr r1, [r0, #GPIOA_PUPDR]
 8001a22:	68c1      	ldr	r1, [r0, #12]
    bic r1, r1, #(0b11 << PA5_PUPDR_Pos)
 8001a24:	f421 6140 	bic.w	r1, r1, #3072	@ 0xc00
    str r1, [r0, #GPIOA_PUPDR]
 8001a28:	60c1      	str	r1, [r0, #12]

    ldr r1, [r0, #GPIOA_AFRL]
 8001a2a:	6a01      	ldr	r1, [r0, #32]
    bic r1, r1, #(0b1111 << PA5_AFRL_Pos)
 8001a2c:	f421 0170 	bic.w	r1, r1, #15728640	@ 0xf00000
    orr r1, r1, #PA5_AF_TIM2_CH1
 8001a30:	f441 1180 	orr.w	r1, r1, #1048576	@ 0x100000
    str r1, [r0, #GPIOA_AFRL]
 8001a34:	6201      	str	r1, [r0, #32]

    MOV_imm32 r0, RCC_BASE
 8001a36:	f241 0000 	movw	r0, #4096	@ 0x1000
 8001a3a:	f2c4 0002 	movt	r0, #16386	@ 0x4002
    ldr r1, [r0, #RCC_APB1ENR1]
 8001a3e:	6d81      	ldr	r1, [r0, #88]	@ 0x58
    orr r1, r1, #TIM2EN_BIT
 8001a40:	f041 0101 	orr.w	r1, r1, #1
    str r1, [r0, #RCC_APB1ENR1]
 8001a44:	6581      	str	r1, [r0, #88]	@ 0x58
    nop
 8001a46:	bf00      	nop
    nop
 8001a48:	bf00      	nop

    MOV_imm32 r0, TIM2_BASE
 8001a4a:	f240 0000 	movw	r0, #0
 8001a4e:	f2c4 0000 	movt	r0, #16384	@ 0x4000
    ldr r1, [r0, #TIMx_CR1]
 8001a52:	6801      	ldr	r1, [r0, #0]
    bic r1, r1, #TIMx_CR1_CEN
 8001a54:	f021 0101 	bic.w	r1, r1, #1
    str r1, [r0, #TIMx_CR1]
 8001a58:	6001      	str	r1, [r0, #0]
    ldr r1, [r0, #TIMx_CCER]
 8001a5a:	6a01      	ldr	r1, [r0, #32]
    bic r1, r1, #TIMx_CCER_CC1E
 8001a5c:	f021 0101 	bic.w	r1, r1, #1
    str r1, [r0, #TIMx_CCER]
 8001a60:	6201      	str	r1, [r0, #32]

    pop {r0-r3, pc}
 8001a62:	bd0f      	pop	{r0, r1, r2, r3, pc}

08001a64 <device6_timer_output_disable>:
@    and TIMx_CCR1 (Capture/Compare Register 1): All reset to 0.
@======================================================================
.global device6_timer_output_disable
.thumb_func
device6_timer_output_disable:
    push {r0-r2, lr}
 8001a64:	b507      	push	{r0, r1, r2, lr}
    MOV_imm32 r0, TIM2_BASE
 8001a66:	f240 0000 	movw	r0, #0
 8001a6a:	f2c4 0000 	movt	r0, #16384	@ 0x4000
    ldr r1, [r0, #TIMx_CR1]
 8001a6e:	6801      	ldr	r1, [r0, #0]
    bic r1, r1, #TIMx_CR1_CEN
 8001a70:	f021 0101 	bic.w	r1, r1, #1
    bic r1, r1, #TIMx_CR1_OPM
 8001a74:	f021 0108 	bic.w	r1, r1, #8
    bic r1, r1, #TIMx_CR1_ARPE
 8001a78:	f021 0180 	bic.w	r1, r1, #128	@ 0x80
    bic r1, r1, #TIMx_CR1_DIR
 8001a7c:	f021 0110 	bic.w	r1, r1, #16
    bic r1, r1, #TIMx_CR1_CMS
 8001a80:	f021 0160 	bic.w	r1, r1, #96	@ 0x60
    str r1, [r0, #TIMx_CR1]
 8001a84:	6001      	str	r1, [r0, #0]
    movs r1, #0
 8001a86:	2100      	movs	r1, #0
    str r1, [r0, #TIMx_CCER]
 8001a88:	6201      	str	r1, [r0, #32]
    movs r1, #0
 8001a8a:	2100      	movs	r1, #0
    str r1, [r0, #TIMx_CCMR1]
 8001a8c:	6181      	str	r1, [r0, #24]
    movs r1, #0
 8001a8e:	2100      	movs	r1, #0
    str r1, [r0, #TIMx_CR2]
 8001a90:	6041      	str	r1, [r0, #4]
    movs r1, #0
 8001a92:	2100      	movs	r1, #0
    str r1, [r0, #TIMx_SMCR]
 8001a94:	6081      	str	r1, [r0, #8]
    movs r1, #0
 8001a96:	2100      	movs	r1, #0
    str r1, [r0, #TIMx_DIER]
 8001a98:	60c1      	str	r1, [r0, #12]
    movs r1, #0
 8001a9a:	2100      	movs	r1, #0
    str r1, [r0, #TIMx_SR]
 8001a9c:	6101      	str	r1, [r0, #16]
    movs r1, #0
 8001a9e:	2100      	movs	r1, #0
    str r1, [r0, #TIMx_CNT]
 8001aa0:	6241      	str	r1, [r0, #36]	@ 0x24
    str r1, [r0, #TIMx_PSC]
 8001aa2:	6281      	str	r1, [r0, #40]	@ 0x28
    str r1, [r0, #TIMx_ARR]
 8001aa4:	62c1      	str	r1, [r0, #44]	@ 0x2c
    str r1, [r0, #TIMx_CCR1]
 8001aa6:	6341      	str	r1, [r0, #52]	@ 0x34
    pop {r0-r2, pc}
 8001aa8:	bd07      	pop	{r0, r1, r2, pc}

08001aaa <device6_tim2_input_init_pa0>:
@ or input capture, which are handled by other functions.
@======================================================================
.global device6_tim2_input_init_pa0
.thumb_func
device6_tim2_input_init_pa0:
    push {r0-r7, lr}
 8001aaa:	b5ff      	push	{r0, r1, r2, r3, r4, r5, r6, r7, lr}

    bl device6_timer_output_disable
 8001aac:	f7ff ffda 	bl	8001a64 <device6_timer_output_disable>

    MOV_imm32 r0, RCC_BASE
 8001ab0:	f241 0000 	movw	r0, #4096	@ 0x1000
 8001ab4:	f2c4 0002 	movt	r0, #16386	@ 0x4002
    ldr r1, [r0, #RCC_AHB2ENR]
 8001ab8:	6cc1      	ldr	r1, [r0, #76]	@ 0x4c
    orr r1, r1, #GPIOAEN_BIT
 8001aba:	f041 0101 	orr.w	r1, r1, #1
    str r1, [r0, #RCC_AHB2ENR]
 8001abe:	64c1      	str	r1, [r0, #76]	@ 0x4c

    ldr r1, [r0, #RCC_APB1ENR1]
 8001ac0:	6d81      	ldr	r1, [r0, #88]	@ 0x58
    orr r1, r1, #TIM2EN_BIT
 8001ac2:	f041 0101 	orr.w	r1, r1, #1
    str r1, [r0, #RCC_APB1ENR1]
 8001ac6:	6581      	str	r1, [r0, #88]	@ 0x58
    nop
 8001ac8:	bf00      	nop
    nop
 8001aca:	bf00      	nop

    MOV_imm32 r0, GPIOA_BASE
 8001acc:	f240 0000 	movw	r0, #0
 8001ad0:	f6c4 0000 	movt	r0, #18432	@ 0x4800
    ldr r1, [r0, #GPIOA_MODER]
 8001ad4:	6801      	ldr	r1, [r0, #0]
    ldr r2, =~(0b11 << PA0_MODER_Pos)
 8001ad6:	f06f 0203 	mvn.w	r2, #3
    and r1, r1, r2
 8001ada:	ea01 0102 	and.w	r1, r1, r2
    ldr r2, =(0b10 << PA0_MODER_Pos)
 8001ade:	f04f 0202 	mov.w	r2, #2
    orr r1, r1, r2
 8001ae2:	ea41 0102 	orr.w	r1, r1, r2
    str r1, [r0, #GPIOA_MODER]
 8001ae6:	6001      	str	r1, [r0, #0]

    ldr r1, [r0, #GPIOA_AFRL]
 8001ae8:	6a01      	ldr	r1, [r0, #32]
    ldr r2, =~(0b1111 << PA0_AFRL_Pos)
 8001aea:	f06f 020f 	mvn.w	r2, #15
    and r1, r1, r2
 8001aee:	ea01 0102 	and.w	r1, r1, r2
    ldr r2, =(GPIO_AF1_TIM2 << PA0_AFRL_Pos)
 8001af2:	f04f 0201 	mov.w	r2, #1
    orr r1, r1, r2
 8001af6:	ea41 0102 	orr.w	r1, r1, r2
    str r1, [r0, #GPIOA_AFRL]
 8001afa:	6201      	str	r1, [r0, #32]

    MOV_imm32 r0, TIM2_BASE
 8001afc:	f240 0000 	movw	r0, #0
 8001b00:	f2c4 0000 	movt	r0, #16384	@ 0x4000

    ldr r1, [r0, #TIMx_CCMR1]
 8001b04:	6981      	ldr	r1, [r0, #24]
    bic r1, r1, #TIM_CCMR1_CC1S_Msk
 8001b06:	f021 0103 	bic.w	r1, r1, #3
    orr r1, r1, #(0b01 << TIM_CCMR1_CC1S_Pos)
 8001b0a:	f041 0101 	orr.w	r1, r1, #1
    str r1, [r0, #TIMx_CCMR1]
 8001b0e:	6181      	str	r1, [r0, #24]

    ldr r1, [r0, #TIMx_CCER]
 8001b10:	6a01      	ldr	r1, [r0, #32]
    bic r1, r1, #TIM_CCER_CC1E_Msk
 8001b12:	f021 0101 	bic.w	r1, r1, #1
    str r1, [r0, #TIMx_CCER]
 8001b16:	6201      	str	r1, [r0, #32]

    pop {r0-r7, pc}
 8001b18:	bdff      	pop	{r0, r1, r2, r3, r4, r5, r6, r7, pc}
	...

08001b1c <device6_pwm_enable>:
@ 10. Enables the TIM2 counter (CEN bit in TIMx_CR1) to start PWM generation.
@======================================================================
.global device6_pwm_enable
.thumb_func
device6_pwm_enable:
    push {r0-r7, lr}
 8001b1c:	b5ff      	push	{r0, r1, r2, r3, r4, r5, r6, r7, lr}
	bl device6_timer_output_disable
 8001b1e:	f7ff ffa1 	bl	8001a64 <device6_timer_output_disable>
    MOV_imm32 r0, TIM2_BASE
 8001b22:	f240 0000 	movw	r0, #0
 8001b26:	f2c4 0000 	movt	r0, #16384	@ 0x4000

    ldr r1, [r0, #TIMx_CR1]
 8001b2a:	6801      	ldr	r1, [r0, #0]
    bic r1, r1, #TIMx_CR1_CEN
 8001b2c:	f021 0101 	bic.w	r1, r1, #1
    str r1, [r0, #TIMx_CR1]
 8001b30:	6001      	str	r1, [r0, #0]

    movw r1, #:lower16:(ACTUAL_PCLK1_HZ / TARGET_TIM_CLOCK_HZ - 1)
 8001b32:	f240 01a9 	movw	r1, #169	@ 0xa9
    movt r1, #:upper16:(ACTUAL_PCLK1_HZ / TARGET_TIM_CLOCK_HZ - 1)
 8001b36:	f2c0 0100 	movt	r1, #0
    str r1, [r0, #TIMx_PSC]
 8001b3a:	6281      	str	r1, [r0, #40]	@ 0x28

    ldr r2, =pwm_arr_val
 8001b3c:	4a12      	ldr	r2, [pc, #72]	@ (8001b88 <device6_pwm_enable+0x6c>)
    ldr r1, [r2]
 8001b3e:	6811      	ldr	r1, [r2, #0]
    str r1, [r0, #TIMx_ARR]
 8001b40:	62c1      	str	r1, [r0, #44]	@ 0x2c

	ldr r2, =pwm_arr_duty
 8001b42:	4a12      	ldr	r2, [pc, #72]	@ (8001b8c <device6_pwm_enable+0x70>)
	ldr r2, [r2]
 8001b44:	6812      	ldr	r2, [r2, #0]
	mul r2, r2, r1
 8001b46:	fb02 f201 	mul.w	r2, r2, r1
	movs r3, #100
 8001b4a:	2364      	movs	r3, #100	@ 0x64
	udiv r2, r2, r3
 8001b4c:	fbb2 f2f3 	udiv	r2, r2, r3
    str r2, [r0, #TIMx_CCR1]
 8001b50:	6342      	str	r2, [r0, #52]	@ 0x34

    ldr r1, [r0, #TIMx_CCMR1]
 8001b52:	6981      	ldr	r1, [r0, #24]
    movs r2, #0x73
 8001b54:	2273      	movs	r2, #115	@ 0x73
    bic r1, r1, r2
 8001b56:	ea21 0102 	bic.w	r1, r1, r2
    orr r1, r1, #TIMx_CCMR1_OC1M_PWM1
 8001b5a:	f041 0160 	orr.w	r1, r1, #96	@ 0x60
    orr r1, r1, #TIMx_CCMR1_OC1PE
 8001b5e:	f041 0108 	orr.w	r1, r1, #8
    str r1, [r0, #TIMx_CCMR1]
 8001b62:	6181      	str	r1, [r0, #24]

    ldr r1, [r0, #TIMx_CCER]
 8001b64:	6a01      	ldr	r1, [r0, #32]
    bic r1, r1, #(1 << 1)
 8001b66:	f021 0102 	bic.w	r1, r1, #2
    orr r1, r1, #TIMx_CCER_CC1E
 8001b6a:	f041 0101 	orr.w	r1, r1, #1
    str r1, [r0, #TIMx_CCER]
 8001b6e:	6201      	str	r1, [r0, #32]

    ldr r1, [r0, #TIMx_CR1]
 8001b70:	6801      	ldr	r1, [r0, #0]
    orr r1, r1, #TIMx_CR1_ARPE
 8001b72:	f041 0180 	orr.w	r1, r1, #128	@ 0x80
    str r1, [r0, #TIMx_CR1]
 8001b76:	6001      	str	r1, [r0, #0]

    movs r2, #TIMx_EGR_UG
 8001b78:	2201      	movs	r2, #1
    str r2, [r0, #TIMx_EGR]
 8001b7a:	6142      	str	r2, [r0, #20]

    ldr r1, [r0, #TIMx_CR1]
 8001b7c:	6801      	ldr	r1, [r0, #0]
    orr r1, r1, #TIMx_CR1_CEN
 8001b7e:	f041 0101 	orr.w	r1, r1, #1
    str r1, [r0, #TIMx_CR1]
 8001b82:	6001      	str	r1, [r0, #0]

    pop {r0-r7, pc}
 8001b84:	bdff      	pop	{r0, r1, r2, r3, r4, r5, r6, r7, pc}
 8001b86:	0000      	.short	0x0000
    ldr r2, =pwm_arr_val
 8001b88:	20000654 	.word	0x20000654
	ldr r2, =pwm_arr_duty
 8001b8c:	20000658 	.word	0x20000658

08001b90 <device6_opm_enable>:
@ 10. Enables the TIM2 counter (TIMx_CR1_CEN).
@======================================================================
.global device6_opm_enable
.thumb_func
device6_opm_enable:
    push {r0-r7, lr}
 8001b90:	b5ff      	push	{r0, r1, r2, r3, r4, r5, r6, r7, lr}

    bl device6_timer_output_disable
 8001b92:	f7ff ff67 	bl	8001a64 <device6_timer_output_disable>

    ldr r2, =opm_delay_ticks_val
 8001b96:	4a3b      	ldr	r2, [pc, #236]	@ (8001c84 <err+0x2>)
    ldr r4, [r2]
 8001b98:	6814      	ldr	r4, [r2, #0]
    ldr r2, =opm_width_ticks_val
 8001b9a:	4a3b      	ldr	r2, [pc, #236]	@ (8001c88 <err+0x6>)
    ldr r5, [r2]
 8001b9c:	6815      	ldr	r5, [r2, #0]

    MOV_imm32 r0, TIM2_BASE
 8001b9e:	f240 0000 	movw	r0, #0
 8001ba2:	f2c4 0000 	movt	r0, #16384	@ 0x4000

    movw r1, #:lower16:(ACTUAL_PCLK1_HZ / TARGET_TIM_CLOCK_HZ - 1)
 8001ba6:	f240 01a9 	movw	r1, #169	@ 0xa9
    movt r1, #:upper16:(ACTUAL_PCLK1_HZ / TARGET_TIM_CLOCK_HZ - 1)
 8001baa:	f2c0 0100 	movt	r1, #0
    str r1, [r0, #TIMx_PSC]
 8001bae:	6281      	str	r1, [r0, #40]	@ 0x28

    cmp r4, #0
 8001bb0:	2c00      	cmp	r4, #0
    it lt
 8001bb2:	bfb8      	it	lt
    movlt r4, #0
 8001bb4:	2400      	movlt	r4, #0
    cmp r5, #0
 8001bb6:	2d00      	cmp	r5, #0
    it lt
 8001bb8:	bfb8      	it	lt
    movlt r5, #0
 8001bba:	2500      	movlt	r5, #0

    str r4, [r0, #TIMx_CCR1]
 8001bbc:	6344      	str	r4, [r0, #52]	@ 0x34

    add r1, r4, r5
 8001bbe:	eb04 0105 	add.w	r1, r4, r5
    str r1, [r0, #TIMx_ARR]
 8001bc2:	62c1      	str	r1, [r0, #44]	@ 0x2c

    ldr r1, [r0, #TIMx_CCMR1]
 8001bc4:	6981      	ldr	r1, [r0, #24]
    movs r2, #0x73
 8001bc6:	2273      	movs	r2, #115	@ 0x73
    bic r1, r1, r2
 8001bc8:	ea21 0102 	bic.w	r1, r1, r2
    movs r2, #(0b111 << 4)
 8001bcc:	2270      	movs	r2, #112	@ 0x70
    orr r1, r1, r2
 8001bce:	ea41 0102 	orr.w	r1, r1, r2
    orr r1, r1, #TIMx_CCMR1_OC1PE
 8001bd2:	f041 0108 	orr.w	r1, r1, #8
    str r1, [r0, #TIMx_CCMR1]
 8001bd6:	6181      	str	r1, [r0, #24]

    ldr r1, [r0, #TIMx_CCER]
 8001bd8:	6a01      	ldr	r1, [r0, #32]
    bic r1, r1, #(1 << 1)
 8001bda:	f021 0102 	bic.w	r1, r1, #2
    orr r1, r1, #TIMx_CCER_CC1E
 8001bde:	f041 0101 	orr.w	r1, r1, #1
    str r1, [r0, #TIMx_CCER]
 8001be2:	6201      	str	r1, [r0, #32]

    ldr r1, [r0, #TIMx_CR1]
 8001be4:	6801      	ldr	r1, [r0, #0]
    orr r1, r1, #TIMx_CR1_ARPE
 8001be6:	f041 0180 	orr.w	r1, r1, #128	@ 0x80
    orr r1, r1, #TIMx_CR1_OPM
 8001bea:	f041 0108 	orr.w	r1, r1, #8
    str r1, [r0, #TIMx_CR1]
 8001bee:	6001      	str	r1, [r0, #0]

    movs r2, #TIMx_EGR_UG
 8001bf0:	2201      	movs	r2, #1
    str r2, [r0, #TIMx_EGR]
 8001bf2:	6142      	str	r2, [r0, #20]
    ldr r1, [r0, #TIMx_CR1]
 8001bf4:	6801      	ldr	r1, [r0, #0]
    orr r1, r1, #TIMx_CR1_CEN
 8001bf6:	f041 0101 	orr.w	r1, r1, #1
    str r1, [r0, #TIMx_CR1]
 8001bfa:	6001      	str	r1, [r0, #0]
    pop {r0-r7, pc}
 8001bfc:	bdff      	pop	{r0, r1, r2, r3, r4, r5, r6, r7, pc}

08001bfe <device6_simple_pulse_enable>:
@ Input: Relies on 'simple_pulse_width_ticks_val' being pre-loaded.
@======================================================================
.global device6_simple_pulse_enable
.thumb_func
device6_simple_pulse_enable:
    push {r0-r7, lr}
 8001bfe:	b5ff      	push	{r0, r1, r2, r3, r4, r5, r6, r7, lr}

	ldr r0, =simple_pulse_width_ticks_val
 8001c00:	4822      	ldr	r0, [pc, #136]	@ (8001c8c <err+0xa>)
	ldr r0, [r0]
 8001c02:	6800      	ldr	r0, [r0, #0]

	ldr r1, =opm_width_ticks_val
 8001c04:	4920      	ldr	r1, [pc, #128]	@ (8001c88 <err+0x6>)
	str r0, [r1]
 8001c06:	6008      	str	r0, [r1, #0]

	ldr r1, =opm_delay_ticks_val
 8001c08:	491e      	ldr	r1, [pc, #120]	@ (8001c84 <err+0x2>)
	mov r0, #10
 8001c0a:	f04f 000a 	mov.w	r0, #10
	str r0, [r1]
 8001c0e:	6008      	str	r0, [r1, #0]

	bl device6_opm_enable
 8001c10:	f7ff ffbe 	bl	8001b90 <device6_opm_enable>

    pop {r0-r7, pc}
 8001c14:	bdff      	pop	{r0, r1, r2, r3, r4, r5, r6, r7, pc}

08001c16 <device6_single_freq_cycle_enable>:
@ Handles division by zero if target frequency is 0.
@======================================================================
.global device6_single_freq_cycle_enable
.thumb_func
device6_single_freq_cycle_enable:
    push {r0-r7, lr}
 8001c16:	b5ff      	push	{r0, r1, r2, r3, r4, r5, r6, r7, lr}

    bl device6_timer_output_disable
 8001c18:	f7ff ff24 	bl	8001a64 <device6_timer_output_disable>

    ldr r3, =single_freq_cycle_target_hz_val
 8001c1c:	4b1c      	ldr	r3, [pc, #112]	@ (8001c90 <err+0xe>)
    ldr r3, [r3]
 8001c1e:	681b      	ldr	r3, [r3, #0]

    MOV_imm32 r0, TIM2_BASE
 8001c20:	f240 0000 	movw	r0, #0
 8001c24:	f2c4 0000 	movt	r0, #16384	@ 0x4000

    movw r1, #:lower16:(ACTUAL_PCLK1_HZ / TARGET_TIM_CLOCK_HZ - 1)
 8001c28:	f240 01a9 	movw	r1, #169	@ 0xa9
    movt r1, #:upper16:(ACTUAL_PCLK1_HZ / TARGET_TIM_CLOCK_HZ - 1)
 8001c2c:	f2c0 0100 	movt	r1, #0
    str r1, [r0, #TIMx_PSC]
 8001c30:	6281      	str	r1, [r0, #40]	@ 0x28

    ldr r4, =TARGET_TIM_CLOCK_HZ
 8001c32:	4c18      	ldr	r4, [pc, #96]	@ (8001c94 <err+0x12>)
    cmp r3, #0
 8001c34:	2b00      	cmp	r3, #0
    beq err
 8001c36:	d024      	beq.n	8001c82 <err>
    udiv r4, r4, r3
 8001c38:	fbb4 f4f3 	udiv	r4, r4, r3
    subs r4, r4, #1
 8001c3c:	3c01      	subs	r4, #1
    str r4, [r0, #TIMx_ARR]
 8001c3e:	62c4      	str	r4, [r0, #44]	@ 0x2c

    mov r5, r4
 8001c40:	4625      	mov	r5, r4
    add r5, r5, #1
 8001c42:	f105 0501 	add.w	r5, r5, #1
    lsrs r5, r5, #1
 8001c46:	086d      	lsrs	r5, r5, #1
    str r5, [r0, #TIMx_CCR1]
 8001c48:	6345      	str	r5, [r0, #52]	@ 0x34

    ldr r1, [r0, #TIMx_CCMR1]
 8001c4a:	6981      	ldr	r1, [r0, #24]
    movs r2, #0x73
 8001c4c:	2273      	movs	r2, #115	@ 0x73
    bic r1, r1, r2
 8001c4e:	ea21 0102 	bic.w	r1, r1, r2
    orr r1, r1, #TIMx_CCMR1_OC1M_PWM1
 8001c52:	f041 0160 	orr.w	r1, r1, #96	@ 0x60
    orr r1, r1, #TIMx_CCMR1_OC1PE
 8001c56:	f041 0108 	orr.w	r1, r1, #8
    str r1, [r0, #TIMx_CCMR1]
 8001c5a:	6181      	str	r1, [r0, #24]

    ldr r1, [r0, #TIMx_CCER]
 8001c5c:	6a01      	ldr	r1, [r0, #32]
    bic r1, r1, #(1 << 1)
 8001c5e:	f021 0102 	bic.w	r1, r1, #2
    orr r1, r1, #TIMx_CCER_CC1E
 8001c62:	f041 0101 	orr.w	r1, r1, #1
    str r1, [r0, #TIMx_CCER]
 8001c66:	6201      	str	r1, [r0, #32]

    ldr r1, [r0, #TIMx_CR1]
 8001c68:	6801      	ldr	r1, [r0, #0]
    orr r1, r1, #TIMx_CR1_ARPE
 8001c6a:	f041 0180 	orr.w	r1, r1, #128	@ 0x80
    orr r1, r1, #TIMx_CR1_OPM
 8001c6e:	f041 0108 	orr.w	r1, r1, #8
    str r1, [r0, #TIMx_CR1]
 8001c72:	6001      	str	r1, [r0, #0]

    movs r2, #TIMx_EGR_UG
 8001c74:	2201      	movs	r2, #1
    str r2, [r0, #TIMx_EGR]
 8001c76:	6142      	str	r2, [r0, #20]

    ldr r1, [r0, #TIMx_CR1]
 8001c78:	6801      	ldr	r1, [r0, #0]
    orr r1, r1, #TIMx_CR1_CEN
 8001c7a:	f041 0101 	orr.w	r1, r1, #1
    str r1, [r0, #TIMx_CR1]
 8001c7e:	6001      	str	r1, [r0, #0]

08001c80 <done>:

done:
    pop {r0-r7, pc}
 8001c80:	bdff      	pop	{r0, r1, r2, r3, r4, r5, r6, r7, pc}

08001c82 <err>:

err:
    b done
 8001c82:	e7fd      	b.n	8001c80 <done>
    ldr r2, =opm_delay_ticks_val
 8001c84:	2000065c 	.word	0x2000065c
    ldr r2, =opm_width_ticks_val
 8001c88:	20000660 	.word	0x20000660
	ldr r0, =simple_pulse_width_ticks_val
 8001c8c:	20000670 	.word	0x20000670
    ldr r3, =single_freq_cycle_target_hz_val
 8001c90:	2000066c 	.word	0x2000066c
    ldr r4, =TARGET_TIM_CLOCK_HZ
 8001c94:	000f4240 	.word	0x000f4240

08001c98 <store_pwm_cmd>:
@     Is updated by arg_retrieve/arg_retrieve_half.
@======================================================================
.global store_pwm_cmd
.thumb_func
store_pwm_cmd:
	push {r0-r7, lr}
 8001c98:	b5ff      	push	{r0, r1, r2, r3, r4, r5, r6, r7, lr}
	
	bl arg_retrieve
 8001c9a:	f000 f951 	bl	8001f40 <arg_retrieve>
    ldr r6, =temp_pwm_arr_val
 8001c9e:	4e2e      	ldr	r6, [pc, #184]	@ (8001d58 <done+0x4>)
	str r1, [r6]
 8001ca0:	6031      	str	r1, [r6, #0]

	bl arg_retrieve_half
 8001ca2:	f000 f969 	bl	8001f78 <arg_retrieve_half>
	ldr r6, =temp_pwm_arr_duty
 8001ca6:	4e2d      	ldr	r6, [pc, #180]	@ (8001d5c <done+0x8>)
	str r1, [r6]
 8001ca8:	6031      	str	r1, [r6, #0]
	
	pop {r0-r7, pc}
 8001caa:	bdff      	pop	{r0, r1, r2, r3, r4, r5, r6, r7, pc}

08001cac <store_pfm_cmd>:
@ r0: Input, pointer to command payload. Output from freq_to_arr_ticks (ARR value).
@======================================================================
.global store_pfm_cmd
.thumb_func
store_pfm_cmd:
	push {r0-r7, lr}
 8001cac:	b5ff      	push	{r0, r1, r2, r3, r4, r5, r6, r7, lr}
	
	bl arg_retrieve
 8001cae:	f000 f947 	bl	8001f40 <arg_retrieve>
    mov r0, r1
 8001cb2:	4608      	mov	r0, r1
    bl freq_to_arr_ticks
 8001cb4:	f000 f977 	bl	8001fa6 <freq_to_arr_ticks>
    ldr r6, =temp_pwm_arr_val
 8001cb8:	4e27      	ldr	r6, [pc, #156]	@ (8001d58 <done+0x4>)
	str r0, [r6]
 8001cba:	6030      	str	r0, [r6, #0]

	mov r1, #50
 8001cbc:	f04f 0132 	mov.w	r1, #50	@ 0x32
    ldr r6, =temp_pwm_arr_duty
 8001cc0:	4e26      	ldr	r6, [pc, #152]	@ (8001d5c <done+0x8>)
	str r1, [r6]
 8001cc2:	6031      	str	r1, [r6, #0]
	
	pop {r0-r7, pc}
 8001cc4:	bdff      	pop	{r0, r1, r2, r3, r4, r5, r6, r7, pc}

08001cc6 <store_sp_cmd>:
@ r0: Input, pointer to command payload.
@======================================================================
.global store_sp_cmd
.thumb_func
store_sp_cmd:
	push {r0-r7, lr}
 8001cc6:	b5ff      	push	{r0, r1, r2, r3, r4, r5, r6, r7, lr}
	
	bl arg_retrieve
 8001cc8:	f000 f93a 	bl	8001f40 <arg_retrieve>
    ldr r6, =temp_simple_pulse_width_ticks_val
 8001ccc:	4e24      	ldr	r6, [pc, #144]	@ (8001d60 <done+0xc>)
	str r1, [r6]
 8001cce:	6031      	str	r1, [r6, #0]
	
	pop {r0-r7, pc}
 8001cd0:	bdff      	pop	{r0, r1, r2, r3, r4, r5, r6, r7, pc}

08001cd2 <store_pw_cmd>:
@ r0: Input, pointer to command payload. Updated by arg_retrieve.
@======================================================================
.global store_pw_cmd
.thumb_func
store_pw_cmd:
	push {r0-r7, lr}
 8001cd2:	b5ff      	push	{r0, r1, r2, r3, r4, r5, r6, r7, lr}
	
	bl arg_retrieve
 8001cd4:	f000 f934 	bl	8001f40 <arg_retrieve>
    ldr r6, =temp_opm_delay_ticks_val
 8001cd8:	4e22      	ldr	r6, [pc, #136]	@ (8001d64 <done+0x10>)
	str r1, [r6]
 8001cda:	6031      	str	r1, [r6, #0]

	bl arg_retrieve
 8001cdc:	f000 f930 	bl	8001f40 <arg_retrieve>
    ldr r6, =temp_opm_width_ticks_val
 8001ce0:	4e21      	ldr	r6, [pc, #132]	@ (8001d68 <done+0x14>)
	str r1, [r6]
 8001ce2:	6031      	str	r1, [r6, #0]
	
	pop {r0-r7, pc}
 8001ce4:	bdff      	pop	{r0, r1, r2, r3, r4, r5, r6, r7, pc}

08001ce6 <store_pf_cmd>:
@ r0: Input, pointer to command payload.
@======================================================================
.global store_pf_cmd
.thumb_func
store_pf_cmd:
	push {r0-r7, lr}
 8001ce6:	b5ff      	push	{r0, r1, r2, r3, r4, r5, r6, r7, lr}
	
	bl arg_retrieve
 8001ce8:	f000 f92a 	bl	8001f40 <arg_retrieve>
    ldr r6, =temp_single_freq_cycle_target_hz_val
 8001cec:	4e1f      	ldr	r6, [pc, #124]	@ (8001d6c <done+0x18>)
	str r1, [r6]
 8001cee:	6031      	str	r1, [r6, #0]
	
	pop {r0-r7, pc}
 8001cf0:	bdff      	pop	{r0, r1, r2, r3, r4, r5, r6, r7, pc}

08001cf2 <prep_trig>:
@ r0: Input, pointer to command payload. First byte is sub-command, followed by parameters.
@======================================================================
.global prep_trig
.thumb_func
prep_trig:
	push {r0-r7, lr}
 8001cf2:	b5ff      	push	{r0, r1, r2, r3, r4, r5, r6, r7, lr}
	ldrb r1, [r0], #1
 8001cf4:	f810 1b01 	ldrb.w	r1, [r0], #1

	cmp r1, #1
 8001cf8:	2901      	cmp	r1, #1
	beq pwd
 8001cfa:	d008      	beq.n	8001d0e <pwd>
 	cmp r1, #2
 8001cfc:	2902      	cmp	r1, #2
	beq pfm
 8001cfe:	d00d      	beq.n	8001d1c <pfm>
	cmp r1, #3
 8001d00:	2903      	cmp	r1, #3
	beq sp
 8001d02:	d012      	beq.n	8001d2a <sp>
	cmp r1, #4
 8001d04:	2904      	cmp	r1, #4
	beq pw
 8001d06:	d017      	beq.n	8001d38 <pw>
	cmp r1, #5
 8001d08:	2905      	cmp	r1, #5
	beq pf
 8001d0a:	d01c      	beq.n	8001d46 <pf>
	b done
 8001d0c:	e022      	b.n	8001d54 <done>

08001d0e <pwd>:
pwd:
	ldr r5, =trigger_state
 8001d0e:	4d18      	ldr	r5, [pc, #96]	@ (8001d70 <done+0x1c>)
	mov r4, #3
 8001d10:	f04f 0403 	mov.w	r4, #3
	str r4, [r5]
 8001d14:	602c      	str	r4, [r5, #0]
	bl store_pwm_cmd
 8001d16:	f7ff ffbf 	bl	8001c98 <store_pwm_cmd>
	b done
 8001d1a:	e01b      	b.n	8001d54 <done>

08001d1c <pfm>:

pfm:
	ldr r5, =trigger_state
 8001d1c:	4d14      	ldr	r5, [pc, #80]	@ (8001d70 <done+0x1c>)
	mov r4, #4
 8001d1e:	f04f 0404 	mov.w	r4, #4
	str r4, [r5]
 8001d22:	602c      	str	r4, [r5, #0]
	bl store_pfm_cmd
 8001d24:	f7ff ffc2 	bl	8001cac <store_pfm_cmd>
	b done
 8001d28:	e014      	b.n	8001d54 <done>

08001d2a <sp>:

sp:
	ldr r5, =trigger_state
 8001d2a:	4d11      	ldr	r5, [pc, #68]	@ (8001d70 <done+0x1c>)
	mov r4, #5
 8001d2c:	f04f 0405 	mov.w	r4, #5
	str r4, [r5]
 8001d30:	602c      	str	r4, [r5, #0]
	bl store_sp_cmd
 8001d32:	f7ff ffc8 	bl	8001cc6 <store_sp_cmd>
	b done
 8001d36:	e00d      	b.n	8001d54 <done>

08001d38 <pw>:

pw:
	ldr r5, =trigger_state
 8001d38:	4d0d      	ldr	r5, [pc, #52]	@ (8001d70 <done+0x1c>)
	mov r4, #6
 8001d3a:	f04f 0406 	mov.w	r4, #6
	str r4, [r5]
 8001d3e:	602c      	str	r4, [r5, #0]
	bl store_pw_cmd
 8001d40:	f7ff ffc7 	bl	8001cd2 <store_pw_cmd>
	b done
 8001d44:	e006      	b.n	8001d54 <done>

08001d46 <pf>:

pf:
	ldr r5, =trigger_state
 8001d46:	4d0a      	ldr	r5, [pc, #40]	@ (8001d70 <done+0x1c>)
	mov r4, #7
 8001d48:	f04f 0407 	mov.w	r4, #7
	str r4, [r5]
 8001d4c:	602c      	str	r4, [r5, #0]
	bl store_pf_cmd
 8001d4e:	f7ff ffca 	bl	8001ce6 <store_pf_cmd>
	b done
 8001d52:	e7ff      	b.n	8001d54 <done>

08001d54 <done>:

done:
	pop {r0-r7, pc}
 8001d54:	bdff      	pop	{r0, r1, r2, r3, r4, r5, r6, r7, pc}
 8001d56:	0000      	.short	0x0000
    ldr r6, =temp_pwm_arr_val
 8001d58:	20000634 	.word	0x20000634
	ldr r6, =temp_pwm_arr_duty
 8001d5c:	20000638 	.word	0x20000638
    ldr r6, =temp_simple_pulse_width_ticks_val
 8001d60:	20000650 	.word	0x20000650
    ldr r6, =temp_opm_delay_ticks_val
 8001d64:	2000063c 	.word	0x2000063c
    ldr r6, =temp_opm_width_ticks_val
 8001d68:	20000640 	.word	0x20000640
    ldr r6, =temp_single_freq_cycle_target_hz_val
 8001d6c:	2000064c 	.word	0x2000064c
	ldr r5, =trigger_state
 8001d70:	2000156c 	.word	0x2000156c

08001d74 <device6_cmdHandler>:
@ r1: Used to store and manipulate the command ID.
@======================================================================
    .global device6_cmdHandler
    .thumb_func
device6_cmdHandler:
    push {r7, lr}
 8001d74:	b580      	push	{r7, lr}
    ldrb r1, [r0], #1
 8001d76:	f810 1b01 	ldrb.w	r1, [r0], #1
    and  r1, r1, #0x0f
 8001d7a:	f001 010f 	and.w	r1, r1, #15
    tbb  [pc, r1]
 8001d7e:	e8df f001 	tbb	[pc, r1]

08001d82 <device6_cmds>:
 8001d82:	1b13      	.short	0x1b13
 8001d84:	47372b77 	.word	0x47372b77
 8001d88:	07646a53 	.word	0x07646a53
 8001d8c:	0a070707 	.word	0x0a070707

08001d90 <device6_skiptask>:
@ periodic timer operations if they were managed as MoT tasks.
@======================================================================
.global device6_skiptask
.thumb_func
device6_skiptask:
    ldr rDEVP, [rDEVP, #NEXTTASK]
 8001d90:	68ad      	ldr	r5, [r5, #8]
    ldr pc, [rDEVP, #XEQTASK]
 8001d92:	f8d5 f004 	ldr.w	pc, [r5, #4]

08001d96 <device6_init_in>:
@ This sets up TIM2 to start counting external events on PA0.
@======================================================================
.global device6_init_in
.thumb_func
device6_init_in:
	bl device6_timer_output_disable
 8001d96:	f7ff fe65 	bl	8001a64 <device6_timer_output_disable>
	bl device6_tim2_input_init_pa0
 8001d9a:	f7ff fe86 	bl	8001aaa <device6_tim2_input_init_pa0>
    add r0, rDEVP, #device6_initmsg_OFFSET
 8001d9e:	f105 0020 	add.w	r0, r5, #32
	b post_msg_and_return
 8001da2:	f000 b8ef 	b.w	8001f84 <post_msg_and_return>
    pop {r7, pc}
 8001da6:	bd80      	pop	{r7, pc}

08001da8 <device6_initialize>:
@ 3. Branches to 'post_msg_and_return' to post the "device6 is Initialized" message.
@======================================================================
.global device6_initialize
.thumb_func
device6_initialize:
	bl device6_timer_output_disable
 8001da8:	f7ff fe5c 	bl	8001a64 <device6_timer_output_disable>
    bl device6_timer_base_init
 8001dac:	f7ff fe1c 	bl	80019e8 <device6_timer_base_init>
    add r0, rDEVP, #device6_initmsg_OFFSET
 8001db0:	f105 0020 	add.w	r0, r5, #32
	b post_msg_and_return
 8001db4:	f000 b8e6 	b.w	8001f84 <post_msg_and_return>

08001db8 <device6_pwm_on>:
@ r0: Input, pointer to command payload.
@======================================================================
.global device6_pwm_on
.thumb_func
device6_pwm_on:
	bl device6_timer_output_disable
 8001db8:	f7ff fe54 	bl	8001a64 <device6_timer_output_disable>
	bl arg_retrieve
 8001dbc:	f000 f8c0 	bl	8001f40 <arg_retrieve>
    ldr r6, =pwm_arr_val
 8001dc0:	4e46      	ldr	r6, [pc, #280]	@ (8001edc <convert_hex_to_buffer_loop_new+0x32>)
	str r1, [r6]
 8001dc2:	6031      	str	r1, [r6, #0]
	bl arg_retrieve_half
 8001dc4:	f000 f8d8 	bl	8001f78 <arg_retrieve_half>
	ldr r6, =pwm_arr_duty
 8001dc8:	4e45      	ldr	r6, [pc, #276]	@ (8001ee0 <convert_hex_to_buffer_loop_new+0x36>)
	str r1, [r6]
 8001dca:	6031      	str	r1, [r6, #0]
    bl device6_pwm_enable
 8001dcc:	f7ff fea6 	bl	8001b1c <device6_pwm_enable>
    add r0, rDEVP, #device6_pwm_onmsg_OFFSET
 8001dd0:	f105 004c 	add.w	r0, r5, #76	@ 0x4c
	b post_msg_and_return
 8001dd4:	f000 b8d6 	b.w	8001f84 <post_msg_and_return>

08001dd8 <device6_pulse_on>:
@ r0: Input, pointer to command payload.
@======================================================================
.global device6_pulse_on
.thumb_func
device6_pulse_on:
	bl device6_timer_output_disable
 8001dd8:	f7ff fe44 	bl	8001a64 <device6_timer_output_disable>
	bl arg_retrieve
 8001ddc:	f000 f8b0 	bl	8001f40 <arg_retrieve>
    ldr r6, =simple_pulse_width_ticks_val
 8001de0:	4e40      	ldr	r6, [pc, #256]	@ (8001ee4 <convert_hex_to_buffer_loop_new+0x3a>)
	str r1, [r6]
 8001de2:	6031      	str	r1, [r6, #0]
    bl device6_simple_pulse_enable
 8001de4:	f7ff ff0b 	bl	8001bfe <device6_simple_pulse_enable>
	add r0, rDEVP, #device6_pulse_onmsg_OFFSET
 8001de8:	f105 0094 	add.w	r0, r5, #148	@ 0x94
	b post_msg_and_return
 8001dec:	f000 b8ca 	b.w	8001f84 <post_msg_and_return>

08001df0 <device6_pulse_width_on>:
@ r0: Input, pointer to command payload.
@======================================================================
.global device6_pulse_width_on
.thumb_func
device6_pulse_width_on:
	bl device6_timer_output_disable
 8001df0:	f7ff fe38 	bl	8001a64 <device6_timer_output_disable>
	bl arg_retrieve
 8001df4:	f000 f8a4 	bl	8001f40 <arg_retrieve>
    ldr r6, =opm_delay_ticks_val
 8001df8:	4e3b      	ldr	r6, [pc, #236]	@ (8001ee8 <convert_hex_to_buffer_loop_new+0x3e>)
	str r1, [r6]
 8001dfa:	6031      	str	r1, [r6, #0]
	bl arg_retrieve
 8001dfc:	f000 f8a0 	bl	8001f40 <arg_retrieve>
    ldr r6, =opm_width_ticks_val
 8001e00:	4e3a      	ldr	r6, [pc, #232]	@ (8001eec <convert_hex_to_buffer_loop_new+0x42>)
	str r1, [r6]
 8001e02:	6031      	str	r1, [r6, #0]
    bl device6_opm_enable
 8001e04:	f7ff fec4 	bl	8001b90 <device6_opm_enable>
	add r0, rDEVP, #device6_pulse_width_onmsg_OFFSET
 8001e08:	f105 00e8 	add.w	r0, r5, #232	@ 0xe8
	b post_msg_and_return
 8001e0c:	f000 b8ba 	b.w	8001f84 <post_msg_and_return>

08001e10 <device6_pulse_frequency_on>:
@ r0: Input, pointer to command payload.
@======================================================================
.global device6_pulse_frequency_on
.thumb_func
device6_pulse_frequency_on:
	bl device6_timer_output_disable
 8001e10:	f7ff fe28 	bl	8001a64 <device6_timer_output_disable>
	bl arg_retrieve
 8001e14:	f000 f894 	bl	8001f40 <arg_retrieve>
    ldr r6, =single_freq_cycle_target_hz_val
 8001e18:	4e35      	ldr	r6, [pc, #212]	@ (8001ef0 <convert_hex_to_buffer_loop_new+0x46>)
	str r1, [r6]
 8001e1a:	6031      	str	r1, [r6, #0]
    bl device6_single_freq_cycle_enable
 8001e1c:	f7ff fefb 	bl	8001c16 <device6_single_freq_cycle_enable>
	add r0, rDEVP, #device6_pulse_frequency_onmsg_OFFSET
 8001e20:	f105 00b8 	add.w	r0, r5, #184	@ 0xb8
	b post_msg_and_return
 8001e24:	f000 b8ae 	b.w	8001f84 <post_msg_and_return>

08001e28 <device6_triggered_init>:
@ 3. Posts "device6 Trigger Enabled" message to the console.
@======================================================================
.global device6_triggered_init
.thumb_func
device6_triggered_init:
	ldr r4, =trigger_state
 8001e28:	4c32      	ldr	r4, [pc, #200]	@ (8001ef4 <convert_hex_to_buffer_loop_new+0x4a>)
	mov r1, #0
 8001e2a:	f04f 0100 	mov.w	r1, #0
	str r1, [r4]
 8001e2e:	6021      	str	r1, [r4, #0]
	bl EXTI1_init
 8001e30:	f7ff f818 	bl	8000e64 <EXTI1_init>
	MOV_imm32 r0, device6_trig_onmsg
 8001e34:	f240 7088 	movw	r0, #1928	@ 0x788
 8001e38:	f2c2 0000 	movt	r0, #8192	@ 0x2000
    MOV_imm32 r1, consoleMsgs
 8001e3c:	f640 416c 	movw	r1, #3180	@ 0xc6c
 8001e40:	f2c2 0100 	movt	r1, #8192	@ 0x2000
    bl  MoT_msgPost
 8001e44:	f000 fc4d 	bl	80026e2 <MoT_msgPost>
    pop {r7, pc}
 8001e48:	bd80      	pop	{r7, pc}

08001e4a <device6_off>:
@ Then, branches to 'post_msg_and_return' to post "device6 Fucntion OFF" message.
@======================================================================
.global device6_off
.thumb_func
device6_off:
    bl device6_timer_output_disable
 8001e4a:	f7ff fe0b 	bl	8001a64 <device6_timer_output_disable>
    add r0, rDEVP, #device6_fun_offmsg_OFFSET
 8001e4e:	f505 70be 	add.w	r0, r5, #380	@ 0x17c
	b post_msg_and_return
 8001e52:	f000 b897 	b.w	8001f84 <post_msg_and_return>

08001e56 <device6_triggered>:
@ r0: Input, pointer to command payload containing sub-command and parameters.
@======================================================================
.global device6_triggered
.thumb_func
device6_triggered:
	bl prep_trig
 8001e56:	f7ff ff4c 	bl	8001cf2 <prep_trig>
	MOV_imm32 r0, #device6_trig_armedmsg
 8001e5a:	f240 70b4 	movw	r0, #1972	@ 0x7b4
 8001e5e:	f2c2 0000 	movt	r0, #8192	@ 0x2000
	MOV_imm32 r1, consoleMsgs
 8001e62:	f640 416c 	movw	r1, #3180	@ 0xc6c
 8001e66:	f2c2 0100 	movt	r1, #8192	@ 0x2000
    bl  MoT_msgPost
 8001e6a:	f000 fc3a 	bl	80026e2 <MoT_msgPost>
    pop {r7, pc}
 8001e6e:	bd80      	pop	{r7, pc}

08001e70 <device6_pfm_on>:
@ r0: Input, pointer to command payload.
@======================================================================
.global device6_pfm_on
.thumb_func
device6_pfm_on:
	bl device6_timer_output_disable
 8001e70:	f7ff fdf8 	bl	8001a64 <device6_timer_output_disable>
	bl arg_retrieve
 8001e74:	f000 f864 	bl	8001f40 <arg_retrieve>
	mov r0, r1
 8001e78:	4608      	mov	r0, r1
	bl freq_to_arr_ticks
 8001e7a:	f000 f894 	bl	8001fa6 <freq_to_arr_ticks>
	ldr r6, =pwm_arr_val
 8001e7e:	4e17      	ldr	r6, [pc, #92]	@ (8001edc <convert_hex_to_buffer_loop_new+0x32>)
	str r0, [r6]
 8001e80:	6030      	str	r0, [r6, #0]
	mov r0, #50
 8001e82:	f04f 0032 	mov.w	r0, #50	@ 0x32
	ldr r6, =pwm_arr_duty
 8001e86:	4e16      	ldr	r6, [pc, #88]	@ (8001ee0 <convert_hex_to_buffer_loop_new+0x36>)
	str r0, [r6]
 8001e88:	6030      	str	r0, [r6, #0]
    bl device6_pwm_enable
 8001e8a:	f7ff fe47 	bl	8001b1c <device6_pwm_enable>
	add r0, rDEVP, #device6_pfm_onmsg_OFFSET
 8001e8e:	f105 0070 	add.w	r0, r5, #112	@ 0x70
	b post_msg_and_return
 8001e92:	f000 b877 	b.w	8001f84 <post_msg_and_return>

08001e96 <device6_post_input_result>:
@ r0: Input, the 32-bit value to be formatted and posted.
@======================================================================
.global device6_post_input_result
.thumb_func
device6_post_input_result:
    push {r1-r7, lr}
 8001e96:	b5fe      	push	{r1, r2, r3, r4, r5, r6, r7, lr}
    mov r4, r0
 8001e98:	4604      	mov	r4, r0

    MOV_imm32 r1, device6_input_resultmsg
 8001e9a:	f640 0118 	movw	r1, #2072	@ 0x818
 8001e9e:	f2c2 0100 	movt	r1, #8192	@ 0x2000
    add r2, r1, #24
 8001ea2:	f101 0218 	add.w	r2, r1, #24

    mov r7, #8
 8001ea6:	f04f 0708 	mov.w	r7, #8

08001eaa <convert_hex_to_buffer_loop_new>:
convert_hex_to_buffer_loop_new:
    mov r5, r4
 8001eaa:	4625      	mov	r5, r4
    lsr r5, r5, #28
 8001eac:	ea4f 7515 	mov.w	r5, r5, lsr #28
    and r5, r5, #0xF
 8001eb0:	f005 050f 	and.w	r5, r5, #15

    bl nibble_to_ascii
 8001eb4:	f000 f83c 	bl	8001f30 <nibble_to_ascii>
    strb r0, [r2], #1
 8001eb8:	f802 0b01 	strb.w	r0, [r2], #1

    lsl r4, r4, #4
 8001ebc:	ea4f 1404 	mov.w	r4, r4, lsl #4
    subs r7, r7, #1
 8001ec0:	3f01      	subs	r7, #1
    bne convert_hex_to_buffer_loop_new
 8001ec2:	d1f2      	bne.n	8001eaa <convert_hex_to_buffer_loop_new>

	MOV_imm32 r0, #device6_input_resultmsg
 8001ec4:	f640 0018 	movw	r0, #2072	@ 0x818
 8001ec8:	f2c2 0000 	movt	r0, #8192	@ 0x2000
	MOV_imm32 r1, consoleMsgs
 8001ecc:	f640 416c 	movw	r1, #3180	@ 0xc6c
 8001ed0:	f2c2 0100 	movt	r1, #8192	@ 0x2000
    bl  MoT_msgPost
 8001ed4:	f000 fc05 	bl	80026e2 <MoT_msgPost>

    pop {r1-r7, pc}
 8001ed8:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 8001eda:	0000      	.short	0x0000
    ldr r6, =pwm_arr_val
 8001edc:	20000654 	.word	0x20000654
	ldr r6, =pwm_arr_duty
 8001ee0:	20000658 	.word	0x20000658
    ldr r6, =simple_pulse_width_ticks_val
 8001ee4:	20000670 	.word	0x20000670
    ldr r6, =opm_delay_ticks_val
 8001ee8:	2000065c 	.word	0x2000065c
    ldr r6, =opm_width_ticks_val
 8001eec:	20000660 	.word	0x20000660
    ldr r6, =single_freq_cycle_target_hz_val
 8001ef0:	2000066c 	.word	0x2000066c
	ldr r4, =trigger_state
 8001ef4:	2000156c 	.word	0x2000156c

08001ef8 <swap_low2bytes_r1>:
@   r1: The lower 16 bits of r1 are modified with the byte-swapped value.
@======================================================================
.global swap_low2bytes_r1
.thumb_func
swap_low2bytes_r1:
    push {r0, r2, r3, r4, r7, lr}
 8001ef8:	b59d      	push	{r0, r2, r3, r4, r7, lr}
    mov   r2, r1
 8001efa:	460a      	mov	r2, r1
    ldr   r4, =0xFFFF
 8001efc:	f64f 74ff 	movw	r4, #65535	@ 0xffff
    and   r2, r2, r4
 8001f00:	ea02 0204 	and.w	r2, r2, r4
    mov   r3, r2
 8001f04:	4613      	mov	r3, r2
    lsr   r3, r3, #8
 8001f06:	ea4f 2313 	mov.w	r3, r3, lsr #8
    ldr   r4, =0x00FF
 8001f0a:	f04f 04ff 	mov.w	r4, #255	@ 0xff
    and   r3, r3, r4
 8001f0e:	ea03 0304 	and.w	r3, r3, r4
    lsl   r2, r2, #8
 8001f12:	ea4f 2202 	mov.w	r2, r2, lsl #8
    ldr   r4, =0xFF00
 8001f16:	f44f 447f 	mov.w	r4, #65280	@ 0xff00
    and   r2, r2, r4
 8001f1a:	ea02 0204 	and.w	r2, r2, r4
    orr   r2, r2, r3
 8001f1e:	ea42 0203 	orr.w	r2, r2, r3
    ldr   r4, =0xFFFF
 8001f22:	f64f 74ff 	movw	r4, #65535	@ 0xffff
    bic   r1, r1, r4
 8001f26:	ea21 0104 	bic.w	r1, r1, r4
    orr   r1, r1, r2
 8001f2a:	ea41 0102 	orr.w	r1, r1, r2
    pop {r0, r2, r3, r4, r7, pc}
 8001f2e:	bd9d      	pop	{r0, r2, r3, r4, r7, pc}

08001f30 <nibble_to_ascii>:
@   r0: The ASCII character representation of the nibble.
@======================================================================
.global nibble_to_ascii
.thumb_func
nibble_to_ascii:
    cmp r5, #9
 8001f30:	2d09      	cmp	r5, #9
    ble is_digit
 8001f32:	dd02      	ble.n	8001f3a <is_digit>
    add r0, r5, #'A' - 10
 8001f34:	f105 0037 	add.w	r0, r5, #55	@ 0x37
    bx lr
 8001f38:	4770      	bx	lr

08001f3a <is_digit>:

is_digit:
    add r0, r5, #'0'
 8001f3a:	f105 0030 	add.w	r0, r5, #48	@ 0x30
    bx lr
 8001f3e:	4770      	bx	lr

08001f40 <arg_retrieve>:
@   r1: The retrieved and byte-swapped 32-bit argument.
@======================================================================
.global arg_retrieve
.thumb_func
arg_retrieve:
	push {r2-r7, lr}
 8001f40:	b5fc      	push	{r2, r3, r4, r5, r6, r7, lr}

	ldrh  r1, [r0], #2
 8001f42:	f830 1b02 	ldrh.w	r1, [r0], #2
    bl    swap_low2bytes_r1
 8001f46:	f7ff ffd7 	bl	8001ef8 <swap_low2bytes_r1>
    lsl   r1, r1, #16
 8001f4a:	ea4f 4101 	mov.w	r1, r1, lsl #16
    mov   r4, r1
 8001f4e:	460c      	mov	r4, r1
	ldrh  r1, [r0], #2
 8001f50:	f830 1b02 	ldrh.w	r1, [r0], #2
    bl    swap_low2bytes_r1
 8001f54:	f7ff ffd0 	bl	8001ef8 <swap_low2bytes_r1>
    orr   r1, r1, r4
 8001f58:	ea41 0104 	orr.w	r1, r1, r4
	pop {r2-r7, pc}
 8001f5c:	bdfc      	pop	{r2, r3, r4, r5, r6, r7, pc}

08001f5e <arg_retrieve_24bits>:
@   r1: The retrieved and processed 24-bit argument (in the lower 24 bits of r1).
@======================================================================
.global arg_retrieve_24bits
.thumb_func
arg_retrieve_24bits:
    push {r2-r7, lr}
 8001f5e:	b5fc      	push	{r2, r3, r4, r5, r6, r7, lr}

    ldrh r1, [r0], #2
 8001f60:	f830 1b02 	ldrh.w	r1, [r0], #2
    bl   swap_low2bytes_r1
 8001f64:	f7ff ffc8 	bl	8001ef8 <swap_low2bytes_r1>
    lsl  r1, r1, #8
 8001f68:	ea4f 2101 	mov.w	r1, r1, lsl #8
    mov  r4, r1
 8001f6c:	460c      	mov	r4, r1

    ldrb r1, [r0], #1
 8001f6e:	f810 1b01 	ldrb.w	r1, [r0], #1
    orr  r1, r1, r4
 8001f72:	ea41 0104 	orr.w	r1, r1, r4
    pop {r2-r7, pc}
 8001f76:	bdfc      	pop	{r2, r3, r4, r5, r6, r7, pc}

08001f78 <arg_retrieve_half>:
@   r1: The retrieved and byte-swapped 16-bit argument.
@======================================================================
.global arg_retrieve_half
.thumb_func
arg_retrieve_half:
	push {r2-r7, lr}
 8001f78:	b5fc      	push	{r2, r3, r4, r5, r6, r7, lr}

	ldrh  r1, [r0], #2
 8001f7a:	f830 1b02 	ldrh.w	r1, [r0], #2
    bl    swap_low2bytes_r1
 8001f7e:	f7ff ffbb 	bl	8001ef8 <swap_low2bytes_r1>

	pop {r2-r7, pc}
 8001f82:	bdfc      	pop	{r2, r3, r4, r5, r6, r7, pc}

08001f84 <post_msg_and_return>:
@   r0: Pointer to the MoT message link structure to be posted.
@======================================================================
.global post_msg_and_return
.thumb_func
post_msg_and_return:
	MOV_imm32 r1, consoleMsgs
 8001f84:	f640 416c 	movw	r1, #3180	@ 0xc6c
 8001f88:	f2c2 0100 	movt	r1, #8192	@ 0x2000
    bl  MoT_msgPost
 8001f8c:	f000 fba9 	bl	80026e2 <MoT_msgPost>
    pop {r7, pc}
 8001f90:	bd80      	pop	{r7, pc}

08001f92 <delay>:
@   r0: Outer loop count. A larger value results in a longer delay.
@======================================================================
    .global delay
    .thumb_func
delay:
    push {r1-r3, lr}
 8001f92:	b50e      	push	{r1, r2, r3, lr}
    cmp r0, #0
 8001f94:	2800      	cmp	r0, #0
    beq end
 8001f96:	d005      	beq.n	8001fa4 <end>

08001f98 <loop>:
loop:
    movs r2, #16000
 8001f98:	f45f 527a 	movs.w	r2, #16000	@ 0x3e80

08001f9c <dec>:
dec:
    subs r2, r2, #1
 8001f9c:	3a01      	subs	r2, #1
    bne dec
 8001f9e:	d1fd      	bne.n	8001f9c <dec>
    subs r0, r0, #1
 8001fa0:	3801      	subs	r0, #1
    bne loop
 8001fa2:	d1f9      	bne.n	8001f98 <loop>

08001fa4 <end>:
end:
    pop {r1-r3, pc}
 8001fa4:	bd0e      	pop	{r1, r2, r3, pc}

08001fa6 <freq_to_arr_ticks>:
@   r0: Calculated ARR value in timer ticks, or 0 on error.
@======================================================================
.global freq_to_arr_ticks
.thumb_func
freq_to_arr_ticks:
    push {lr}
 8001fa6:	b500      	push	{lr}
    mov r1, r0
 8001fa8:	4601      	mov	r1, r0
    cmp r1, #0
 8001faa:	2900      	cmp	r1, #0
    beq err
 8001fac:	d006      	beq.n	8001fbc <err>
    ldr r0, =1000000
 8001fae:	480a      	ldr	r0, [pc, #40]	@ (8001fd8 <done_pp+0x2>)
    cmp r0, r1
 8001fb0:	4288      	cmp	r0, r1
    blt err
 8001fb2:	db03      	blt.n	8001fbc <err>
    bl __aeabi_uidiv
 8001fb4:	f000 fdb6 	bl	8002b24 <__udivsi3>
    subs r0, r0, #1
 8001fb8:	3801      	subs	r0, #1
    b done
 8001fba:	e000      	b.n	8001fbe <done>

08001fbc <err>:
err:
    movs r0, #0
 8001fbc:	2000      	movs	r0, #0

08001fbe <done>:
done:
    pop {pc}
 8001fbe:	bd00      	pop	{pc}

08001fc0 <pull_up_down>:
@   r0: Modified to either 0 or 4095.
@======================================================================
.global pull_up_down
.thumb_func
pull_up_down:
	push {r1, lr}
 8001fc0:	b502      	push	{r1, lr}
	cmp r0, #2040
 8001fc2:	f5b0 6fff 	cmp.w	r0, #2040	@ 0x7f8
	blt down
 8001fc6:	db00      	blt.n	8001fca <down>
	b up
 8001fc8:	e002      	b.n	8001fd0 <up>

08001fca <down>:

down:
	mov r0, #0
 8001fca:	f04f 0000 	mov.w	r0, #0
	b done_pp
 8001fce:	e002      	b.n	8001fd6 <done_pp>

08001fd0 <up>:
up:
	mov r0, #4095
 8001fd0:	f640 70ff 	movw	r0, #4095	@ 0xfff
	b done_pp
 8001fd4:	e7ff      	b.n	8001fd6 <done_pp>

08001fd6 <done_pp>:

done_pp:
	pop {r1, pc}
 8001fd6:	bd02      	pop	{r1, pc}
    ldr r0, =1000000
 8001fd8:	000f4240 	.word	0x000f4240

08001fdc <w25q128_erase_sector>:
@   r0: Starting 24-bit address of the sector to erase. Must be sector-aligned.
@======================================================================
.global w25q128_erase_sector
.thumb_func
w25q128_erase_sector:
    push {r0-r3, lr}
 8001fdc:	b50f      	push	{r0, r1, r2, r3, lr}

    bl w25q128_write_enable
 8001fde:	f000 f84d 	bl	800207c <w25q128_write_enable>

    bl w25q128_assert_cs
 8001fe2:	f000 f867 	bl	80020b4 <w25q128_assert_cs>

    movs r1, #W25_CMD_SECTOR_ERASE
 8001fe6:	2120      	movs	r1, #32
    push {r0}
 8001fe8:	b401      	push	{r0}
    mov r0, r1
 8001fea:	4608      	mov	r0, r1
    bl spi_send_receive_byte
 8001fec:	f000 f876 	bl	80020dc <spi_send_receive_byte>
    pop {r0}
 8001ff0:	bc01      	pop	{r0}

    mov r2, r0
 8001ff2:	4602      	mov	r2, r0
    lsr r1, r2, #16
 8001ff4:	ea4f 4112 	mov.w	r1, r2, lsr #16
    mov r0, r1
 8001ff8:	4608      	mov	r0, r1
    bl spi_send_receive_byte
 8001ffa:	f000 f86f 	bl	80020dc <spi_send_receive_byte>

    lsr r1, r2, #8
 8001ffe:	ea4f 2112 	mov.w	r1, r2, lsr #8
    mov r0, r1
 8002002:	4608      	mov	r0, r1
    bl spi_send_receive_byte
 8002004:	f000 f86a 	bl	80020dc <spi_send_receive_byte>

    mov r0, r2
 8002008:	4610      	mov	r0, r2
    bl spi_send_receive_byte
 800200a:	f000 f867 	bl	80020dc <spi_send_receive_byte>

    bl w25q128_deassert_cs
 800200e:	f000 f85b 	bl	80020c8 <w25q128_deassert_cs>

    bl w25q128_wait_for_write_complete
 8002012:	f000 f848 	bl	80020a6 <w25q128_wait_for_write_complete>

    pop {r0-r3, pc}
 8002016:	bd0f      	pop	{r0, r1, r2, r3, pc}

08002018 <w25q128_write_ram_buffer>:
@   r1: Starting 24-bit address in flash memory where data will be written.
@======================================================================
.global w25q128_write_ram_buffer
.thumb_func
w25q128_write_ram_buffer:
    push {r4-r7, lr}
 8002018:	b5f0      	push	{r4, r5, r6, r7, lr}

    ldr r2, =RAM_BUFFER_SIZE
 800201a:	f44f 7280 	mov.w	r2, #256	@ 0x100
    mov r7, r0
 800201e:	4607      	mov	r7, r0
    mov r6, r1
 8002020:	460e      	mov	r6, r1

08002022 <write_page_loop_start>:

write_page_loop_start:
    cmp r2, #0
 8002022:	2a00      	cmp	r2, #0
    beq write_page_loop_end
 8002024:	d029      	beq.n	800207a <write_page_loop_end>

    bl w25q128_write_enable
 8002026:	f000 f829 	bl	800207c <w25q128_write_enable>

    bl w25q128_assert_cs
 800202a:	f000 f843 	bl	80020b4 <w25q128_assert_cs>

    movs r4, #W25_CMD_PAGE_PROGRAM
 800202e:	2402      	movs	r4, #2
    mov r0, r4
 8002030:	4620      	mov	r0, r4
    bl spi_send_receive_byte
 8002032:	f000 f853 	bl	80020dc <spi_send_receive_byte>

    mov r5, r6
 8002036:	4635      	mov	r5, r6

    lsr r4, r5, #16
 8002038:	ea4f 4415 	mov.w	r4, r5, lsr #16
    mov r0, r4
 800203c:	4620      	mov	r0, r4
    bl spi_send_receive_byte
 800203e:	f000 f84d 	bl	80020dc <spi_send_receive_byte>

    lsr r4, r5, #8
 8002042:	ea4f 2415 	mov.w	r4, r5, lsr #8
    mov r0, r4
 8002046:	4620      	mov	r0, r4
    bl spi_send_receive_byte
 8002048:	f000 f848 	bl	80020dc <spi_send_receive_byte>

    mov r0, r5
 800204c:	4628      	mov	r0, r5
    bl spi_send_receive_byte
 800204e:	f000 f845 	bl	80020dc <spi_send_receive_byte>

    mov r3, #PAGE_SIZE
 8002052:	f44f 7380 	mov.w	r3, #256	@ 0x100

08002056 <send_data_byte_loop_start>:
send_data_byte_loop_start:
    cmp r3, #0
 8002056:	2b00      	cmp	r3, #0
    beq send_data_byte_loop_end
 8002058:	d006      	beq.n	8002068 <send_data_byte_loop_end>

    ldrb r4, [r7], #1
 800205a:	f817 4b01 	ldrb.w	r4, [r7], #1
    mov r0, r4
 800205e:	4620      	mov	r0, r4
    bl spi_send_receive_byte
 8002060:	f000 f83c 	bl	80020dc <spi_send_receive_byte>

    subs r3, r3, #1
 8002064:	3b01      	subs	r3, #1
    b send_data_byte_loop_start
 8002066:	e7f6      	b.n	8002056 <send_data_byte_loop_start>

08002068 <send_data_byte_loop_end>:
send_data_byte_loop_end:

    bl w25q128_deassert_cs
 8002068:	f000 f82e 	bl	80020c8 <w25q128_deassert_cs>

    bl w25q128_wait_for_write_complete
 800206c:	f000 f81b 	bl	80020a6 <w25q128_wait_for_write_complete>

    add r6, r6, #PAGE_SIZE
 8002070:	f506 7680 	add.w	r6, r6, #256	@ 0x100
    sub r2, r2, #PAGE_SIZE
 8002074:	f5a2 7280 	sub.w	r2, r2, #256	@ 0x100

    b write_page_loop_start
 8002078:	e7d3      	b.n	8002022 <write_page_loop_start>

0800207a <write_page_loop_end>:

write_page_loop_end:
    pop {r4-r7, pc}
 800207a:	bdf0      	pop	{r4, r5, r6, r7, pc}

0800207c <w25q128_write_enable>:
@ W25Q128 flash memory.
@======================================================================
.global w25q128_write_enable
.thumb_func
w25q128_write_enable:
    push {r0, lr}
 800207c:	b501      	push	{r0, lr}
    bl w25q128_assert_cs
 800207e:	f000 f819 	bl	80020b4 <w25q128_assert_cs>
    movs r0, #W25_CMD_WRITE_ENABLE
 8002082:	2006      	movs	r0, #6
    bl spi_send_receive_byte
 8002084:	f000 f82a 	bl	80020dc <spi_send_receive_byte>
    bl w25q128_deassert_cs
 8002088:	f000 f81e 	bl	80020c8 <w25q128_deassert_cs>
    pop {r0, pc}
 800208c:	bd01      	pop	{r0, pc}

0800208e <w25q128_read_status_register1>:
@   r0: The 8-bit value of Status Register-1.
@======================================================================
.global w25q128_read_status_register1
.thumb_func
w25q128_read_status_register1:
    push {r0, lr}
 800208e:	b501      	push	{r0, lr}
    bl w25q128_assert_cs
 8002090:	f000 f810 	bl	80020b4 <w25q128_assert_cs>
    movs r0, #W25_CMD_READ_STATUS_REG1
 8002094:	2005      	movs	r0, #5
    bl spi_send_receive_byte
 8002096:	f000 f821 	bl	80020dc <spi_send_receive_byte>
    movs r0, #W25_DUMMY_BYTE
 800209a:	2000      	movs	r0, #0
    bl spi_send_receive_byte
 800209c:	f000 f81e 	bl	80020dc <spi_send_receive_byte>
    bl w25q128_deassert_cs
 80020a0:	f000 f812 	bl	80020c8 <w25q128_deassert_cs>
    pop {r0, pc}
 80020a4:	bd01      	pop	{r0, pc}

080020a6 <w25q128_wait_for_write_complete>:
@ the function returns.
@======================================================================
.global w25q128_wait_for_write_complete
.thumb_func
w25q128_wait_for_write_complete:
    push {r0, r1, lr}
 80020a6:	b503      	push	{r0, r1, lr}

080020a8 <wait_busy_loop>:
wait_busy_loop:
    bl w25q128_read_status_register1
 80020a8:	f7ff fff1 	bl	800208e <w25q128_read_status_register1>
    movs r1, #SR1_BUSY_BIT
 80020ac:	2101      	movs	r1, #1
    tst r0, r1
 80020ae:	4208      	tst	r0, r1
    bne wait_busy_loop
 80020b0:	d1fa      	bne.n	80020a8 <wait_busy_loop>
    pop {r0, r1, pc}
 80020b2:	bd03      	pop	{r0, r1, pc}

080020b4 <w25q128_assert_cs>:
@ begin communication with the W25Q128 flash memory chip.
@======================================================================
.global w25q128_assert_cs
.thumb_func
w25q128_assert_cs:
    push {r0, r1}
 80020b4:	b403      	push	{r0, r1}
    MOV_imm32 r1, GPIOB_BASE
 80020b6:	f240 4100 	movw	r1, #1024	@ 0x400
 80020ba:	f6c4 0100 	movt	r1, #18432	@ 0x4800
    movs r0, #(1 << (PIN12 + 16))
 80020be:	f05f 5080 	movs.w	r0, #268435456	@ 0x10000000
    str r0, [r1, #GPIOx_BSRR]
 80020c2:	6188      	str	r0, [r1, #24]
    pop {r0, r1}
 80020c4:	bc03      	pop	{r0, r1}
    bx lr
 80020c6:	4770      	bx	lr

080020c8 <w25q128_deassert_cs>:
@ a command sequence or deselects the flash memory chip.
@======================================================================
.global w25q128_deassert_cs
.thumb_func
w25q128_deassert_cs:
    push {r0, r1}
 80020c8:	b403      	push	{r0, r1}
    MOV_imm32 r1, GPIOB_BASE
 80020ca:	f240 4100 	movw	r1, #1024	@ 0x400
 80020ce:	f6c4 0100 	movt	r1, #18432	@ 0x4800
    movs r0, #(1 << PIN12)
 80020d2:	f45f 5080 	movs.w	r0, #4096	@ 0x1000
    str r0, [r1, #GPIOx_BSRR]
 80020d6:	6188      	str	r0, [r1, #24]
    pop {r0, r1}
 80020d8:	bc03      	pop	{r0, r1}
    bx lr
 80020da:	4770      	bx	lr

080020dc <spi_send_receive_byte>:
@   r0: The 8-bit byte received from SPI (from the slave device).
@======================================================================
.global spi_send_receive_byte
.thumb_func
spi_send_receive_byte:
    push {lr}
 80020dc:	b500      	push	{lr}
    push {r1-r3}
 80020de:	b40e      	push	{r1, r2, r3}

    MOV_imm32 r1, SPI2_BASE
 80020e0:	f643 0100 	movw	r1, #14336	@ 0x3800
 80020e4:	f2c4 0100 	movt	r1, #16384	@ 0x4000

080020e8 <spi_wait_txe>:

spi_wait_txe:
    ldr r2, [r1, #SPIx_SR]
 80020e8:	688a      	ldr	r2, [r1, #8]
    tst r2, #SPI_SR_TXE
 80020ea:	f012 0f02 	tst.w	r2, #2
    beq spi_wait_txe
 80020ee:	d0fb      	beq.n	80020e8 <spi_wait_txe>
    mov r3, r0
 80020f0:	4603      	mov	r3, r0
    strb r3, [r1, #SPIx_DR]
 80020f2:	730b      	strb	r3, [r1, #12]

080020f4 <spi_wait_rxne>:

spi_wait_rxne:
    ldr r2, [r1, #SPIx_SR]
 80020f4:	688a      	ldr	r2, [r1, #8]
    tst r2, #SPI_SR_RXNE
 80020f6:	f012 0f01 	tst.w	r2, #1
    beq spi_wait_rxne
 80020fa:	d0fb      	beq.n	80020f4 <spi_wait_rxne>
    ldrb r0, [r1, #SPIx_DR]
 80020fc:	7b08      	ldrb	r0, [r1, #12]

    pop {r1-r3}
 80020fe:	bc0e      	pop	{r1, r2, r3}
    pop {pc}
 8002100:	bd00      	pop	{pc}

08002102 <short_delay>:
@   r0: Loop count for the delay. A larger value results in a longer delay.
@======================================================================
.global short_delay
.thumb_func
short_delay:
    push {r0, lr}
 8002102:	b501      	push	{r0, lr}

08002104 <delay_loop_internal>:
delay_loop_internal:
    subs r0, r0, #1
 8002104:	3801      	subs	r0, #1
    bne delay_loop_internal
 8002106:	d1fd      	bne.n	8002104 <delay_loop_internal>
    pop {r0, pc}
 8002108:	bd01      	pop	{r0, pc}

0800210a <w25q128_reset_init>:
@ This sequence brings the flash memory to a known, default state.
@======================================================================
.global w25q128_reset_init
.thumb_func
w25q128_reset_init:
    push {r0-r3, lr}
 800210a:	b50f      	push	{r0, r1, r2, r3, lr}

    bl device7_enable_clocks
 800210c:	f7ff fb50 	bl	80017b0 <device7_enable_clocks>
    bl device7_configure_gpios
 8002110:	f7ff fb6b 	bl	80017ea <device7_configure_gpios>
    bl device7_configure_spi_peripheral
 8002114:	f7ff fbc2 	bl	800189c <device7_configure_spi_peripheral>

    bl w25q128_assert_cs
 8002118:	f7ff ffcc 	bl	80020b4 <w25q128_assert_cs>
    movs r0, #W25_CMD_ENABLE_RESET
 800211c:	2066      	movs	r0, #102	@ 0x66
    bl spi_send_receive_byte
 800211e:	f7ff ffdd 	bl	80020dc <spi_send_receive_byte>
    bl w25q128_deassert_cs
 8002122:	f7ff ffd1 	bl	80020c8 <w25q128_deassert_cs>

    movs r0, #10
 8002126:	200a      	movs	r0, #10
    bl short_delay
 8002128:	f7ff ffeb 	bl	8002102 <short_delay>

    bl w25q128_assert_cs
 800212c:	f7ff ffc2 	bl	80020b4 <w25q128_assert_cs>
    movs r0, #W25_CMD_RESET_DEVICE
 8002130:	2099      	movs	r0, #153	@ 0x99
    bl spi_send_receive_byte
 8002132:	f7ff ffd3 	bl	80020dc <spi_send_receive_byte>
    bl w25q128_deassert_cs
 8002136:	f7ff ffc7 	bl	80020c8 <w25q128_deassert_cs>

    MOV_imm32 r0, 500
 800213a:	f240 10f4 	movw	r0, #500	@ 0x1f4
 800213e:	f2c0 0000 	movt	r0, #0
    bl short_delay
 8002142:	f7ff ffde 	bl	8002102 <short_delay>
    pop {r0-r3, pc}
 8002146:	bd0f      	pop	{r0, r1, r2, r3, pc}

08002148 <w25q128_read_ram_buffer>:
@   r1: Starting address of the destination RAM buffer.
@======================================================================
.global w25q128_read_ram_buffer
.thumb_func
w25q128_read_ram_buffer:
    push {r2-r5, lr}
 8002148:	b53c      	push	{r2, r3, r4, r5, lr}

    bl w25q128_assert_cs
 800214a:	f7ff ffb3 	bl	80020b4 <w25q128_assert_cs>

    movs r2, #W25_CMD_READ_DATA
 800214e:	2203      	movs	r2, #3
    push {r0, r1}
 8002150:	b403      	push	{r0, r1}
    mov r0, r2
 8002152:	4610      	mov	r0, r2
    bl spi_send_receive_byte
 8002154:	f7ff ffc2 	bl	80020dc <spi_send_receive_byte>
    pop {r0, r1}
 8002158:	bc03      	pop	{r0, r1}

    mov r3, r0
 800215a:	4603      	mov	r3, r0
    lsr r2, r3, #16
 800215c:	ea4f 4213 	mov.w	r2, r3, lsr #16
    mov r0, r2
 8002160:	4610      	mov	r0, r2
    bl spi_send_receive_byte
 8002162:	f7ff ffbb 	bl	80020dc <spi_send_receive_byte>

    lsr r2, r3, #8
 8002166:	ea4f 2213 	mov.w	r2, r3, lsr #8
    mov r0, r2
 800216a:	4610      	mov	r0, r2
    bl spi_send_receive_byte
 800216c:	f7ff ffb6 	bl	80020dc <spi_send_receive_byte>

    mov r0, r3
 8002170:	4618      	mov	r0, r3
    bl spi_send_receive_byte
 8002172:	f7ff ffb3 	bl	80020dc <spi_send_receive_byte>

    ldr r4, =RAM_BUFFER_SIZE
 8002176:	f44f 7480 	mov.w	r4, #256	@ 0x100
    mov r5, r1
 800217a:	460d      	mov	r5, r1

0800217c <read_byte_loop_start>:

read_byte_loop_start:
    cmp r4, #0
 800217c:	2c00      	cmp	r4, #0
    beq read_byte_loop_end
 800217e:	d006      	beq.n	800218e <read_byte_loop_end>

    movs r0, #W25_DUMMY_BYTE
 8002180:	2000      	movs	r0, #0
    bl spi_send_receive_byte
 8002182:	f7ff ffab 	bl	80020dc <spi_send_receive_byte>

    strb r0, [r5], #1
 8002186:	f805 0b01 	strb.w	r0, [r5], #1

    subs r4, r4, #1
 800218a:	3c01      	subs	r4, #1
    b read_byte_loop_start
 800218c:	e7f6      	b.n	800217c <read_byte_loop_start>

0800218e <read_byte_loop_end>:

read_byte_loop_end:
    bl w25q128_deassert_cs
 800218e:	f7ff ff9b 	bl	80020c8 <w25q128_deassert_cs>

    pop {r2-r5, pc}
 8002192:	bd3c      	pop	{r2, r3, r4, r5, pc}

08002194 <w25q128_read_jedec_id>:
@ The function handles asserting and de-asserting Chip Select (CS).
@======================================================================
.global w25q128_read_jedec_id
.thumb_func
w25q128_read_jedec_id:
    push {r0-r7, lr}
 8002194:	b5ff      	push	{r0, r1, r2, r3, r4, r5, r6, r7, lr}

    bl w25q128_assert_cs
 8002196:	f7ff ff8d 	bl	80020b4 <w25q128_assert_cs>
    movs r0, #W25_CMD_JEDEC_ID
 800219a:	209f      	movs	r0, #159	@ 0x9f
    bl spi_send_receive_byte
 800219c:	f7ff ff9e 	bl	80020dc <spi_send_receive_byte>

    movs r0, #W25_DUMMY_BYTE
 80021a0:	2000      	movs	r0, #0
    bl spi_send_receive_byte
 80021a2:	f7ff ff9b 	bl	80020dc <spi_send_receive_byte>
    mov r4, r0
 80021a6:	4604      	mov	r4, r0

    movs r0, #W25_DUMMY_BYTE
 80021a8:	2000      	movs	r0, #0
    bl spi_send_receive_byte
 80021aa:	f7ff ff97 	bl	80020dc <spi_send_receive_byte>
    mov r5, r0
 80021ae:	4605      	mov	r5, r0

    movs r0, #W25_DUMMY_BYTE
 80021b0:	2000      	movs	r0, #0
    bl spi_send_receive_byte
 80021b2:	f7ff ff93 	bl	80020dc <spi_send_receive_byte>
    mov r6, r0
 80021b6:	4606      	mov	r6, r0

    bl w25q128_deassert_cs
 80021b8:	f7ff ff86 	bl	80020c8 <w25q128_deassert_cs>

    ldr r1, =w25q128_manufacturer_id
 80021bc:	491b      	ldr	r1, [pc, #108]	@ (800222c <print_ident+0x62>)
    strb r4, [r1]
 80021be:	700c      	strb	r4, [r1, #0]
    ldr r1, =w25q128_device_type_id
 80021c0:	491b      	ldr	r1, [pc, #108]	@ (8002230 <print_ident+0x66>)
    strb r5, [r1]
 80021c2:	700d      	strb	r5, [r1, #0]
    ldr r1, =w25q128_capacity_id
 80021c4:	491b      	ldr	r1, [pc, #108]	@ (8002234 <print_ident+0x6a>)
    strb r6, [r1]
 80021c6:	700e      	strb	r6, [r1, #0]

	pop {r0-r7, pc}
 80021c8:	bdff      	pop	{r0, r1, r2, r3, r4, r5, r6, r7, pc}

080021ca <print_ident>:
@ For example, it populates the "XX" in "MF=0xXX", "Type=0xYY", "Cap=0xZZ".
@======================================================================
.global print_ident
.thumb_func
print_ident:
    push {r0-r7, lr}
 80021ca:	b5ff      	push	{r0, r1, r2, r3, r4, r5, r6, r7, lr}

    ldr r1, =device8_read_identtxt
 80021cc:	491a      	ldr	r1, [pc, #104]	@ (8002238 <print_ident+0x6e>)

    ldr r2, =w25q128_manufacturer_id
 80021ce:	4a17      	ldr	r2, [pc, #92]	@ (800222c <print_ident+0x62>)
    ldrb r4, [r2]
 80021d0:	7814      	ldrb	r4, [r2, #0]

    mov r5, r4
 80021d2:	4625      	mov	r5, r4
    lsr r5, r5, #4
 80021d4:	ea4f 1515 	mov.w	r5, r5, lsr #4
    bl nibble_to_ascii
 80021d8:	f7ff feaa 	bl	8001f30 <nibble_to_ascii>
    strb r0, [r1, #20]
 80021dc:	7508      	strb	r0, [r1, #20]

    mov r5, r4
 80021de:	4625      	mov	r5, r4
    and r5, r5, #0x0F
 80021e0:	f005 050f 	and.w	r5, r5, #15
    bl nibble_to_ascii
 80021e4:	f7ff fea4 	bl	8001f30 <nibble_to_ascii>
    strb r0, [r1, #21]
 80021e8:	7548      	strb	r0, [r1, #21]

    ldr r2, =w25q128_device_type_id
 80021ea:	4a11      	ldr	r2, [pc, #68]	@ (8002230 <print_ident+0x66>)
    ldrb r4, [r2]
 80021ec:	7814      	ldrb	r4, [r2, #0]

    mov r5, r4
 80021ee:	4625      	mov	r5, r4
    lsr r5, r5, #4
 80021f0:	ea4f 1515 	mov.w	r5, r5, lsr #4
    bl nibble_to_ascii
 80021f4:	f7ff fe9c 	bl	8001f30 <nibble_to_ascii>
    strb r0, [r1, #31]
 80021f8:	77c8      	strb	r0, [r1, #31]

    mov r5, r4
 80021fa:	4625      	mov	r5, r4
    and r5, r5, #0x0F
 80021fc:	f005 050f 	and.w	r5, r5, #15
    bl nibble_to_ascii
 8002200:	f7ff fe96 	bl	8001f30 <nibble_to_ascii>
    strb r0, [r1, #32]
 8002204:	f881 0020 	strb.w	r0, [r1, #32]

    ldr r2, =w25q128_capacity_id
 8002208:	4a0a      	ldr	r2, [pc, #40]	@ (8002234 <print_ident+0x6a>)
    ldrb r4, [r2]
 800220a:	7814      	ldrb	r4, [r2, #0]

    mov r5, r4
 800220c:	4625      	mov	r5, r4
    lsr r5, r5, #4
 800220e:	ea4f 1515 	mov.w	r5, r5, lsr #4
    bl nibble_to_ascii
 8002212:	f7ff fe8d 	bl	8001f30 <nibble_to_ascii>
    strb r0, [r1, #41]
 8002216:	f881 0029 	strb.w	r0, [r1, #41]	@ 0x29

    mov r5, r4
 800221a:	4625      	mov	r5, r4
    and r5, r5, #0x0F
 800221c:	f005 050f 	and.w	r5, r5, #15
    bl nibble_to_ascii
 8002220:	f7ff fe86 	bl	8001f30 <nibble_to_ascii>
    strb r0, [r1, #42]
 8002224:	f881 002a 	strb.w	r0, [r1, #42]	@ 0x2a

	pop {r0-r7, pc}
 8002228:	bdff      	pop	{r0, r1, r2, r3, r4, r5, r6, r7, pc}
 800222a:	0000      	.short	0x0000
    ldr r1, =w25q128_manufacturer_id
 800222c:	2000084c 	.word	0x2000084c
    ldr r1, =w25q128_device_type_id
 8002230:	2000084d 	.word	0x2000084d
    ldr r1, =w25q128_capacity_id
 8002234:	2000084e 	.word	0x2000084e
    ldr r1, =device8_read_identtxt
 8002238:	20000abc 	.word	0x20000abc

0800223c <w25q128_verify_ram_buffer>:
@       Returns 0 if any byte mismatch is found (verification failure).
@======================================================================
.global w25q128_verify_ram_buffer
.thumb_func
w25q128_verify_ram_buffer:
    push {r1-r5, lr}
 800223c:	b53e      	push	{r1, r2, r3, r4, r5, lr}

    mov r2, r0
 800223e:	4602      	mov	r2, r0
    mov r3, r1
 8002240:	460b      	mov	r3, r1
    ldr r4, =RAM_BUFFER_SIZE
 8002242:	f44f 7480 	mov.w	r4, #256	@ 0x100

08002246 <verify_loop_start>:

verify_loop_start:
    cmp r4, #0
 8002246:	2c00      	cmp	r4, #0
    beq verify_success
 8002248:	d007      	beq.n	800225a <verify_success>

    ldrb r0, [r2], #1
 800224a:	f812 0b01 	ldrb.w	r0, [r2], #1
    ldrb r1, [r3], #1
 800224e:	f813 1b01 	ldrb.w	r1, [r3], #1

    cmp r0, r1
 8002252:	4288      	cmp	r0, r1
    bne verify_failure
 8002254:	d103      	bne.n	800225e <verify_failure>

    subs r4, r4, #1
 8002256:	3c01      	subs	r4, #1
    b verify_loop_start
 8002258:	e7f5      	b.n	8002246 <verify_loop_start>

0800225a <verify_success>:

verify_success:
    movs r0, #1
 800225a:	2001      	movs	r0, #1
    b verify_end
 800225c:	e000      	b.n	8002260 <verify_end>

0800225e <verify_failure>:

verify_failure:
    movs r0, #0
 800225e:	2000      	movs	r0, #0

08002260 <verify_end>:

verify_end:
    pop {r1-r5, pc}
 8002260:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
	...

08002264 <device8_cmdHandler>:
@ r1: Used to store and manipulate the command ID.
@======================================================================
.global device8_cmdHandler
.thumb_func
device8_cmdHandler:
    push   {r7, lr}
 8002264:	b580      	push	{r7, lr}
    ldrb   r1, [r0], #1
 8002266:	f810 1b01 	ldrb.w	r1, [r0], #1
    and    r1, r1, #0x0F
 800226a:	f001 010f 	and.w	r1, r1, #15
    tbb    [pc, r1]
 800226e:	e8df f001 	tbb	[pc, r1]

08002272 <device8_cmds>:
 8002272:	0f04      	.short	0x0f04
 8002274:	50402b1c 	.word	0x50402b1c
 8002278:	65          	.byte	0x65
	...

0800227a <device8_initialize>:
@ "device8 has been initialized on W25Q128" to the console.
@======================================================================
.global device8_initialize
.thumb_func
device8_initialize:
	bl w25q128_reset_init
 800227a:	f7ff ff46 	bl	800210a <w25q128_reset_init>

    add   r0, rDEVP, #device8_initmsg_OFFSET
 800227e:	f105 0020 	add.w	r0, r5, #32
    MOV_imm32 r1, consoleMsgs
 8002282:	f640 416c 	movw	r1, #3180	@ 0xc6c
 8002286:	f2c2 0100 	movt	r1, #8192	@ 0x2000
    bl    MoT_msgPost
 800228a:	f000 fa2a 	bl	80026e2 <MoT_msgPost>
    pop   {r7, pc}
 800228e:	bd80      	pop	{r7, pc}

08002290 <device8_read_ident>:
@    to the console.
@======================================================================
.global device8_read_ident
.thumb_func
device8_read_ident:
	bl w25q128_read_jedec_id
 8002290:	f7ff ff80 	bl	8002194 <w25q128_read_jedec_id>
	bl print_ident
 8002294:	f7ff ff99 	bl	80021ca <print_ident>

    add   r0, rDEVP, #device8_read_identmsg_OFFSET
 8002298:	f105 005c 	add.w	r0, r5, #92	@ 0x5c
    MOV_imm32 r1, consoleMsgs
 800229c:	f640 416c 	movw	r1, #3180	@ 0xc6c
 80022a0:	f2c2 0100 	movt	r1, #8192	@ 0x2000
    bl    MoT_msgPost
 80022a4:	f000 fa1d 	bl	80026e2 <MoT_msgPost>
    pop   {r7, pc}
 80022a8:	bd80      	pop	{r7, pc}

080022aa <device8_erase>:
@ "device8 erased directed block" to the console.
@======================================================================
.global device8_erase
.thumb_func
device8_erase:
	MOV_imm32 r0, 0x000000
 80022aa:	f240 0000 	movw	r0, #0
 80022ae:	f2c0 0000 	movt	r0, #0
	bl w25q128_erase_sector
 80022b2:	f7ff fe93 	bl	8001fdc <w25q128_erase_sector>
    add   r0, rDEVP, #device8_erase_blockmsg_OFFSET
 80022b6:	f105 009c 	add.w	r0, r5, #156	@ 0x9c
    MOV_imm32 r1, consoleMsgs
 80022ba:	f640 416c 	movw	r1, #3180	@ 0xc6c
 80022be:	f2c2 0100 	movt	r1, #8192	@ 0x2000
    bl    MoT_msgPost
 80022c2:	f000 fa0e 	bl	80026e2 <MoT_msgPost>
    pop   {r7, pc}
 80022c6:	bd80      	pop	{r7, pc}

080022c8 <device8_input>:
@ r1, r2, r3: Used as temporary registers.
@======================================================================
.global device8_input
.thumb_func
device8_input:
	ldrb r2, [r0], #1
 80022c8:	f810 2b01 	ldrb.w	r2, [r0], #1
	ldr r3, =ram_buffer
 80022cc:	4b3b      	ldr	r3, [pc, #236]	@ (80023bc <loop_clr+0xa>)

080022ce <loop>:
loop:
	cmp r2, #0
 80022ce:	2a00      	cmp	r2, #0
	beq finished
 80022d0:	d006      	beq.n	80022e0 <finished>
	ldrb  r1, [r0], #1
 80022d2:	f810 1b01 	ldrb.w	r1, [r0], #1
	strb r1, [r3], #1
 80022d6:	f803 1b01 	strb.w	r1, [r3], #1
	sub r2, r2, #1
 80022da:	f1a2 0201 	sub.w	r2, r2, #1
	b loop
 80022de:	e7f6      	b.n	80022ce <loop>

080022e0 <finished>:

finished:
    add   r0, rDEVP, #device8_inputmsg_OFFSET
 80022e0:	f505 7098 	add.w	r0, r5, #304	@ 0x130
    MOV_imm32 r1, consoleMsgs
 80022e4:	f640 416c 	movw	r1, #3180	@ 0xc6c
 80022e8:	f2c2 0100 	movt	r1, #8192	@ 0x2000
    bl    MoT_msgPost
 80022ec:	f000 f9f9 	bl	80026e2 <MoT_msgPost>
    pop   {r7, pc}
 80022f0:	bd80      	pop	{r7, pc}

080022f2 <device8_copy>:
@ After completion, it posts "device8 copy complete" to the console.
@======================================================================
.global device8_copy
.thumb_func
device8_copy:
	ldr r0, =ram_buffer
 80022f2:	4832      	ldr	r0, [pc, #200]	@ (80023bc <loop_clr+0xa>)
	MOV_imm32 r1, 0x000000
 80022f4:	f240 0100 	movw	r1, #0
 80022f8:	f2c0 0100 	movt	r1, #0
	bl w25q128_write_ram_buffer
 80022fc:	f7ff fe8c 	bl	8002018 <w25q128_write_ram_buffer>
    add   r0, rDEVP, #device8_copy_donemsg_OFFSET
 8002300:	f505 70ae 	add.w	r0, r5, #348	@ 0x15c
    MOV_imm32 r1, consoleMsgs
 8002304:	f640 416c 	movw	r1, #3180	@ 0xc6c
 8002308:	f2c2 0100 	movt	r1, #8192	@ 0x2000
    bl    MoT_msgPost
 800230c:	f000 f9e9 	bl	80026e2 <MoT_msgPost>
    pop   {r7, pc}
 8002310:	bd80      	pop	{r7, pc}

08002312 <device8_verify>:
@    to the console based on the result.
@======================================================================
.global device8_verify
.thumb_func
device8_verify:
	bl device8_read
 8002312:	f000 f83d 	bl	8002390 <device8_read>
	ldr r0, =ram_buffer
 8002316:	4829      	ldr	r0, [pc, #164]	@ (80023bc <loop_clr+0xa>)
	ldr r1, =received_buffer
 8002318:	4929      	ldr	r1, [pc, #164]	@ (80023c0 <loop_clr+0xe>)
	bl w25q128_verify_ram_buffer
 800231a:	f7ff ff8f 	bl	800223c <w25q128_verify_ram_buffer>

	cmp r0, #1
 800231e:	2801      	cmp	r0, #1
	beq success
 8002320:	d002      	beq.n	8002328 <success>

	add   r0, rDEVP, #device8_verify_failedmsg_OFFSET
 8002322:	f505 7080 	add.w	r0, r5, #256	@ 0x100
	b done
 8002326:	e002      	b.n	800232e <done>

08002328 <success>:

success:
	add   r0, rDEVP, #device8_verify_successmsg_OFFSET
 8002328:	f105 00cc 	add.w	r0, r5, #204	@ 0xcc
	b done
 800232c:	e7ff      	b.n	800232e <done>

0800232e <done>:
done:
	MOV_imm32 r1, consoleMsgs
 800232e:	f640 416c 	movw	r1, #3180	@ 0xc6c
 8002332:	f2c2 0100 	movt	r1, #8192	@ 0x2000
    bl    MoT_msgPost
 8002336:	f000 f9d4 	bl	80026e2 <MoT_msgPost>
    pop {r7, pc}
 800233a:	bd80      	pop	{r7, pc}

0800233c <device8_output>:
@ r1-r5: Used as temporary registers.
@======================================================================
.global device8_output
.thumb_func
device8_output:
	bl clear_output_msg
 800233c:	f000 f831 	bl	80023a2 <clear_output_msg>
    ldrb  r4, [r0]
 8002340:	7804      	ldrb	r4, [r0, #0]
    ldr   r3, =received_buffer
 8002342:	4b1f      	ldr	r3, [pc, #124]	@ (80023c0 <loop_clr+0xe>)
    ldr   r2, =device8_outputmsg
 8002344:	4a1f      	ldr	r2, [pc, #124]	@ (80023c4 <loop_clr+0x12>)
    add   r2, r2, #44
 8002346:	f102 022c 	add.w	r2, r2, #44	@ 0x2c

0800234a <loop_msg>:
loop_msg:
    cmp   r4, #0
 800234a:	2c00      	cmp	r4, #0
    beq   loop_done
 800234c:	d012      	beq.n	8002374 <loop_done>
    ldrb  r1, [r3], #1
 800234e:	f813 1b01 	ldrb.w	r1, [r3], #1
    mov   r5, r1
 8002352:	460d      	mov	r5, r1
    lsr   r5, r5, #4
 8002354:	ea4f 1515 	mov.w	r5, r5, lsr #4
    bl    nibble_to_ascii
 8002358:	f7ff fdea 	bl	8001f30 <nibble_to_ascii>
    strb  r0, [r2], #1
 800235c:	f802 0b01 	strb.w	r0, [r2], #1
    mov   r5, r1
 8002360:	460d      	mov	r5, r1
    and   r5, r5, #0x0F
 8002362:	f005 050f 	and.w	r5, r5, #15
    bl    nibble_to_ascii
 8002366:	f7ff fde3 	bl	8001f30 <nibble_to_ascii>
    strb  r0, [r2], #1
 800236a:	f802 0b01 	strb.w	r0, [r2], #1
    sub   r4, r4, #1
 800236e:	f1a4 0401 	sub.w	r4, r4, #1
    b   loop_msg
 8002372:	e7ea      	b.n	800234a <loop_msg>

08002374 <loop_done>:
loop_done:
    MOV_imm32 r0, #device8_outputmsg
 8002374:	f640 30d4 	movw	r0, #3028	@ 0xbd4
 8002378:	f2c2 0000 	movt	r0, #8192	@ 0x2000
    MOV_imm32 r1, consoleMsgs
 800237c:	f640 416c 	movw	r1, #3180	@ 0xc6c
 8002380:	f2c2 0100 	movt	r1, #8192	@ 0x2000
    bl    MoT_msgPost
 8002384:	f000 f9ad 	bl	80026e2 <MoT_msgPost>
    pop   {r7, pc}
 8002388:	bd80      	pop	{r7, pc}

0800238a <device8_skiptask>:
@ It serves as the default idle behavior for this command-driven device.
@======================================================================
.global device8_skiptask
.thumb_func
device8_skiptask:
    ldr rDEVP, [rDEVP, #NEXTTASK]
 800238a:	68ad      	ldr	r5, [r5, #8]
    ldr pc, [rDEVP, #XEQTASK]
 800238c:	f8d5 f004 	ldr.w	pc, [r5, #4]

08002390 <device8_read>:
@ It calls 'w25q128_read_ram_buffer' to perform the actual read operation.
@======================================================================
.global device8_read
.thumb_func
device8_read:
	push {r0-r7, lr}
 8002390:	b5ff      	push	{r0, r1, r2, r3, r4, r5, r6, r7, lr}
	ldr r1, =received_buffer
 8002392:	490b      	ldr	r1, [pc, #44]	@ (80023c0 <loop_clr+0xe>)
	MOV_imm32 r0, 0x000000
 8002394:	f240 0000 	movw	r0, #0
 8002398:	f2c0 0000 	movt	r0, #0
	bl w25q128_read_ram_buffer
 800239c:	f7ff fed4 	bl	8002148 <w25q128_read_ram_buffer>
	pop {r0-r7, pc}
 80023a0:	bdff      	pop	{r0, r1, r2, r3, r4, r5, r6, r7, pc}

080023a2 <clear_output_msg>:
@ This prepares the message buffer for displaying new hex data read from flash.
@======================================================================
.global clear_output_msg
.thumb_func
clear_output_msg:
    push {r0-r7, lr}
 80023a2:	b5ff      	push	{r0, r1, r2, r3, r4, r5, r6, r7, lr}

    ldr   r2, =device8_outputmsg
 80023a4:	4a07      	ldr	r2, [pc, #28]	@ (80023c4 <loop_clr+0x12>)
    add   r2, r2, #44
 80023a6:	f102 022c 	add.w	r2, r2, #44	@ 0x2c
    mov   r0, #64
 80023aa:	f04f 0040 	mov.w	r0, #64	@ 0x40
    mov   r1, #48
 80023ae:	f04f 0130 	mov.w	r1, #48	@ 0x30

080023b2 <loop_clr>:

loop_clr:
    strb r1, [r2], #1
 80023b2:	f802 1b01 	strb.w	r1, [r2], #1
    subs r0, r0, #1
 80023b6:	3801      	subs	r0, #1
    bne loop_clr
 80023b8:	d1fb      	bne.n	80023b2 <loop_clr>

    pop {r0-r7, pc}
 80023ba:	bdff      	pop	{r0, r1, r2, r3, r4, r5, r6, r7, pc}
	ldr r3, =ram_buffer
 80023bc:	20000950 	.word	0x20000950
	ldr r1, =received_buffer
 80023c0:	20000850 	.word	0x20000850
    ldr   r2, =device8_outputmsg
 80023c4:	20000bd4 	.word	0x20000bd4

080023c8 <STARTING_msgtxt>:
 80023c8:	20546f4d 	.word	0x20546f4d
 80023cc:	69766564 	.word	0x69766564
 80023d0:	20306563 	.word	0x20306563
 80023d4:	73207369 	.word	0x73207369
 80023d8:	74726174 	.word	0x74726174
 80023dc:	0a676e69 	.word	0x0a676e69
 80023e0:	000d      	.short	0x000d

080023e2 <STARTING2_msgtxt>:
 80023e2:	736d      	.short	0x736d
 80023e4:	3a322067 	.word	0x3a322067
 80023e8:	546f4d20 	.word	0x546f4d20
 80023ec:	76656420 	.word	0x76656420
 80023f0:	30656369 	.word	0x30656369
 80023f4:	20736920 	.word	0x20736920
 80023f8:	72617473 	.word	0x72617473
 80023fc:	676e6974 	.word	0x676e6974
 8002400:	0d0a      	.short	0x0d0a
	...

08002404 <STARTING3_msgtxt>:
 8002404:	2067736d 	.word	0x2067736d
 8002408:	4d203a33 	.word	0x4d203a33
 800240c:	6420546f 	.word	0x6420546f
 8002410:	63697665 	.word	0x63697665
 8002414:	69203065 	.word	0x69203065
 8002418:	74732073 	.word	0x74732073
 800241c:	69747261 	.word	0x69747261
 8002420:	0d0a676e 	.word	0x0d0a676e
	...

08002426 <device0_init>:
 8002426:	f241 5418 	movw	r4, #5400	@ 0x1518
 800242a:	f2c2 0400 	movt	r4, #8192	@ 0x2000
 800242e:	6825      	ldr	r5, [r4, #0]
 8002430:	f105 003c 	add.w	r0, r5, #60	@ 0x3c
 8002434:	f8c5 0020 	str.w	r0, [r5, #32]
 8002438:	f242 40d9 	movw	r0, #9433	@ 0x24d9
 800243c:	f6c0 0000 	movt	r0, #2048	@ 0x800
 8002440:	f8c5 0024 	str.w	r0, [r5, #36]	@ 0x24
 8002444:	f242 4091 	movw	r0, #9361	@ 0x2491
 8002448:	f6c0 0000 	movt	r0, #2048	@ 0x800
 800244c:	6068      	str	r0, [r5, #4]
 800244e:	4770      	bx	lr

08002450 <device0_task0>:
 8002450:	f605 003c 	addw	r0, r5, #2108	@ 0x83c
 8002454:	f640 416c 	movw	r1, #3180	@ 0xc6c
 8002458:	f2c2 0100 	movt	r1, #8192	@ 0x2000
 800245c:	f000 f941 	bl	80026e2 <MoT_msgPost>
 8002460:	f605 004c 	addw	r0, r5, #2124	@ 0x84c
 8002464:	f640 416c 	movw	r1, #3180	@ 0xc6c
 8002468:	f2c2 0100 	movt	r1, #8192	@ 0x2000
 800246c:	f000 f939 	bl	80026e2 <MoT_msgPost>
 8002470:	f605 005c 	addw	r0, r5, #2140	@ 0x85c
 8002474:	f640 416c 	movw	r1, #3180	@ 0xc6c
 8002478:	f2c2 0100 	movt	r1, #8192	@ 0x2000
 800247c:	f000 f931 	bl	80026e2 <MoT_msgPost>
 8002480:	f242 4091 	movw	r0, #9361	@ 0x2491
 8002484:	f6c0 0000 	movt	r0, #2048	@ 0x800
 8002488:	6068      	str	r0, [r5, #4]
 800248a:	6865      	ldr	r5, [r4, #4]
 800248c:	f8d5 f004 	ldr.w	pc, [r5, #4]

08002490 <device0_task1>:
 8002490:	f241 40b0 	movw	r0, #5296	@ 0x14b0
 8002494:	f2c2 0000 	movt	r0, #8192	@ 0x2000
 8002498:	f000 f948 	bl	800272c <MoT_cmdlistUpdate>
 800249c:	f640 406c 	movw	r0, #3180	@ 0xc6c
 80024a0:	f2c2 0000 	movt	r0, #8192	@ 0x2000
 80024a4:	f000 f90a 	bl	80026bc <MoT_msglistUpdate>
 80024a8:	f7fe f83d 	bl	8000526 <HW_userCOM_okputchar>
 80024ac:	2800      	cmp	r0, #0
 80024ae:	d409      	bmi.n	80024c4 <device0_task1+0x34>
 80024b0:	f640 406c 	movw	r0, #3180	@ 0xc6c
 80024b4:	f2c2 0000 	movt	r0, #8192	@ 0x2000
 80024b8:	f000 f92a 	bl	8002710 <MoT_msglistGetchar>
 80024bc:	2800      	cmp	r0, #0
 80024be:	d401      	bmi.n	80024c4 <device0_task1+0x34>
 80024c0:	f7fe f854 	bl	800056c <HW_userCOM_putchar>
 80024c4:	f000 f9c9 	bl	800285a <userCOM_RXgetbuf0>
 80024c8:	2800      	cmp	r0, #0
 80024ca:	d502      	bpl.n	80024d2 <Cmd_parser>
 80024cc:	6865      	ldr	r5, [r4, #4]
 80024ce:	f8d5 f004 	ldr.w	pc, [r5, #4]

080024d2 <Cmd_parser>:
 80024d2:	f8d5 1024 	ldr.w	r1, [r5, #36]	@ 0x24
 80024d6:	4708      	bx	r1

080024d8 <Cmd_wait_for_startchar>:
 80024d8:	283a      	cmp	r0, #58	@ 0x3a
 80024da:	d002      	beq.n	80024e2 <Cmd_have_startchar>
 80024dc:	6865      	ldr	r5, [r4, #4]
 80024de:	f8d5 f004 	ldr.w	pc, [r5, #4]

080024e2 <Cmd_have_startchar>:
 80024e2:	f105 023c 	add.w	r2, r5, #60	@ 0x3c
 80024e6:	f8c5 2020 	str.w	r2, [r5, #32]
 80024ea:	f242 40fb 	movw	r0, #9467	@ 0x24fb
 80024ee:	f6c0 0000 	movt	r0, #2048	@ 0x800
 80024f2:	f8c5 0024 	str.w	r0, [r5, #36]	@ 0x24
 80024f6:	f000 f9b0 	bl	800285a <userCOM_RXgetbuf0>

080024fa <Cmd_get_msg_evenchar>:
 80024fa:	2800      	cmp	r0, #0
 80024fc:	d502      	bpl.n	8002504 <Cmd_have_evenchar>
 80024fe:	6865      	ldr	r5, [r4, #4]
 8002500:	f8d5 f004 	ldr.w	pc, [r5, #4]

08002504 <Cmd_have_evenchar>:
 8002504:	280a      	cmp	r0, #10
 8002506:	d030      	beq.n	800256a <Cmd_have_endchar>
 8002508:	280d      	cmp	r0, #13
 800250a:	d02e      	beq.n	800256a <Cmd_have_endchar>
 800250c:	f8d5 2020 	ldr.w	r2, [r5, #32]
 8002510:	2839      	cmp	r0, #57	@ 0x39
 8002512:	bf94      	ite	ls
 8002514:	3830      	subls	r0, #48	@ 0x30
 8002516:	3837      	subhi	r0, #55	@ 0x37
 8002518:	ea4f 1000 	mov.w	r0, r0, lsl #4
 800251c:	7010      	strb	r0, [r2, #0]
 800251e:	f242 502f 	movw	r0, #9519	@ 0x252f
 8002522:	f6c0 0000 	movt	r0, #2048	@ 0x800
 8002526:	f8c5 0024 	str.w	r0, [r5, #36]	@ 0x24
 800252a:	f000 f996 	bl	800285a <userCOM_RXgetbuf0>

0800252e <Cmd_get_msg_oddchar>:
 800252e:	2800      	cmp	r0, #0
 8002530:	d502      	bpl.n	8002538 <Cmd_have_oddchar>
 8002532:	6865      	ldr	r5, [r4, #4]
 8002534:	f8d5 f004 	ldr.w	pc, [r5, #4]

08002538 <Cmd_have_oddchar>:
 8002538:	280a      	cmp	r0, #10
 800253a:	d033      	beq.n	80025a4 <Cmd_error_exit>
 800253c:	280d      	cmp	r0, #13
 800253e:	d031      	beq.n	80025a4 <Cmd_error_exit>
 8002540:	2839      	cmp	r0, #57	@ 0x39
 8002542:	bf94      	ite	ls
 8002544:	3830      	subls	r0, #48	@ 0x30
 8002546:	3837      	subhi	r0, #55	@ 0x37
 8002548:	f8d5 2020 	ldr.w	r2, [r5, #32]
 800254c:	7811      	ldrb	r1, [r2, #0]
 800254e:	4401      	add	r1, r0
 8002550:	f802 1b01 	strb.w	r1, [r2], #1
 8002554:	f8c5 2020 	str.w	r2, [r5, #32]
 8002558:	f242 40fb 	movw	r0, #9467	@ 0x24fb
 800255c:	f6c0 0000 	movt	r0, #2048	@ 0x800
 8002560:	f8c5 0024 	str.w	r0, [r5, #36]	@ 0x24
 8002564:	f000 f979 	bl	800285a <userCOM_RXgetbuf0>
 8002568:	e7c7      	b.n	80024fa <Cmd_get_msg_evenchar>

0800256a <Cmd_have_endchar>:
 800256a:	f105 033c 	add.w	r3, r5, #60	@ 0x3c
 800256e:	f8d5 2020 	ldr.w	r2, [r5, #32]
 8002572:	429a      	cmp	r2, r3
 8002574:	d016      	beq.n	80025a4 <Cmd_error_exit>
 8002576:	2000      	movs	r0, #0

08002578 <Cmd_accumulate_checksum>:
 8002578:	f813 1b01 	ldrb.w	r1, [r3], #1
 800257c:	1840      	adds	r0, r0, r1
 800257e:	4293      	cmp	r3, r2
 8002580:	d3fa      	bcc.n	8002578 <Cmd_accumulate_checksum>
 8002582:	f000 00ff 	and.w	r0, r0, #255	@ 0xff
 8002586:	2800      	cmp	r0, #0
 8002588:	d10c      	bne.n	80025a4 <Cmd_error_exit>

0800258a <Cmd_dispatch>:
 800258a:	f105 003c 	add.w	r0, r5, #60	@ 0x3c
 800258e:	f810 1b01 	ldrb.w	r1, [r0], #1
 8002592:	f854 5021 	ldr.w	r5, [r4, r1, lsl #2]
 8002596:	682a      	ldr	r2, [r5, #0]
 8002598:	4790      	blx	r2
 800259a:	f7ff ff44 	bl	8002426 <device0_init>
 800259e:	68ad      	ldr	r5, [r5, #8]
 80025a0:	f8d5 f004 	ldr.w	pc, [r5, #4]

080025a4 <Cmd_error_exit>:
 80025a4:	f7ff ff3f 	bl	8002426 <device0_init>
 80025a8:	6865      	ldr	r5, [r4, #4]
 80025aa:	f8d5 f004 	ldr.w	pc, [r5, #4]

080025ae <deviceN_cmdHandler>:
 80025ae:	b580      	push	{r7, lr}
 80025b0:	f810 1b01 	ldrb.w	r1, [r0], #1
 80025b4:	f001 0103 	and.w	r1, r1, #3
 80025b8:	e8df f001 	tbb	[pc, r1]

080025bc <deviceN_fns>:
 80025bc:	09070502 	.word	0x09070502

080025c0 <placeholder0>:
 80025c0:	f20f 0010 	addw	r0, pc, #16
 80025c4:	bd80      	pop	{r7, pc}

080025c6 <placeholder1>:
 80025c6:	a009      	add	r0, pc, #36	@ (adr r0, 80025ec <placeholder0_msg+0x1a>)
 80025c8:	bd80      	pop	{r7, pc}

080025ca <placeholder2>:
 80025ca:	a00f      	add	r0, pc, #60	@ (adr r0, 8002608 <placeholder1_msg+0x1a>)
 80025cc:	bd80      	pop	{r7, pc}

080025ce <placeholder3>:
 80025ce:	a015      	add	r0, pc, #84	@ (adr r0, 8002624 <placeholder2_msg+0x1a>)
 80025d0:	bd80      	pop	{r7, pc}

080025d2 <placeholder0_msg>:
 80025d2:	6c70      	.short	0x6c70
 80025d4:	68656361 	.word	0x68656361
 80025d8:	65646c6f 	.word	0x65646c6f
 80025dc:	64203072 	.word	0x64203072
 80025e0:	2073656f 	.word	0x2073656f
 80025e4:	68746f6e 	.word	0x68746f6e
 80025e8:	0a676e69 	.word	0x0a676e69
 80025ec:	000d      	.short	0x000d

080025ee <placeholder1_msg>:
 80025ee:	6c70      	.short	0x6c70
 80025f0:	68656361 	.word	0x68656361
 80025f4:	65646c6f 	.word	0x65646c6f
 80025f8:	64203172 	.word	0x64203172
 80025fc:	2073656f 	.word	0x2073656f
 8002600:	68746f6e 	.word	0x68746f6e
 8002604:	0a676e69 	.word	0x0a676e69
 8002608:	000d      	.short	0x000d

0800260a <placeholder2_msg>:
 800260a:	6c70      	.short	0x6c70
 800260c:	68656361 	.word	0x68656361
 8002610:	65646c6f 	.word	0x65646c6f
 8002614:	64203272 	.word	0x64203272
 8002618:	2073656f 	.word	0x2073656f
 800261c:	68746f6e 	.word	0x68746f6e
 8002620:	0a676e69 	.word	0x0a676e69
 8002624:	000d      	.short	0x000d

08002626 <placeholder3_msg>:
 8002626:	6c70      	.short	0x6c70
 8002628:	68656361 	.word	0x68656361
 800262c:	65646c6f 	.word	0x65646c6f
 8002630:	64203372 	.word	0x64203372
 8002634:	2073656f 	.word	0x2073656f
 8002638:	68746f6e 	.word	0x68746f6e
 800263c:	0a676e69 	.word	0x0a676e69
 8002640:	000d      	.short	0x000d

08002642 <deviceN_defaultTask0>:
 8002642:	bdb0      	pop	{r4, r5, r7, pc}

08002644 <deviceN_defaultTask1>:
 8002644:	f241 5000 	movw	r0, #5376	@ 0x1500
 8002648:	f2c2 0000 	movt	r0, #8192	@ 0x2000
 800264c:	f8c5 004c 	str.w	r0, [r5, #76]	@ 0x4c
 8002650:	f241 40f4 	movw	r0, #5364	@ 0x14f4
 8002654:	f2c2 0000 	movt	r0, #8192	@ 0x2000
 8002658:	f000 f89a 	bl	8002790 <MoT_doCmdList>
 800265c:	f242 606f 	movw	r0, #9839	@ 0x266f
 8002660:	f6c0 0000 	movt	r0, #2048	@ 0x800
 8002664:	f04f 0100 	mov.w	r1, #0
 8002668:	6068      	str	r0, [r5, #4]
 800266a:	60e9      	str	r1, [r5, #12]
 800266c:	bdb0      	pop	{r4, r5, r7, pc}

0800266e <deviceN_defaultTask2>:
 800266e:	f241 40f4 	movw	r0, #5364	@ 0x14f4
 8002672:	f2c2 0000 	movt	r0, #8192	@ 0x2000
 8002676:	f8c5 004c 	str.w	r0, [r5, #76]	@ 0x4c
 800267a:	f241 5000 	movw	r0, #5376	@ 0x1500
 800267e:	f2c2 0000 	movt	r0, #8192	@ 0x2000
 8002682:	f000 f885 	bl	8002790 <MoT_doCmdList>
 8002686:	f242 6045 	movw	r0, #9797	@ 0x2645
 800268a:	f6c0 0000 	movt	r0, #2048	@ 0x800
 800268e:	f04f 0100 	mov.w	r1, #0
 8002692:	6068      	str	r0, [r5, #4]
 8002694:	60e9      	str	r1, [r5, #12]
 8002696:	bdb0      	pop	{r4, r5, r7, pc}

08002698 <MoT_doTasks>:
 8002698:	b5b0      	push	{r4, r5, r7, lr}
 800269a:	4604      	mov	r4, r0
 800269c:	6825      	ldr	r5, [r4, #0]
 800269e:	f8d5 f004 	ldr.w	pc, [r5, #4]

080026a2 <MoT_doCmd>:
 80026a2:	f810 2b01 	ldrb.w	r2, [r0], #1
 80026a6:	f851 5022 	ldr.w	r5, [r1, r2, lsl #2]
 80026aa:	f8d5 f000 	ldr.w	pc, [r5]

080026ae <MoT_taskUpdate>:
 80026ae:	b580      	push	{r7, lr}
 80026b0:	6068      	str	r0, [r5, #4]
 80026b2:	60e9      	str	r1, [r5, #12]
 80026b4:	bd80      	pop	{r7, pc}

080026b6 <MoT_skipTask>:
 80026b6:	68ad      	ldr	r5, [r5, #8]
 80026b8:	f8d5 f004 	ldr.w	pc, [r5, #4]

080026bc <MoT_msglistUpdate>:
 80026bc:	6802      	ldr	r2, [r0, #0]
 80026be:	b902      	cbnz	r2, 80026c2 <MoT_msglistUpdate+0x6>
 80026c0:	4770      	bx	lr
 80026c2:	68c1      	ldr	r1, [r0, #12]
 80026c4:	b101      	cbz	r1, 80026c8 <MoT_msglistUpdate+0xc>
 80026c6:	4770      	bx	lr
 80026c8:	6813      	ldr	r3, [r2, #0]
 80026ca:	6011      	str	r1, [r2, #0]
 80026cc:	4293      	cmp	r3, r2
 80026ce:	d005      	beq.n	80026dc <MoT_msglistUpdate+0x20>
 80026d0:	6003      	str	r3, [r0, #0]
 80026d2:	685a      	ldr	r2, [r3, #4]
 80026d4:	6082      	str	r2, [r0, #8]
 80026d6:	689a      	ldr	r2, [r3, #8]
 80026d8:	60c2      	str	r2, [r0, #12]
 80026da:	4770      	bx	lr
 80026dc:	6001      	str	r1, [r0, #0]
 80026de:	6041      	str	r1, [r0, #4]
 80026e0:	4770      	bx	lr

080026e2 <MoT_msgPost>:
 80026e2:	6803      	ldr	r3, [r0, #0]
 80026e4:	b113      	cbz	r3, 80026ec <MoT_msgPost+0xa>
 80026e6:	f04f 30ff 	mov.w	r0, #4294967295
 80026ea:	4770      	bx	lr
 80026ec:	684b      	ldr	r3, [r1, #4]
 80026ee:	b94b      	cbnz	r3, 8002704 <MoT_msgPost+0x22>
 80026f0:	6008      	str	r0, [r1, #0]
 80026f2:	6048      	str	r0, [r1, #4]
 80026f4:	6000      	str	r0, [r0, #0]
 80026f6:	6842      	ldr	r2, [r0, #4]
 80026f8:	608a      	str	r2, [r1, #8]
 80026fa:	6882      	ldr	r2, [r0, #8]
 80026fc:	60ca      	str	r2, [r1, #12]
 80026fe:	f04f 0000 	mov.w	r0, #0
 8002702:	4770      	bx	lr
 8002704:	6018      	str	r0, [r3, #0]
 8002706:	6048      	str	r0, [r1, #4]
 8002708:	6000      	str	r0, [r0, #0]
 800270a:	f04f 0000 	mov.w	r0, #0
 800270e:	4770      	bx	lr

08002710 <MoT_msglistGetchar>:
 8002710:	6881      	ldr	r1, [r0, #8]
 8002712:	68c2      	ldr	r2, [r0, #12]
 8002714:	b912      	cbnz	r2, 800271c <MoT_msglistGetchar+0xc>
 8002716:	f04f 30ff 	mov.w	r0, #4294967295
 800271a:	4770      	bx	lr
 800271c:	f811 3b01 	ldrb.w	r3, [r1], #1
 8002720:	f1a2 0201 	sub.w	r2, r2, #1
 8002724:	6081      	str	r1, [r0, #8]
 8002726:	60c2      	str	r2, [r0, #12]
 8002728:	4618      	mov	r0, r3
 800272a:	4770      	bx	lr

0800272c <MoT_cmdlistUpdate>:
 800272c:	6801      	ldr	r1, [r0, #0]
 800272e:	b901      	cbnz	r1, 8002732 <MoT_cmdlistUpdate+0x6>
 8002730:	4770      	bx	lr
 8002732:	b521      	push	{r0, r5, lr}
 8002734:	6848      	ldr	r0, [r1, #4]
 8002736:	f810 1b01 	ldrb.w	r1, [r0], #1
 800273a:	f854 5021 	ldr.w	r5, [r4, r1, lsl #2]
 800273e:	682a      	ldr	r2, [r5, #0]
 8002740:	4790      	blx	r2
 8002742:	e8bd 4021 	ldmia.w	sp!, {r0, r5, lr}
 8002746:	6802      	ldr	r2, [r0, #0]
 8002748:	6811      	ldr	r1, [r2, #0]
 800274a:	4291      	cmp	r1, r2
 800274c:	f04f 0300 	mov.w	r3, #0
 8002750:	6013      	str	r3, [r2, #0]
 8002752:	d102      	bne.n	800275a <MoT_cmdlistUpdate+0x2e>
 8002754:	6003      	str	r3, [r0, #0]
 8002756:	6043      	str	r3, [r0, #4]
 8002758:	4770      	bx	lr
 800275a:	6001      	str	r1, [r0, #0]
 800275c:	e7e9      	b.n	8002732 <MoT_cmdlistUpdate+0x6>

0800275e <MoT_cmdlistReset>:
 800275e:	6801      	ldr	r1, [r0, #0]
 8002760:	b901      	cbnz	r1, 8002764 <MoT_cmdlistReset+0x6>
 8002762:	4770      	bx	lr
 8002764:	6802      	ldr	r2, [r0, #0]
 8002766:	6811      	ldr	r1, [r2, #0]
 8002768:	4291      	cmp	r1, r2
 800276a:	f04f 0300 	mov.w	r3, #0
 800276e:	6013      	str	r3, [r2, #0]
 8002770:	d102      	bne.n	8002778 <MoT_cmdlistReset+0x1a>
 8002772:	6003      	str	r3, [r0, #0]
 8002774:	6043      	str	r3, [r0, #4]
 8002776:	4770      	bx	lr
 8002778:	6001      	str	r1, [r0, #0]
 800277a:	e7f3      	b.n	8002764 <MoT_cmdlistReset+0x6>

0800277c <MoT_doCtask>:
 800277c:	68e8      	ldr	r0, [r5, #12]
 800277e:	4780      	blx	r0
 8002780:	68ad      	ldr	r5, [r5, #8]
 8002782:	f8d5 f004 	ldr.w	pc, [r5, #4]

08002786 <SysTick_doCwait>:
 8002786:	68e8      	ldr	r0, [r5, #12]
 8002788:	4780      	blx	r0
 800278a:	68ad      	ldr	r5, [r5, #8]
 800278c:	f8d5 f004 	ldr.w	pc, [r5, #4]

08002790 <MoT_doCmdList>:
 8002790:	b580      	push	{r7, lr}
 8002792:	6841      	ldr	r1, [r0, #4]
 8002794:	6081      	str	r1, [r0, #8]
 8002796:	b421      	push	{r0, r5}
 8002798:	6801      	ldr	r1, [r0, #0]
 800279a:	b909      	cbnz	r1, 80027a0 <MoT_doCmdList+0x10>
 800279c:	bc21      	pop	{r0, r5}
 800279e:	bd80      	pop	{r7, pc}
 80027a0:	6882      	ldr	r2, [r0, #8]
 80027a2:	4291      	cmp	r1, r2
 80027a4:	6848      	ldr	r0, [r1, #4]
 80027a6:	f810 2b01 	ldrb.w	r2, [r0], #1
 80027aa:	f241 5118 	movw	r1, #5400	@ 0x1518
 80027ae:	f2c2 0100 	movt	r1, #8192	@ 0x2000
 80027b2:	f851 5022 	ldr.w	r5, [r1, r2, lsl #2]
 80027b6:	682a      	ldr	r2, [r5, #0]
 80027b8:	4790      	blx	r2
 80027ba:	bf00      	nop
 80027bc:	bc21      	pop	{r0, r5}
 80027be:	6801      	ldr	r1, [r0, #0]
 80027c0:	680a      	ldr	r2, [r1, #0]
 80027c2:	4291      	cmp	r1, r2
 80027c4:	d106      	bne.n	80027d4 <MoT_doCmdList+0x44>
 80027c6:	f04f 0200 	mov.w	r2, #0
 80027ca:	6002      	str	r2, [r0, #0]
 80027cc:	6042      	str	r2, [r0, #4]
 80027ce:	6082      	str	r2, [r0, #8]
 80027d0:	600a      	str	r2, [r1, #0]
 80027d2:	bd80      	pop	{r7, pc}
 80027d4:	6002      	str	r2, [r0, #0]
 80027d6:	f04f 0200 	mov.w	r2, #0
 80027da:	600a      	str	r2, [r1, #0]
 80027dc:	e7db      	b.n	8002796 <MoT_doCmdList+0x6>
 80027de:	bc21      	pop	{r0, r5}
 80027e0:	bd80      	pop	{r7, pc}

080027e2 <MoT_doCmdLink>:
 80027e2:	b520      	push	{r5, lr}
 80027e4:	6840      	ldr	r0, [r0, #4]
 80027e6:	f810 2b01 	ldrb.w	r2, [r0], #1
 80027ea:	f851 5022 	ldr.w	r5, [r1, r2, lsl #2]
 80027ee:	f8d5 f000 	ldr.w	pc, [r5]
 80027f2:	bd20      	pop	{r5, pc}

080027f4 <MoT_postCmd>:
 80027f4:	b580      	push	{r7, lr}
 80027f6:	6803      	ldr	r3, [r0, #0]
 80027f8:	b113      	cbz	r3, 8002800 <MoT_postCmd+0xc>
 80027fa:	f04f 30ff 	mov.w	r0, #4294967295
 80027fe:	bd80      	pop	{r7, pc}
 8002800:	684b      	ldr	r3, [r1, #4]
 8002802:	b913      	cbnz	r3, 800280a <MoT_postCmd+0x16>
 8002804:	6008      	str	r0, [r1, #0]
 8002806:	6048      	str	r0, [r1, #4]
 8002808:	e001      	b.n	800280e <MoT_postCmd+0x1a>
 800280a:	6018      	str	r0, [r3, #0]
 800280c:	6048      	str	r0, [r1, #4]
 800280e:	6000      	str	r0, [r0, #0]
 8002810:	f04f 0000 	mov.w	r0, #0
 8002814:	bd80      	pop	{r7, pc}

08002816 <userCOM_MsgPost>:
 8002816:	b672      	cpsid	i
 8002818:	b580      	push	{r7, lr}
 800281a:	685a      	ldr	r2, [r3, #4]
 800281c:	b112      	cbz	r2, 8002824 <userCOM_MsgPost+0xe>
 800281e:	6090      	str	r0, [r2, #8]
 8002820:	6058      	str	r0, [r3, #4]
 8002822:	e004      	b.n	800282e <userCOM_MsgPost+0x18>
 8002824:	f7fd fecd 	bl	80005c2 <userCOM_IRQenable>
 8002828:	b910      	cbnz	r0, 8002830 <userCOM_MsgPost+0x1a>
 800282a:	6018      	str	r0, [r3, #0]
 800282c:	6058      	str	r0, [r3, #4]
 800282e:	6080      	str	r0, [r0, #8]
 8002830:	b662      	cpsie	i
 8002832:	bd80      	pop	{r7, pc}

08002834 <userCOM_MsgsInit>:
 8002834:	f04f 0100 	mov.w	r1, #0
 8002838:	6001      	str	r1, [r0, #0]
 800283a:	6041      	str	r1, [r0, #4]
 800283c:	4770      	bx	lr

0800283e <userCOM_RXbuffer_init>:
 800283e:	b580      	push	{r7, lr}
 8002840:	f241 5014 	movw	r0, #5396	@ 0x1514
 8002844:	f2c2 0000 	movt	r0, #8192	@ 0x2000
 8002848:	6800      	ldr	r0, [r0, #0]
 800284a:	f241 5110 	movw	r1, #5392	@ 0x1510
 800284e:	f2c2 0100 	movt	r1, #8192	@ 0x2000
 8002852:	6809      	ldr	r1, [r1, #0]
 8002854:	f000 f933 	bl	8002abe <ringbufbuf_init>
 8002858:	bd80      	pop	{r7, pc}

0800285a <userCOM_RXgetbuf0>:
 800285a:	b580      	push	{r7, lr}
 800285c:	f241 5014 	movw	r0, #5396	@ 0x1514
 8002860:	f2c2 0000 	movt	r0, #8192	@ 0x2000
 8002864:	6800      	ldr	r0, [r0, #0]
 8002866:	f000 f8f4 	bl	8002a52 <ringbufbuf0_rd>
 800286a:	bd80      	pop	{r7, pc}

0800286c <userCOM_RXgetbuf1>:
 800286c:	b580      	push	{r7, lr}
 800286e:	f241 5014 	movw	r0, #5396	@ 0x1514
 8002872:	f2c2 0000 	movt	r0, #8192	@ 0x2000
 8002876:	6800      	ldr	r0, [r0, #0]
 8002878:	f000 f906 	bl	8002a88 <ringbufbuf1_rd>
 800287c:	bd80      	pop	{r7, pc}

0800287e <userCOM_RXresetRXBUF0_NUMOVERRUNS>:
 800287e:	f241 5114 	movw	r1, #5396	@ 0x1514
 8002882:	f2c2 0100 	movt	r1, #8192	@ 0x2000
 8002886:	6809      	ldr	r1, [r1, #0]
 8002888:	f04f 0000 	mov.w	r0, #0
 800288c:	f821 0c20 	strh.w	r0, [r1, #-32]
 8002890:	4770      	bx	lr

08002892 <userCOM_RXgetRXBUF0_NUMOVERRUNS>:
 8002892:	f241 5114 	movw	r1, #5396	@ 0x1514
 8002896:	f2c2 0100 	movt	r1, #8192	@ 0x2000
 800289a:	6809      	ldr	r1, [r1, #0]
 800289c:	f831 0c20 	ldrh.w	r0, [r1, #-32]
 80028a0:	4770      	bx	lr

080028a2 <userCOM_RXresetRXBUF0_NUMNEWLINES>:
 80028a2:	f241 5114 	movw	r1, #5396	@ 0x1514
 80028a6:	f2c2 0100 	movt	r1, #8192	@ 0x2000
 80028aa:	6809      	ldr	r1, [r1, #0]
 80028ac:	f04f 0000 	mov.w	r0, #0
 80028b0:	f821 0c1c 	strh.w	r0, [r1, #-28]
 80028b4:	4770      	bx	lr

080028b6 <userCOM_RXgetRXBUF0_NUMNEWLINES>:
 80028b6:	f241 5114 	movw	r1, #5396	@ 0x1514
 80028ba:	f2c2 0100 	movt	r1, #8192	@ 0x2000
 80028be:	6809      	ldr	r1, [r1, #0]
 80028c0:	f831 0c1c 	ldrh.w	r0, [r1, #-28]
 80028c4:	4770      	bx	lr

080028c6 <userCOM_RXresetRXBUF1_NUMOVERRUNS>:
 80028c6:	f241 5114 	movw	r1, #5396	@ 0x1514
 80028ca:	f2c2 0100 	movt	r1, #8192	@ 0x2000
 80028ce:	6809      	ldr	r1, [r1, #0]
 80028d0:	f04f 0000 	mov.w	r0, #0
 80028d4:	f821 0c1e 	strh.w	r0, [r1, #-30]
 80028d8:	4770      	bx	lr

080028da <userCOM_RXgetRXBUF1_NUMOVERRUNS>:
 80028da:	f241 5114 	movw	r1, #5396	@ 0x1514
 80028de:	f2c2 0100 	movt	r1, #8192	@ 0x2000
 80028e2:	6809      	ldr	r1, [r1, #0]
 80028e4:	f831 0c1e 	ldrh.w	r0, [r1, #-30]
 80028e8:	4770      	bx	lr

080028ea <userCOM_RXresetRXBUF1_NUMNEWLINES>:
 80028ea:	f241 5114 	movw	r1, #5396	@ 0x1514
 80028ee:	f2c2 0100 	movt	r1, #8192	@ 0x2000
 80028f2:	6809      	ldr	r1, [r1, #0]
 80028f4:	f04f 0000 	mov.w	r0, #0
 80028f8:	f821 0c1a 	strh.w	r0, [r1, #-26]
 80028fc:	4770      	bx	lr

080028fe <userCOM_RXgetRXBUF1_NUMNEWLINES>:
 80028fe:	f241 5114 	movw	r1, #5396	@ 0x1514
 8002902:	f2c2 0100 	movt	r1, #8192	@ 0x2000
 8002906:	6809      	ldr	r1, [r1, #0]
 8002908:	f831 0c1a 	ldrh.w	r0, [r1, #-26]
 800290c:	4770      	bx	lr

0800290e <userCOM_resetRXBUF_NUMERRORS>:
 800290e:	f241 5114 	movw	r1, #5396	@ 0x1514
 8002912:	f2c2 0100 	movt	r1, #8192	@ 0x2000
 8002916:	6809      	ldr	r1, [r1, #0]
 8002918:	f04f 0000 	mov.w	r0, #0
 800291c:	f801 0c24 	strb.w	r0, [r1, #-36]
 8002920:	4770      	bx	lr

08002922 <userCOM_getRXBUF_NUMERRORS>:
 8002922:	f241 5114 	movw	r1, #5396	@ 0x1514
 8002926:	f2c2 0100 	movt	r1, #8192	@ 0x2000
 800292a:	6809      	ldr	r1, [r1, #0]
 800292c:	f811 0c24 	ldrb.w	r0, [r1, #-36]
 8002930:	4770      	bx	lr

08002932 <userCOM_resetRXBUF_NUMUNKNOWNS>:
 8002932:	f241 5114 	movw	r1, #5396	@ 0x1514
 8002936:	f2c2 0100 	movt	r1, #8192	@ 0x2000
 800293a:	6809      	ldr	r1, [r1, #0]
 800293c:	f04f 0000 	mov.w	r0, #0
 8002940:	f801 0c23 	strb.w	r0, [r1, #-35]
 8002944:	4770      	bx	lr

08002946 <userCOM_getRXBUF_NUMUNKNOWNS>:
 8002946:	f241 5114 	movw	r1, #5396	@ 0x1514
 800294a:	f2c2 0100 	movt	r1, #8192	@ 0x2000
 800294e:	6809      	ldr	r1, [r1, #0]
 8002950:	f811 0c23 	ldrb.w	r0, [r1, #-35]
 8002954:	4770      	bx	lr

08002956 <userCOM_resetRXBUF_NUMPUTFAILS>:
 8002956:	f241 5114 	movw	r1, #5396	@ 0x1514
 800295a:	f2c2 0100 	movt	r1, #8192	@ 0x2000
 800295e:	6809      	ldr	r1, [r1, #0]
 8002960:	f04f 0000 	mov.w	r0, #0
 8002964:	f801 0c22 	strb.w	r0, [r1, #-34]
 8002968:	4770      	bx	lr

0800296a <userCOM_getRXBUF_NUMPUTFAILS>:
 800296a:	f241 5114 	movw	r1, #5396	@ 0x1514
 800296e:	f2c2 0100 	movt	r1, #8192	@ 0x2000
 8002972:	6809      	ldr	r1, [r1, #0]
 8002974:	f811 0c22 	ldrb.w	r0, [r1, #-34]
 8002978:	4770      	bx	lr

0800297a <userCOM_resetRXBUF_NUMOTHERFAILS>:
 800297a:	f241 5114 	movw	r1, #5396	@ 0x1514
 800297e:	f2c2 0100 	movt	r1, #8192	@ 0x2000
 8002982:	6809      	ldr	r1, [r1, #0]
 8002984:	f04f 0000 	mov.w	r0, #0
 8002988:	f801 0c21 	strb.w	r0, [r1, #-33]
 800298c:	4770      	bx	lr

0800298e <userCOM_getRXBUF_NUMOTHERFAILS>:
 800298e:	f241 5114 	movw	r1, #5396	@ 0x1514
 8002992:	f2c2 0100 	movt	r1, #8192	@ 0x2000
 8002996:	6809      	ldr	r1, [r1, #0]
 8002998:	f811 0c21 	ldrb.w	r0, [r1, #-33]
 800299c:	4770      	bx	lr

0800299e <userCOM_RXBUF0_discard>:
 800299e:	b580      	push	{r7, lr}
 80029a0:	f241 5014 	movw	r0, #5396	@ 0x1514
 80029a4:	f2c2 0000 	movt	r0, #8192	@ 0x2000
 80029a8:	6800      	ldr	r0, [r0, #0]
 80029aa:	f000 f8a4 	bl	8002af6 <ringbufbuf0_reset>
 80029ae:	bd80      	pop	{r7, pc}

080029b0 <userCOM_RXBUF1_discard>:
 80029b0:	b580      	push	{r7, lr}
 80029b2:	f241 5014 	movw	r0, #5396	@ 0x1514
 80029b6:	f2c2 0000 	movt	r0, #8192	@ 0x2000
 80029ba:	6800      	ldr	r0, [r0, #0]
 80029bc:	f000 f8a6 	bl	8002b0c <ringbufbuf1_reset>
 80029c0:	bd80      	pop	{r7, pc}

080029c2 <userCOM_ringbufbuf_wr>:
 80029c2:	b580      	push	{r7, lr}
 80029c4:	4601      	mov	r1, r0
 80029c6:	f241 5014 	movw	r0, #5396	@ 0x1514
 80029ca:	f2c2 0000 	movt	r0, #8192	@ 0x2000
 80029ce:	6800      	ldr	r0, [r0, #0]
 80029d0:	f000 f828 	bl	8002a24 <ringbufbuf_wr>
 80029d4:	bd80      	pop	{r7, pc}

080029d6 <userCOM_updateRXBUF_NUMERRORS>:
 80029d6:	f241 5114 	movw	r1, #5396	@ 0x1514
 80029da:	f2c2 0100 	movt	r1, #8192	@ 0x2000
 80029de:	6809      	ldr	r1, [r1, #0]
 80029e0:	f811 0c24 	ldrb.w	r0, [r1, #-36]
 80029e4:	f100 0001 	add.w	r0, r0, #1
 80029e8:	f801 0c24 	strb.w	r0, [r1, #-36]
 80029ec:	4770      	bx	lr

080029ee <userCOM_updateRXBUF_NUMUNKNOWNS>:
 80029ee:	f241 5114 	movw	r1, #5396	@ 0x1514
 80029f2:	f2c2 0100 	movt	r1, #8192	@ 0x2000
 80029f6:	6809      	ldr	r1, [r1, #0]
 80029f8:	f811 0c23 	ldrb.w	r0, [r1, #-35]
 80029fc:	f100 0001 	add.w	r0, r0, #1
 8002a00:	f801 0c23 	strb.w	r0, [r1, #-35]
 8002a04:	4770      	bx	lr

08002a06 <userCOM_updateRXBUF_NUMPUTFAILS>:
 8002a06:	f241 5114 	movw	r1, #5396	@ 0x1514
 8002a0a:	f2c2 0100 	movt	r1, #8192	@ 0x2000
 8002a0e:	6809      	ldr	r1, [r1, #0]
 8002a10:	f811 0c22 	ldrb.w	r0, [r1, #-34]
 8002a14:	f100 0001 	add.w	r0, r0, #1
 8002a18:	f801 0c22 	strb.w	r0, [r1, #-34]
 8002a1c:	4770      	bx	lr

08002a1e <Call_Failed>:
 8002a1e:	f04f 30ff 	mov.w	r0, #4294967295
 8002a22:	4770      	bx	lr

08002a24 <ringbufbuf_wr>:
 8002a24:	b672      	cpsid	i
 8002a26:	f850 2c04 	ldr.w	r2, [r0, #-4]
 8002a2a:	5481      	strb	r1, [r0, r2]
 8002a2c:	3201      	adds	r2, #1
 8002a2e:	f850 3c08 	ldr.w	r3, [r0, #-8]
 8002a32:	1a99      	subs	r1, r3, r2
 8002a34:	bf08      	it	eq
 8002a36:	460a      	moveq	r2, r1
 8002a38:	f840 2c04 	str.w	r2, [r0, #-4]
 8002a3c:	f850 1c10 	ldr.w	r1, [r0, #-16]
 8002a40:	4299      	cmp	r1, r3
 8002a42:	bf0e      	itee	eq
 8002a44:	f840 2c18 	streq.w	r2, [r0, #-24]
 8002a48:	3101      	addne	r1, #1
 8002a4a:	f840 1c10 	strne.w	r1, [r0, #-16]
 8002a4e:	b662      	cpsie	i
 8002a50:	4770      	bx	lr

08002a52 <ringbufbuf0_rd>:
 8002a52:	b672      	cpsid	i
 8002a54:	f850 2c10 	ldr.w	r2, [r0, #-16]
 8002a58:	b91a      	cbnz	r2, 8002a62 <ringbufbuf0_rd+0x10>
 8002a5a:	f04f 30ff 	mov.w	r0, #4294967295
 8002a5e:	b662      	cpsie	i
 8002a60:	4770      	bx	lr
 8002a62:	f1a2 0201 	sub.w	r2, r2, #1
 8002a66:	f840 2c10 	str.w	r2, [r0, #-16]
 8002a6a:	f850 1c18 	ldr.w	r1, [r0, #-24]
 8002a6e:	5c42      	ldrb	r2, [r0, r1]
 8002a70:	3101      	adds	r1, #1
 8002a72:	f850 3c08 	ldr.w	r3, [r0, #-8]
 8002a76:	1a5b      	subs	r3, r3, r1
 8002a78:	bf0c      	ite	eq
 8002a7a:	f840 3c18 	streq.w	r3, [r0, #-24]
 8002a7e:	f840 1c18 	strne.w	r1, [r0, #-24]
 8002a82:	4610      	mov	r0, r2
 8002a84:	b662      	cpsie	i
 8002a86:	4770      	bx	lr

08002a88 <ringbufbuf1_rd>:
 8002a88:	b672      	cpsid	i
 8002a8a:	f850 2c0c 	ldr.w	r2, [r0, #-12]
 8002a8e:	b91a      	cbnz	r2, 8002a98 <ringbufbuf1_rd+0x10>
 8002a90:	f04f 30ff 	mov.w	r0, #4294967295
 8002a94:	b662      	cpsie	i
 8002a96:	4770      	bx	lr
 8002a98:	f1a2 0201 	sub.w	r2, r2, #1
 8002a9c:	f840 2c0c 	str.w	r2, [r0, #-12]
 8002aa0:	f850 1c14 	ldr.w	r1, [r0, #-20]
 8002aa4:	5c42      	ldrb	r2, [r0, r1]
 8002aa6:	3101      	adds	r1, #1
 8002aa8:	f850 3c08 	ldr.w	r3, [r0, #-8]
 8002aac:	1a5b      	subs	r3, r3, r1
 8002aae:	bf0c      	ite	eq
 8002ab0:	f840 3c14 	streq.w	r3, [r0, #-20]
 8002ab4:	f840 1c14 	strne.w	r1, [r0, #-20]
 8002ab8:	4610      	mov	r0, r2
 8002aba:	b662      	cpsie	i
 8002abc:	4770      	bx	lr

08002abe <ringbufbuf_init>:
 8002abe:	b672      	cpsid	i
 8002ac0:	f840 1c08 	str.w	r1, [r0, #-8]
 8002ac4:	f850 1c1e 	ldr.w	r1, [r0, #-30]
 8002ac8:	f04f 0200 	mov.w	r2, #0
 8002acc:	f820 2c1c 	strh.w	r2, [r0, #-28]
 8002ad0:	f820 2c20 	strh.w	r2, [r0, #-32]
 8002ad4:	f840 2c18 	str.w	r2, [r0, #-24]
 8002ad8:	f840 2c10 	str.w	r2, [r0, #-16]
 8002adc:	f820 2c1a 	strh.w	r2, [r0, #-26]
 8002ae0:	f820 2c1e 	strh.w	r2, [r0, #-30]
 8002ae4:	f840 2c14 	str.w	r2, [r0, #-20]
 8002ae8:	f840 2c0c 	str.w	r2, [r0, #-12]
 8002aec:	f840 2c04 	str.w	r2, [r0, #-4]
 8002af0:	4608      	mov	r0, r1
 8002af2:	b662      	cpsie	i
 8002af4:	4770      	bx	lr

08002af6 <ringbufbuf0_reset>:
 8002af6:	b672      	cpsid	i
 8002af8:	f850 1c04 	ldr.w	r1, [r0, #-4]
 8002afc:	f840 1c18 	str.w	r1, [r0, #-24]
 8002b00:	f04f 0100 	mov.w	r1, #0
 8002b04:	f840 1c10 	str.w	r1, [r0, #-16]
 8002b08:	b662      	cpsie	i
 8002b0a:	4770      	bx	lr

08002b0c <ringbufbuf1_reset>:
 8002b0c:	b672      	cpsid	i
 8002b0e:	f850 1c04 	ldr.w	r1, [r0, #-4]
 8002b12:	f840 1c14 	str.w	r1, [r0, #-20]
 8002b16:	f04f 0100 	mov.w	r1, #0
 8002b1a:	f840 1c0c 	str.w	r1, [r0, #-12]
 8002b1e:	b662      	cpsie	i
 8002b20:	4770      	bx	lr
	...

08002b24 <__udivsi3>:
 8002b24:	2900      	cmp	r1, #0
 8002b26:	d002      	beq.n	8002b2e <__udivsi3+0xa>
 8002b28:	fbb0 f0f1 	udiv	r0, r0, r1
 8002b2c:	4770      	bx	lr
 8002b2e:	b108      	cbz	r0, 8002b34 <__udivsi3+0x10>
 8002b30:	f04f 30ff 	mov.w	r0, #4294967295
 8002b34:	f000 b808 	b.w	8002b48 <__aeabi_idiv0>

08002b38 <__aeabi_uidivmod>:
 8002b38:	2900      	cmp	r1, #0
 8002b3a:	d0f8      	beq.n	8002b2e <__udivsi3+0xa>
 8002b3c:	4602      	mov	r2, r0
 8002b3e:	fbb0 f0f1 	udiv	r0, r0, r1
 8002b42:	fb00 2111 	mls	r1, r0, r1, r2
 8002b46:	4770      	bx	lr

08002b48 <__aeabi_idiv0>:
 8002b48:	4770      	bx	lr
 8002b4a:	bf00      	nop

08002b4c <link_tasks>:
MoT_core_t *devicelist[] = {&device0, &userLED, &blueBUTTON, &device3,  &device4, &device5, &device6, &device7, &device8, &deviceN};	 //device0, deviceN must be first, last

void * MoT_doTasks(MoT_core_t *list[] ); // in MoTservices_xx.S; dispatches device tasks

// note: MoT uses an exhaustive linked list of tasks for speed. 'link_devicetasks()' below initializes the device-task list
void link_tasks(MoT_core_t *list[], int num ) {
 8002b4c:	b480      	push	{r7}
 8002b4e:	b085      	sub	sp, #20
 8002b50:	af00      	add	r7, sp, #0
 8002b52:	6078      	str	r0, [r7, #4]
 8002b54:	6039      	str	r1, [r7, #0]
	int i;
	for(i=0;i<num-1;i++) {				//'num-1' because the final device (deviceN) does not have a successor. 
 8002b56:	2300      	movs	r3, #0
 8002b58:	60fb      	str	r3, [r7, #12]
 8002b5a:	e00e      	b.n	8002b7a <link_tasks+0x2e>
		list[i]->nexttask = list[i+1];	//style-trial
 8002b5c:	68fb      	ldr	r3, [r7, #12]
 8002b5e:	3301      	adds	r3, #1
 8002b60:	009b      	lsls	r3, r3, #2
 8002b62:	687a      	ldr	r2, [r7, #4]
 8002b64:	441a      	add	r2, r3
 8002b66:	68fb      	ldr	r3, [r7, #12]
 8002b68:	009b      	lsls	r3, r3, #2
 8002b6a:	6879      	ldr	r1, [r7, #4]
 8002b6c:	440b      	add	r3, r1
 8002b6e:	681b      	ldr	r3, [r3, #0]
 8002b70:	6812      	ldr	r2, [r2, #0]
 8002b72:	609a      	str	r2, [r3, #8]
	for(i=0;i<num-1;i++) {				//'num-1' because the final device (deviceN) does not have a successor. 
 8002b74:	68fb      	ldr	r3, [r7, #12]
 8002b76:	3301      	adds	r3, #1
 8002b78:	60fb      	str	r3, [r7, #12]
 8002b7a:	683b      	ldr	r3, [r7, #0]
 8002b7c:	3b01      	subs	r3, #1
 8002b7e:	68fa      	ldr	r2, [r7, #12]
 8002b80:	429a      	cmp	r2, r3
 8002b82:	dbeb      	blt.n	8002b5c <link_tasks+0x10>
	}
}
 8002b84:	bf00      	nop
 8002b86:	bf00      	nop
 8002b88:	3714      	adds	r7, #20
 8002b8a:	46bd      	mov	sp, r7
 8002b8c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002b90:	4770      	bx	lr
	...

08002b94 <main>:

int main(void)
{
 8002b94:	b580      	push	{r7, lr}
 8002b96:	b082      	sub	sp, #8
 8002b98:	af00      	add	r7, sp, #0
	int devnum=sizeof(devicelist)/sizeof(&devicelist[0]);		
 8002b9a:	230a      	movs	r3, #10
 8002b9c:	607b      	str	r3, [r7, #4]

	SystemClock_init2();							//initialize millisecond interrupt and timers
 8002b9e:	f7fd fd5c 	bl	800065a <SystemClock_init2>
	SysTick_init();
 8002ba2:	f7fd fd1a 	bl	80005da <SysTick_init>
	HW_userCOM_init();								//initialize user USART, USART interrupt, and message buffers
 8002ba6:	f7fd fc8e 	bl	80004c6 <HW_userCOM_init>
	link_tasks(devicelist,devnum);
 8002baa:	6879      	ldr	r1, [r7, #4]
 8002bac:	4803      	ldr	r0, [pc, #12]	@ (8002bbc <main+0x28>)
 8002bae:	f7ff ffcd 	bl	8002b4c <link_tasks>

	while (1)
	{
		MoT_doTasks(devicelist);	//in MoTservices*.S
 8002bb2:	4802      	ldr	r0, [pc, #8]	@ (8002bbc <main+0x28>)
 8002bb4:	f7ff fd70 	bl	8002698 <MoT_doTasks>
 8002bb8:	e7fb      	b.n	8002bb2 <main+0x1e>
 8002bba:	bf00      	nop
 8002bbc:	20001518 	.word	0x20001518

08002bc0 <Reset_Handler>:
Reset_Handler: @;!!wmh Note: CopyDataInit() and FillZerobss() functions  are written differently but probably do the same things
@;!!wmh  ldr   r0, =_estack		wmh--this is done by linker in ROM image
@;!!wmh  mov   sp, r0          /* set stack pointer */

/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
 8002bc0:	480c      	ldr	r0, [pc, #48]	@ (8002bf4 <SystemInit+0x4>)
  ldr r1, =_edata
 8002bc2:	490d      	ldr	r1, [pc, #52]	@ (8002bf8 <SystemInit+0x8>)
  ldr r2, =_sidata
 8002bc4:	4a0d      	ldr	r2, [pc, #52]	@ (8002bfc <SystemInit+0xc>)
  movs r3, #0
 8002bc6:	2300      	movs	r3, #0
  b	LoopCopyDataInit
 8002bc8:	e002      	b.n	8002bd0 <LoopCopyDataInit>

08002bca <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
 8002bca:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 8002bcc:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 8002bce:	3304      	adds	r3, #4

08002bd0 <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 8002bd0:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 8002bd2:	428c      	cmp	r4, r1
  bcc CopyDataInit
 8002bd4:	d3f9      	bcc.n	8002bca <CopyDataInit>
  
/* Zero fill the bss segment. */
  ldr r2, =_sbss
 8002bd6:	4a0a      	ldr	r2, [pc, #40]	@ (8002c00 <SystemInit+0x10>)
  ldr r4, =_ebss
 8002bd8:	4c0a      	ldr	r4, [pc, #40]	@ (8002c04 <SystemInit+0x14>)
  movs r3, #0
 8002bda:	2300      	movs	r3, #0
  b LoopFillZerobss
 8002bdc:	e001      	b.n	8002be2 <LoopFillZerobss>

08002bde <FillZerobss>:

FillZerobss:
  str  r3, [r2]
 8002bde:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 8002be0:	3204      	adds	r2, #4

08002be2 <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
 8002be2:	42a2      	cmp	r2, r4
  bcc FillZerobss
 8002be4:	d3fb      	bcc.n	8002bde <FillZerobss>

/* Call the clock system initialization function.*/
    bl  SystemInit
 8002be6:	f000 f803 	bl	8002bf0 <SystemInit>
/* Call static constructors */
@;!!wmh    bl __libc_init_array
/* Call the application's entry point.*/
	bl	main
 8002bea:	f7ff ffd3 	bl	8002b94 <main>

08002bee <LoopForever>:

LoopForever:
    b LoopForever
 8002bee:	e7fe      	b.n	8002bee <LoopForever>

08002bf0 <SystemInit>:

SystemInit:	@;!!wmh stubbed off for now
	bx lr	@; immediate return
 8002bf0:	4770      	bx	lr
 8002bf2:	0000      	.short	0x0000
  ldr r0, =_sdata
 8002bf4:	20000000 	.word	0x20000000
  ldr r1, =_edata
 8002bf8:	20001540 	.word	0x20001540
  ldr r2, =_sidata
 8002bfc:	08002c2c 	.word	0x08002c2c
  ldr r2, =_sbss
 8002c00:	20001540 	.word	0x20001540
  ldr r4, =_ebss
 8002c04:	200015fc 	.word	0x200015fc

08002c08 <ADC1_2_IRQHandler>:
 * @retval : None
*/
    .section	.text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
	b	Infinite_Loop
 8002c08:	e7fe      	b.n	8002c08 <ADC1_2_IRQHandler>
	...

08002c0c <_init>:
 8002c0c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8002c0e:	bf00      	nop
 8002c10:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8002c12:	bc08      	pop	{r3}
 8002c14:	469e      	mov	lr, r3
 8002c16:	4770      	bx	lr

08002c18 <_fini>:
 8002c18:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8002c1a:	bf00      	nop
 8002c1c:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8002c1e:	bc08      	pop	{r3}
 8002c20:	469e      	mov	lr, r3
 8002c22:	4770      	bx	lr
